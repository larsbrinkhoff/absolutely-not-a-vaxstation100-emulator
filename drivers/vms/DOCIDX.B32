MODULE DOC$IDX (
		IDENT = 'VSTADOC Utility INDEX routines'
		,ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = GENERAL)
		) =
BEGIN
!++
!
! ABSTRACT:
!
!	This module provides subroutines for INDEX.
!
! ENVIRONMENT:
!
! VAX Workstation Document file generation utility.
!
!--
!
! TABLE OF CONTENTS:
!
FORWARD ROUTINE
    doc$$idx_init,		!Init indexing procedures.
    doc$$gen_index,		!Put an item in the index
    open_sort_file,		!Open SORT file (a temp index file)
    build_record,		!Routine to build a record.
    doc$$do_index,		!Write the index.
    gen_idx_pages,		!Generate the pages of the index.
    get_idx_line,		!Get next IDX line
    compute_and_write_line,	!Write the IDX line
    selectable_pn,		!Make page number selectable
    rewind_idx_file,		!Rewind the file and prepare to read SEQ.
    grab_1_record,		!Read in a record from the index file.
    write_idx_header,		!Write the header line on the index page.
    close_sort_file;		!Close (and delete) SORT file
!
! INCLUDE FILES:
!
LIBRARY 'SYS$LIBRARY:STARLET';
LIBRARY 'VSTA$LIBRARY:DOCDATA';	!Various internal data structures
				! and constants.
LIBRARY 'VSTA$LIBRARY:DOCFILE';	!File constants
LIBRARY 'VSTA$LIBRARY:DOCMACS';	!Macros

EXTERNAL ROUTINE
    doc$$append_list_line,	!Append string to current list line
    doc$$put_list_line,		!Write out current list line
    doc$$error,			!Report an error
    doc$$type_line,		!Type out a line on TTY
    doc$$gen_set_linesize,	!##: SET LINESIZE nn :##
    doc$$gen_lm,		!##: LEFTMARGIN nn :##
    doc$$gen_rm,		!##: RIGHTMARGIN nn :##
    doc$$gen_eol,		!end of line
    doc$$gen_ff,		!<FF>
    doc$$gen_nofill,		!##: NOFILL :##
    doc$$gen_off_pagenums,	!Turn off page number generation
    doc$$gen_set_typeface,	!##: SET TYPEFACE :##
    doc$$gen_set_typesize,	!##: SET TYPESIZE :##
    doc$$gen_set_rendition,	!##: SET RENDITION :##
    doc$$measure_text,		!Get width & height of string
    doc$$gen_text_string,	!Generate text string
    doc$$gen_center,		!##: CENTER "text" :##
    doc$$gen_blank,		!##: BLANK :##
    doc$$gen_selectable;	!Generate selectable string

EXTERNAL
    doc$gl_cur_page_num,	!Current page number
    doc$gl_cur_gen_vd,		!Current generate vd.
    fatal_error,
    num_user_errors,		!Number of user errors processed
    last_pagex,			!X dimension of page
    last_pagey;			!Y dimension of page

GLOBAL
    doc$gl_num_body_pages,	!Number of pages in the body.
    doc$gl_num_index_pages;	!Number of pages in the index.

MACRO
    hdr_tf_str = 'PELLUCIDA' %,		!Typeface used for the header
    tf_str = 'PELLUCIDA' %;		!Typeface used for INDEX lines
LITERAL
    hdr_tf_len = %CHARCOUNT (hdr_tf_str),
    tf_len = %CHARCOUNT (tf_str);
BIND
    hdr_typeface_str = UPLIT (hdr_tf_str),
    idx_typeface_str = UPLIT (tf_str);
LITERAL
    hdr_line_height = 35,		!Line height of header
    idx_line_height = 15,		!Line height of regular lines
    idx_leftmargin = 5,			!Left margin for regular lines
    space_after_header = 15,		!Blank space after header
    hdr_typesize = 20,			!Typesize used for header lines
    idx_typesize = 12,			!Typesize used for regular lines
    hdr_rend = 0,			!Rendition used for header
    idx_rend = 0;			!Rendition used for regular lines
OWN
    idx_hdr_str_desc: VECTOR [2]
		INITIAL (%CHARCOUNT ('Index'), UPLIT ('Index')),
    idx_typeface_desc: VECTOR [2]
		INITIAL (tf_len, idx_typeface_str),
    hdr_typeface_desc: VECTOR [2]
		INITIAL (hdr_tf_len, hdr_typeface_str),
    comma_width,			!Width (pixels) of a comma

    record_buf: sort_rec_block,	!VECTOR [srb$K_rec_length,BYTE],
    rec_desc: VECTOR [2]
		INITIAL (srb$K_rec_length, record_buf),
    sort_open_flag,		!=1 if sort file is open.
    num_idx_entries,		!How many IDX entries there are.
    num_entries_read,		!Number of IDX entries read in.
  !
  ! The key of the record is "sorted-str","real-str",page_num
  ! Thus entries like "select","[select]",3 are different from
  ! "select","select",3.
  !
    sort_key_xab:
	$XABKEY	(DTP = STG	!String datatype
		,POS = 0	!Starts in first byte
		,SIZ = srb$K_key_size
		),
    sort_fab: $FAB
		(ORG = IDX
		,FNM = 'IDXTEMP.IDX'
		,FAC = <GET,PUT>
		,ALQ = 50
		,BKS = 4	!A reasonable bucket size
		,DEQ = 100	!Default extension quantity
		,FOP = <CBT,DFW,TMD,TMP>
		,MRS = srb$K_rec_length	!Maximum record size
		,RFM = <FIX>	!Fixed length records
		,XAB = sort_key_xab
		),
    sort_rab: $RAB
		(FAB = sort_fab
		,RBF = record_buf
		,UBF = record_buf
		,RSZ = srb$K_rec_length
		,USZ = srb$K_rec_length
		);

GLOBAL ROUTINE doc$$idx_init =
!++
! FUNCTIONAL DESCRIPTION:
!	Initializes indexing procedures and data.
!	Basically, cleans up from old generate, if necessary.
!--
BEGIN

IF (.sort_open_flag)
  THEN close_sort_file ();

num_idx_entries = 0;		!Count number of IDX entries in the file
num_entries_read = 0;		!Count number we've read back in.
RETURN SS$_NORMAL
END;

GLOBAL ROUTINE doc$$gen_index
!++
! FUNCTIONAL DESCRIPTION:
!	Put item in the index.
! FORMAL PARAMETERS:
	(str_desc
	) =
!--
BEGIN
LOCAL
   status;

IF NOT (build_record (.str_desc))
  THEN RETURN .status;		!Already printed error

IF (NOT (.sort_open_flag))
  THEN
    BEGIN
    IF NOT (status =
	open_sort_file ()
	   )
      THEN
	BEGIN
	fatal_error = 1;
	$typeline ('%FATAL: Error opening INDEX sorting file:');
	RETURN doc$$error (.status);
	END;
    END;
!
! Insert record if we can.
!
IF NOT (status =
    $put	(RAB = sort_rab)
	)
  THEN
    BEGIN
    IF (.sort_rab [rab$l_sts] EQL RMS$_DUP)
      THEN
	BEGIN
	$typeline ('%WARN: Duplicate INDEX reference on this page');
	doc$$append_list_line (%ASCID '%WARN: Duplicate INDEX reference on this page');
	doc$$put_list_line ();
	RETURN SS$_NORMAL
	END
      ELSE
	BEGIN
	$typeline ('%FATAL: Cant $put INDEX record:');
	RETURN doc$$error (.status);
	END;
    END;
!
! Record stored in file
!
num_idx_entries = .num_idx_entries + 1;		!Count how many we have.
RETURN SS$_NORMAL
END;

GLOBAL ROUTINE doc$$do_index =
!++
! FUNCTIONAL DESCRIPTION:
!	Creates the index.
! IMPLICIT OUTPUTS:
!	doc$gl_num_body_pages
!	doc$gl_num_index_pages
!--
BEGIN
LOCAL
    start_pagenum,
    junk,
    status;

doc$gl_num_body_pages = .doc$gl_cur_page_num;
doc$gl_num_index_pages = 0;		!Count number of index pages used.
start_pagenum = .doc$gl_cur_page_num;
!
! If no index items, just return now.
!
IF (.num_idx_entries EQL 0)
  THEN RETURN SS$_NORMAL;
!
! Set parameters to do the index. LM=5, RM=pagesize, LINESIZE=15
!
doc$$gen_nofill ();				!Set NOFILL
doc$$gen_set_linesize (idx_line_height);
doc$$gen_lm (0, idx_leftmargin);
doc$$gen_rm (0, .last_pagex);			! . .
doc$$gen_set_typeface (idx_typeface_desc);
doc$$gen_set_typesize (idx_typesize);
doc$$gen_set_rendition (idx_rend, -1);
doc$$measure_text	(.doc$gl_cur_gen_vd
			,1		!Length of string
			,UPLIT (',')	!Address of string
			,comma_width	!Returned x dimension
			,junk		!Returned height
			);
IF (.junk GTR idx_line_height)
  THEN
    BEGIN
    $typeline ('? INDEX linesize too small for font!');
    RETURN SS$_BADPARAM
    END;
!
! Generate the pages
!
gen_idx_pages ();

doc$gl_num_index_pages = .doc$gl_cur_page_num - .start_pagenum;
RETURN SS$_NORMAL
END;

ROUTINE gen_idx_pages =
!++
! FUNCTIONAL DESCRIPTION:
!	Generate the IDX pages.
!	LM, RM, linesize, fonts, all set up.
!--
BEGIN
LOCAL
    lines_this_page,		!How many lines are on this page.
    lines_cango,		!Total lines
    eof_flag,			!=1 if EOF seen
    status;

eof_flag = 0;			!Set to 1 if EOF seen
lines_cango = (.last_pagey - hdr_line_height - space_after_header)
		/ idx_line_height;		!Total # of index lines per pg.
!
! Rewind index file to start reading it sequentially
!
IF NOT (status =
    rewind_idx_file ()
	)
  THEN RETURN .status;
!
! Get the first record into the buffer to prime the pump.
!
IF NOT (status =
    grab_1_record ()
	)
  THEN RETURN .status;
!
! Index lines look like this:
!index-item-name,p1[,p2,p3...]
!
doc$$gen_ff ();			!Start a new page
doc$$gen_off_pagenums ();	!No page numbers from now on, please.
write_idx_header ();

WHILE 1 DO			!EXITLOOP when EOF seen
    BEGIN
    lines_this_page = 0;	!# Lines written so far.
    WHILE (.lines_this_page LSS .lines_cango) DO
	BEGIN
	IF NOT (status =
	    get_idx_line (eof_flag)	!Get next index line	
		)
	  THEN RETURN .status;
	IF (.eof_flag) THEN EXITLOOP;
	lines_this_page = .lines_this_page + 1;
	END;
    IF (.eof_flag) THEN EXITLOOP;	
    doc$$gen_ff ();		!<FF>
    write_idx_header ();	!"index" at top of page.
    END;

RETURN SS$_NORMAL
END;

ROUTINE get_idx_line
!++
! FUNCTIONAL DESCRIPTION:
!	Read from the IDX file until we have gone past the
!	last entry that is the same. Compute the IDX line and
!	write it out.
!
! FORMAL PARAMETERS:
	(eof_flag
	) =
!--
BEGIN
LOCAL
    idx_str: VECTOR [srb$K_key_length, BYTE],
    idx_str_desc: VECTOR [2],
    pn_str: VECTOR [256,BYTE],	!the string "p1[,p2..]"
    pn_desc: VECTOR [2],
    num_refs,			!number refs so far.
    refs: VECTOR [10,WORD],	!Page number references.
    rem_pn_desc: VECTOR [2],	!Descriptor to remainder of pn string
    fao_len: WORD,		!Length output from $fao
    too_many_refs_flag,		!Set to 1 if too many page refs
    status;

pn_desc [0] = 0;
pn_desc [1] = pn_str;
rem_pn_desc [0] = 256;
rem_pn_desc [1] = pn_str;
refs [0] = .record_buf [srb$w_page_num];	!Remember 1st page ref
num_refs = 1;			!1 ref so far
too_many_refs_flag = 0;		!if too many refs, set this flag

idx_str_desc [0] = .record_buf [srb$w_idx_str_len];
idx_str_desc [1] = idx_str;
CH$MOVE	(.idx_str_desc [0]
	,record_buf [srb$b_idx_str]
	,idx_str
	);
!
! Write first page number in pn_str
!
IF NOT (status =
    $fao	(%ASCID ' !SL'		!CTRSTR - decimal number
		,fao_len		!OUTLEN
		,rem_pn_desc		!OUTSTR
		,.record_buf [srb$w_page_num]	!P1
		)
	)
  THEN
    BEGIN
    $typeline ('?$fao failed to write index page number');
    RETURN doc$$error (.status);
    END;
!
! Loop until there are no more page references to this item
!
WHILE 1 DO
    BEGIN
    pn_desc [0] = .pn_desc [0] + .fao_len;		!Update pn_desc
    rem_pn_desc [0] = .rem_pn_desc [0] - .fao_len;	! and rem_desc
    rem_pn_desc [1] = .rem_pn_desc [1] + .fao_len;	! . .

    IF (.num_entries_read EQL .num_idx_entries)
      THEN
	BEGIN				!No more entries in the file.
	.eof_flag = 1;			!Return "EOF" after we write the line.
	EXITLOOP;
	END;
    IF NOT (status =
	grab_1_record ()
	    )
      THEN RETURN .status;
    IF (.record_buf [srb$w_idx_str_len] NEQ .idx_str_desc [0])
      THEN EXITLOOP;		!Different index item found.
    IF (CH$NEQ	(.idx_str_desc [0]	!length1
		,.idx_str_desc [1]	!ptr1
		,.idx_str_desc [0]	!length2
		,record_buf [srb$b_idx_str] !ptr2
		)
	)
      THEN EXITLOOP;		!Different index item found.
  !
  ! Another reference.. add the page number.
  !
    IF (.num_refs LEQ 10)
      THEN
	BEGIN
	refs [.num_refs] = .record_buf [srb$w_page_num];
	num_refs = .num_refs + 1;
	IF NOT (status =
	    $fao	(%ASCID ', !SL'		!CTRSTR
			,fao_len		!OUTLEN
			,rem_pn_desc		!OUTSTR
			,.record_buf [srb$w_page_num]
			)
		)
	  THEN
	    BEGIN
	    $typeline ('?$fao failed to write index page number');
	    RETURN doc$$error (.status);
	    END;
	END
      ELSE
	too_many_refs_flag = 1;

    END;		!Of "WHILE 1 DO"

pn_str [.pn_desc [0]] = %C' ';		!Put space at end
pn_desc [0] = .pn_desc [0] + 1;

IF (.too_many_refs_flag)
  THEN				!User should try to break this up..
    $gen_error ('%WARN: Too many page references for an INDEX item');
!
! Compute the total index line and write it out.
!
IF NOT (status =
    compute_and_write_line
		(idx_str_desc	!Descriptor to the idx item itself
		,pn_desc	!descriptor to the page number(s) string
		,.num_refs	!How many page refs
		,refs		!Address of refs array
		)
	)
  THEN RETURN .status;

RETURN SS$_NORMAL
END;

ROUTINE compute_and_write_line
!++
! FUNCTIONAL DESCRIPTION:
!	Computes the IDX Line and writes it out.
! FORMAL PARAMETERS:
	(idx_str_desc: REF VECTOR [2]	!Descriptor to the idx item itself
	,pn_desc: REF VECTOR [2]	!Descriptor to the page number(s) str.
	,num_refs			!How many page refs
	,refs: REF VECTOR [10,WORD]	!The page refs
	) =
!--
BEGIN
LOCAL
    idx_line_desc: VECTOR [2],
    idx_line_str: VECTOR [512,BYTE],
    width_idx_str,			!# pixels in IDX str
    width_pn_str,			!# pixels in PN str
    rem_desc: VECTOR [2],
    which_ref,
    junk,
    status;

idx_line_desc [1] = idx_line_str;	!Descriptor points to string

!
! Make sure strings will fit
!
doc$$measure_text
	(.doc$gl_cur_gen_vd
	,.idx_str_desc [0]	!Length of string
	,.idx_str_desc [1]	!Address of str
	,width_idx_str		!Returned width
	,junk			!returned height
	);
doc$$measure_text
	(.doc$gl_cur_gen_vd
	,.pn_desc [0]		!Length of string
	,.pn_desc [1]		!Address of string
	,width_pn_str		!Returned width
	,junk			!Returned height
	);

IF ((.comma_width + .width_idx_str + .width_pn_str) GTR .last_pagex)
  THEN
    BEGIN
    $gen_error ('%WARN: Index line too wide for virtual display');
    RETURN SS$_NORMAL
    END;
!
! Append the comma to the initial string, and write it out.
!
CH$MOVE	(.idx_str_desc [0]
	,.idx_str_desc [1]
	,idx_line_str
	);
idx_line_str [.idx_str_desc [0]] = %C',';
idx_line_desc [0] = .idx_str_desc [0] + 1;
doc$$gen_text_string (idx_line_desc);		!Write "idx-entry,"
!
! Now, all the page numbers are selectable.
!
rem_desc [0] = .pn_desc [0];
rem_desc [1] = .pn_desc [1];
which_ref = 0;
WHILE (.rem_desc [0] NEQ 0) DO
    BEGIN
    selectable_pn	(rem_desc		!Ptr to string (gets updated)
			,.refs [.which_ref]	!Which page number
			);
    which_ref = .which_ref + 1;
    END;

doc$$gen_eol ();
RETURN SS$_NORMAL
END;

ROUTINE selectable_pn
!++
! FUNCTIONAL DESCRIPTION:
!	Makes the next page number selectable,
!	then updates rem-desc.
! FORMAL PARAMETERS:
	(rem_desc: REF VECTOR [2]
	,page_num
	) =
!--
BEGIN
LOCAL
    str_desc: VECTOR [2],
    rd_str: REF VECTOR [,BYTE],
    first_nondig,		!Index of first non-digit
    status;

first_nondig = -1;
rd_str = .rem_desc [1];		!Get ptr to string
str_desc [1] = .rd_str;
INCR i FROM 1 TO (.rem_desc [0] - 1) DO		!"i" is index into rem_desc
    BEGIN
    IF ((.rd_str [.i] GTR %C'9')
		OR
	(.rd_str [.i] LSS %C'0'))
      THEN
	BEGIN
	first_nondig = .i;
	EXITLOOP
	END;
    END;

!
! Make that field selectable.
!
str_desc [0] = .first_nondig + 1;		!# of chars (including comma)
IF NOT (status =
    doc$$gen_selectable	(str_desc	!" nnn,"
			,0		!link
			,0		!Kwd-desc (none)
			,.page_num	!Which page number
			)
	)
  THEN RETURN SS$_BADPARAM;

IF (.first_nondig GEQ 0)
  THEN
    BEGIN
    rem_desc [0] = .rem_desc [0] - (.first_nondig + 1);
    rem_desc [1] = .rem_desc [1] + (.first_nondig + 1);
    END
  ELSE
    rem_desc [0] = 0;		!String ran out.

RETURN SS$_NORMAL
END;

ROUTINE rewind_idx_file =
!++
! FUNCTIONAL DESCRIPTION:
!	Rewinds the INDEX file and prepares to read it sequentially.
!--
BEGIN
LOCAL
    status;

sort_rab [rab$b_rac] = rab$c_seq;	!Read file sequentially

IF NOT (status =
    $rewind (RAB = sort_rab)
	)
  THEN
    BEGIN
    $typeline ('?Can''t $rewind INDEX temp file');
    RETURN doc$$error (.status);
    END;

RETURN SS$_NORMAL
END;

ROUTINE grab_1_record =
!++
! FUNCTIONAL DESCRIPTION:
!	Read next IDX record into record_buf
!	If errors, types out the error message.
!--
BEGIN
LOCAL
    status;

IF NOT (status =
    $get	(RAB = sort_rab)
	)
  THEN
    BEGIN
    $typeline ('? $get failed for INDEX temp file');
    RETURN doc$$error (.status)
    END;

num_entries_read = .num_entries_read + 1;	!Count another entry read in
RETURN SS$_NORMAL
END;

ROUTINE open_sort_file =
!++
! FUNCTIONAL DESCRIPTION:
!	Open the temporary index file used for sorting keys.
!--
BEGIN
LOCAL
    status;

IF NOT (status =
    $create	(FAB = sort_fab)
	)
  THEN RETURN .status;

IF NOT (status =
    $connect	(RAB = sort_rab)
	)
  THEN RETURN .status;
!
! Note in the RAB that we want KEY access.
!
sort_rab [rab$b_rac] = rab$c_key;

sort_open_flag = 1;	!Remember sort file is open

RETURN SS$_NORMAL
END;

ROUTINE build_record
!++
! FUNCTIONAL DESCRIPTION:
!	Given an index item, build the record for the index file.
! FORMAL PARAMETERS:
	(idx_desc: REF VECTOR [2]	!Desc of index item
	) =
! IMPLICIT OUTPUTS:
!	record_buf - output record.
!--
BEGIN
LOCAL
    idx_len: WORD,
    key_len: WORD,
    ch_bufaddr: REF VECTOR [,BYTE],
    ch: BYTE,
    key_to_sort: VECTOR [srb$k_key_length, BYTE],
    status;

idx_len = .idx_desc [0];	!Get length of record passed

IF (.idx_len GTR srb$k_key_length)
  THEN idx_len = srb$k_key_length;	!Truncate to keyword length

record_buf [srb$w_idx_str_len] = .idx_len;
!
! Put actual index item in the record
!
CH$COPY	(.idx_len		!Length of source
	,.idx_desc [1]		!Source ptr1
	,%C' '			!Fill character (space)
	,srb$k_key_length	!Dest length
	,record_buf [srb$b_idx_str]	!Dest ptr.
	);
!
! Remember page reference (this is part of key)
!
record_buf [srb$w_page_num] = .doc$gl_cur_page_num;

!
! Get key to sort
! Start with first alphabetic or numeric character.
! Uppercase all lowercase characters.
!
ch_bufaddr = .idx_desc [1];	!So can ref character array.
key_len = 0;			!Length of sorted key, so far.
INCR i FROM 0 TO .idx_len-1 DO
    BEGIN
    ch = .ch_bufaddr [.i];	!Get character
  !
  ! Make lowercase into uppercase.
  !
    IF ((.ch GEQ %C'a') AND (.ch LEQ %C'z'))
      THEN ch = .ch - %O'40'	!Make uppercase
      ELSE
	IF ((.ch GEQ %X'E0') AND (.ch LEQ %X'FD'))
	  THEN ch = .ch - %O'40';
  !
  ! If letter or number, add it verbatim.
  !
    IF (((.ch GEQ %C'A') AND (.ch LEQ %C'Z'))
			OR
	((.ch GEQ %C'0') AND (.ch LEQ %C'9'))
			OR
	((.ch GEQ %X'C0') AND (.ch LEQ %X'DF')))
      THEN
	BEGIN
	key_to_sort [.key_len] = .ch;	!Copy uppercase character
	key_len = .key_len + 1;		!Bump dest idx.
	END;
    END;		!End while loop.

CH$COPY	(.key_len
	,key_to_sort
	,%C' '			!Fill character (space)
	,srb$k_key_length	!Dest length
	,record_buf [srb$b_key_to_sort] !DPTR
	);
!
! (debug) print record
!
!doc$$type_line (rec_desc);

RETURN SS$_NORMAL
END;

ROUTINE write_idx_header =
!++
! FUNCTIONAL DESCRIPTION:
!	Write "Index" at top of page, centered. Leaves font parameters
!	set for normal lines.
!--
BEGIN
!
! Set linesize and font parameters, then write the centered line.
!
doc$$gen_set_linesize (hdr_line_height);
doc$$gen_set_typeface (hdr_typeface_desc);
doc$$gen_set_typesize (hdr_typesize);
doc$$gen_set_rendition (hdr_rend, -1);
doc$$gen_center (idx_hdr_str_desc);	!Leaves us at beginning of next line
!
! Write a blank line to leave some space before normal lines
!
IF (space_after_header NEQ 0)
  THEN
    BEGIN
    doc$$gen_set_linesize (space_after_header);
    doc$$gen_blank (1);
    END;
!
! set linesize and font parameters for normal lines.
!
doc$$gen_set_linesize (idx_line_height);
doc$$gen_set_typeface (idx_typeface_desc);
doc$$gen_set_typesize (idx_typesize);
doc$$gen_set_rendition (idx_rend, -1);

RETURN SS$_NORMAL
END;

ROUTINE close_sort_file =
!++
! FUNCTIONAL DESCRIPTION:
!	Closes the index file (which deletes it).
!--
BEGIN
LOCAL
    status;

sort_open_flag = 0;		!Note file not open.

IF NOT (status =
    $close	(FAB = sort_fab)	!Deletes file
	)
  THEN
    BEGIN
    $typeline ('%FATAL: Can''t close INDEX temp. file:');
    RETURN doc$$error (.status);
    END;

RETURN SS$_NORMAL
END;

END
ELUDOM

MODULE VS$SRV_DEB (
			IDENT = 'HI SERVER Debug routines'
			,ADDRESSING_MODE (EXTERNAL = GENERAL,
					NONEXTERNAL = GENERAL)) =
BEGIN
!++
! FACILITY: VAXstation software (VS)
!
! Human interface (VSSERVE).
!
! ABSTRACT:
!
!   This module provides debugging aids to VSSERVE.
!
! ENVIRONMENT:
!
! Vax Workstation VSSERVE subsystem.
!
!--
!
! TABLE OF CONTENTS:
!
FORWARD ROUTINE
    vsta$$srv_init_debugging,	!An initial debugging routine
    vsta$$srv_deb_broad,	!Broadcast a string to the OPR
    vsta$$srv_tell_opr_dec,	!Broadcast string and decimal number
    vsta$$srv_tell_opr_hex,	!Broadcast string and hex number
    vsta$$srv_tell_opr_sts,	!Broadcast string and symbolic status
    vsta$$report_free_vm_error,	!Routine to tell opr about error trying
				! to free-up virtual memory.
    vsta$$srv_append_string,	!Append string 1 to string 2
    vsta$$srv_append_hex,	!Translate hex to ASCII and append
    vsta$$srv_append_dec,	!Translate dec to ASCII and append
    vsta$$srv_append_status,	!Append a symbolic status value to string
    vsta$$srv_inventory,	!Print out inventory of PIDs, VPs and windows
    vsta$$srv_print_jrb_q;	!print the job queue entries
!
! INCLUDE FILES:
!

LIBRARY 'SYS$LIBRARY:STARLET';
LIBRARY 'VSTA$LIBRARY:VSSRVMACS';	!Useful macros
LIBRARY 'VSTA$LIBRARY:VSSRVDATA';	!Data structures for VSSERVE
LIBRARY 'VSTA$LIBRARY:LIBMACROS';	!Common VSTA symbols/macros

!
! DEFINE PSECTS
!

$vsta_psect;

OWN
   line_of_text: BLOCK [250,BYTE],
   line_desc: VECTOR [2]
		INITIAL (0, line_of_text);

EXTERNAL ROUTINE
    ots$cvt_l_tz,		!Convert longword to hex ASCII string
    ots$cvt_l_ti,		!Convert longword to decimal ASCII string
    vsta$$srv_get_vd_devname;	!Convert VD-id to device name

EXTERNAL
    hi_vbname_desc: VECTOR [2],		!ASCII descriptor of "VBAn:"
    jrb_q_hdr: VECTOR [2];		!Q header for the JRB queue


GLOBAL ROUTINE vsta$$srv_init_debugging =
!++
! FUNCTIONAL DESCRIPTION:
!	This routine does whatever we want to debug
!--
BEGIN
OWN
    my_str: BLOCK [80,BYTE],		!Incase we need one..
    my_str_desc: VECTOR [2]
		INITIAL (0, my_str);

!vsta$$srv_deb_broad (%ASCID 'vsta$$srv_init_debugging');

RETURN SS$_NORMAL
END;

GLOBAL ROUTINE vsta$$srv_deb_broad
!++
! FUNCTIONAL DESCRIPTION:
!	Broadcasts a message to the operator.
!
! FORMAL PARAMETERS:
	(string_desc		!Address of string descriptor
	)=
!
! ROUTINE VALUE
!   Returns "ss$_normal" if successful, or
!	VS facility error status code
!--
BEGIN
LOCAL
    msgbuf: BLOCK [250,BYTE],	!A buffer
    msg_desc: VECTOR [2],
    status;			!Return status

msg_desc [0] = 0;		!Set string length = 0
msg_desc [1] = msgbuf;
!
! Put header in message
!
! "[ HI-VBA0: "
vsta$$srv_append_string (%ASCID '[ HI-', msg_desc);
vsta$$srv_append_string (hi_vbname_desc, msg_desc);
vsta$$srv_append_string (%ASCID ' ', msg_desc);
!
! Append given string to message
!
vsta$$srv_append_string (.string_desc, msg_desc);
!
! And give message a trailer
!
vsta$$srv_append_string (%ASCID ' ]', msg_desc);

IF NOT (status =
   $BRDCST	(MSGBUF = msg_desc	!Address of descriptor
		,DEVNAM = %ASCID '_OPA0:'
		)
	)
  THEN RETURN .status;

RETURN SS$_NORMAL		!Return success

END;

GLOBAL ROUTINE vsta$$srv_tell_opr_dec
!++
! FUNCTIONAL DESCRIPTION:
!	Broadcasts a message to the OPR, and appends to it the
!	decimal number supplied.
! FORMAL PARAMETERS:
	(str_text_desc		!Text string desc.
	,dec_num		!Decimal number
	) =
!--
BEGIN

line_desc [0] = 0;		!Start with blank line
vsta$$srv_append_string (.str_text_desc, line_desc);
vsta$$srv_append_dec (.dec_num, line_desc);
$pline;				!Print the line
RETURN SS$_NORMAL
END;

GLOBAL ROUTINE vsta$$srv_tell_opr_hex
!++
! FUNCTIONAL DESCRIPTION:
!	Broadcasts a message to the OPR, and appends to it the
!	hex number supplied.
! FORMAL PARAMETERS:
	(str_text_desc		!Text string desc.
	,hex_num		!Hex number
	) =
!--
BEGIN

line_desc [0] = 0;		!Start with blank line
vsta$$srv_append_string (.str_text_desc, line_desc);
vsta$$srv_append_hex (.hex_num, line_desc);
$pline;				!Print the line
RETURN SS$_NORMAL
END;

GLOBAL ROUTINE vsta$$srv_tell_opr_sts
!++
! FUNCTIONAL DESCRIPTION:
!	Tells opr about an error and prints its status symbolically.
! FORMAL PARAMETERS:
	(str_text_desc		!The text explaining the error
	,sts			!status code
	) =
!--
BEGIN

line_desc [0] = 0;		!Start with blank line
vsta$$srv_append_string (.str_text_desc, line_desc);
vsta$$srv_append_string (%ASCID ', status = ', line_desc);
vsta$$srv_append_status (.sts, line_desc);
$pline;
RETURN SS$_NORMAL
END;

GLOBAL ROUTINE vsta$$report_free_vm_error
!++
! FUNCTIONAL DESCRIPTION:
!	Tells opr about an error while trying to free-up
!	virtual memory.
! FORMAL PARAMETERS:
	(free_vm_stat		!Status value from "free-vm"
	,what_desc		!Description of type of block
	) =
!--
BEGIN
LOCAL
    str_1: BLOCK [256,BYTE],	!A string
    str_1_desc: VECTOR [2],	! and descriptor to it
    status;

str_1_desc [0] = 0;		!Start with empty string
str_1_desc [1] = str_1;

vsta$$srv_append_string
	(%ASCID '%error trying to free up memory used for ', str_1_desc);
vsta$$srv_append_string (.what_desc, str_1_desc);
vsta$$srv_deb_broad (str_1_desc);

str_1_desc [0] = 0;
vsta$$srv_append_string (%ASCID '  status = ', str_1_desc);
vsta$$srv_append_status (.free_vm_stat, str_1_desc);
vsta$$srv_deb_broad (str_1_desc);

RETURN SS$_NORMAL
END;

GLOBAL ROUTINE vsta$$srv_append_string
! ++
! FUNCTIONAL DESCRIPTION:
!	Appends string 1 to string 2
! FORMAL PARAMETERS:
	(str_1_desc		!String to append
	,str_2_desc		!String appended to
	)=
BEGIN
MAP
    str_1_desc: ref VECTOR[2],
    str_2_desc: ref VECTOR[2];
OWN
    msg_length: WORD,
    addr_buf_1,
    addr_buf_2;

msg_length = .str_1_desc [0];	!Length of message 1
				! Get rid of type bits, just want length
addr_buf_2 = .str_2_desc [0] + .str_2_desc [1];	!Address of place to
						! append string
addr_buf_1 = .str_1_desc [1];			!Address of string to append

str_2_desc [0] = .str_2_desc [0] + .msg_length;	!Add lengths
CH$MOVE	(.msg_length		!Number of bytes to move
	,.addr_buf_1		!From here
	,.addr_buf_2		!To here
	);

RETURN SS$_NORMAL
END;

GLOBAL ROUTINE vsta$$srv_append_hex
!++
! FUNCTIONAL DESCRIPTION:
!	Append hex number to string
! FORMAL PARAMETERS:
	(hex_num		!The hex number in a longword
	,str_desc		!The string descriptor.
	) =
BEGIN
OWN
    hex_str_buf: BLOCK [8,BYTE],	!Hex string to append
    hex_str_desc: VECTOR [2]
		INITIAL (8, hex_str_buf);

ots$cvt_l_tz (hex_num, hex_str_desc);	!Get 8 digits of hex number
RETURN vsta$$srv_append_string (hex_str_desc, .str_desc)

END;

GLOBAL ROUTINE vsta$$srv_append_dec
!++
! FUNCTIONAL DESCRIPTION:
!	Append dec number to string
! FORMAL PARAMETERS:
	(dec_num		!The decimal number in a longword
	,str_desc		!The string descriptor.
	) =
!--
BEGIN
OWN
    dec_str_string: BLOCK [12,BYTE],
    dec_str_desc: VECTOR [2]
		INITIAL (0, dec_str_string);
LOCAL
    the_number,
    ndigits;
!
! First we count the number of digits in the string
!
the_number = .dec_num;		!Get a copy of the number
ndigits = 0;
DO
    BEGIN
    ndigits = .ndigits + 1;
    the_number = .the_number / 10;
    END
  UNTIL (.the_number EQL 0); 
!
! Now get a string of that length
!
dec_str_desc [0] = .ndigits;

ots$cvt_l_ti (dec_num, dec_str_desc);	!Get text
RETURN vsta$$srv_append_string (dec_str_desc, .str_desc)
END;


GLOBAL ROUTINE vsta$$srv_append_status
!++
! FUNCTIONAL DESCRIPTION:
!	Appends a symbolic status string to a string
! FORMAL PARAMETERS:
	(code
	,str_desc
	) =
!--
BEGIN
LOCAL
    gmsg_str: BLOCK [256,BYTE],
    gmsg_desc: VECTOR [2],
    gmsg_returned_len: WORD,
    status;
!
! Do standard $getmsg call to get error string.
!
gmsg_desc [0] = 256;
gmsg_desc [1] = gmsg_str;

IF NOT (status =
    $getmsg	(MSGID = .code
		,MSGLEN = gmsg_returned_len
		,BUFADR = gmsg_desc
		)
	)
  THEN RETURN .status;			!Couldn't do it, just return

gmsg_desc [0] = .gmsg_returned_len;	!Get real string descriptor
RETURN vsta$$srv_append_string (gmsg_desc, .str_desc)
END;

GLOBAL ROUTINE vsta$$srv_inventory =
!++
! FUNCTIONAL DESCRIPTION:
!	Prints an inventory.
!--
BEGIN

vsta$$srv_print_jrb_q ();

RETURN SS$_NORMAL
END;

GLOBAL ROUTINE vsta$$srv_print_jrb_q =
!++
! FUNCTIONAL DESCRIPTION:
!	Prints selected info from the JRB queue
!--
BEGIN
LOCAL
   jrb_count,
   jrb: REF job_block,		!JRB entry ptr.
   wdb_q_head,			!address of window queue head
   wdb: REF window_data_block,	!Current WDB address
   wtype,			!Type of window
   vd_desc: VECTOR [2],
   vd_name: VECTOR [40,BYTE],
   vd_real_len;

vd_desc [1] = vd_name;		!Point to string, desc [0] gets filled in later

jrb_count = 0;			!Count entries in JRB
jrb = .jrb_q_hdr [0];		!Point to first entry to JRB queue
UNTIL (.jrb EQL jrb_q_hdr) DO
    BEGIN
    jrb_count = .jrb_count + 1;
    jrb = .jrb [JRB$A_FLINK];	!Go on to next entry
    END;

IF (.jrb_count EQL 0)
  THEN
	BEGIN
	$print ('[There are no job entries]');
	RETURN SS$_NORMAL
	END;

! Print out the contents of each
!
jrb = .jrb_q_hdr [0];		!Point to first entry
UNTIL (.jrb EQL jrb_q_hdr) DO
BEGIN
$sline ('*** PID: ');
$hex (.jrb [JRB$L_PID]);
$pline;
!
! Loop printing out VP entries
!
wdb_q_head = jrb [JRB$A_WDB_Q_HDR_FL]; 	!Get address of queue header
wdb = ..wdb_q_head;		!Point to first entry
UNTIL (.wdb EQL .wdb_q_head) DO
    BEGIN

    $sline ('Wtype: ');
    wtype = .wdb [wdb$b_window_type];
    (CASE .wtype
		FROM wdb$k_lowest_wtype TO wdb$k_highest_wtype OF
	SET
	[wdb$k_wtype_user]: $cline	('USER    ');
	[wdb$k_wtype_vt100]: $cline	('VT100   ');
	[wdb$k_wtype_4014]: $cline	('4014    ');
	[wdb$k_wtype_vsserve]: $cline	('HI      ');
	[wdb$k_wtype_help]: $cline 	('HELP    ');
	[wdb$k_wtype_prof]: $cline	('PROFILE ');
	[wdb$K_wtype_notice]: $cline	('NOTICE  ');
	[wdb$K_wtype_ts]: $cline	('TERMSET ');
	[outrange]:	 $cline		('?????   ');
	TES
    );
    $cline ('User win id:(w,h) = ');
    $dec (.wdb [wdb$l_u_window_id]);
    $cline (':(');
    $dec (.wdb [wdb$l_u_vp_width]);
    $cline (',');
    $dec (.wdb [wdb$l_u_vp_height]);
    $cline (') ');

    IF (.wdb [wdb$l_u_vp_id] NEQ 0)
      THEN
	BEGIN
	$cline ('Uvp id:(x,y)=');
	$dec (.wdb [wdb$l_u_vp_id]);
	$cline (':(');
	$dec (.wdb [wdb$l_u_vp_x_coor]);
	$cline (',');
	$dec (.wdb [wdb$l_u_vp_y_coor]);
	$cline (') Hivp id:(x,y)=');
	$dec (.wdb [wdb$l_hi_vp_id]);
	$cline (':(');
	$dec (.wdb [wdb$l_hi_vp_x_coor]);
	$cline (',');
	$dec (.wdb [wdb$l_hi_vp_y_coor]);
	$cline (')');
	END
      ELSE
	BEGIN
	$cline ('-- no vp''s -- ');
	END;
    IF (.wtype NEQ wdb$k_wtype_vsserve)
      THEN
	BEGIN
        $cline ('  VKB:');
	$dec (.wdb [wdb$l_u_pb_id]);		!Print out VKB id
        IF (.wtype NEQ wdb$k_wtype_user)
	  THEN
	    BEGIN
	    $cline (' Vd-id:');
	    vd_desc [0] = 20;			!Set string length
	    vsta$$srv_get_vd_devname (.wdb [wdb$l_term_vd_id], vd_desc, vd_real_len);
	    vd_desc [0] = .vd_real_len;
	    vsta$$srv_append_string (vd_desc, line_desc);
	    END;
	END;

    $pline;

    wdb = .wdb [wdb$a_flink];	!link through chain
    END;

jrb = .jrb [JRB$A_FLINK];	!Point to next entry
END;

RETURN SS$_NORMAL
END;
END
ELUDOM

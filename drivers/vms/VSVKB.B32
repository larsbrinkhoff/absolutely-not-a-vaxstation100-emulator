%TITLE 'vs$vkb -- VAXSTATION VIRTUAL KEYBOARD DRIVER'
MODULE vs$vkb(
		IDENT = '1.2-1',
		ADDRESSING_MODE (EXTERNAL = GENERAL,NONEXTERNAL = GENERAL)
		) =
BEGIN

!++
! FACILITY:
!   VAX WORKSTATIONS
!
! ABSTRACT:
!
!   This module contains all the routines and data structures relevent to
!   dealing with the VAXstation virtual keyboard as an entity in the context of
!   a VAX workstation running the associated workstation display software;
!   an implementation of the System Display Architecture.
!
!   Operations have been provided to allow creation, deletion, reads, and
!   associations of virtual keyboards to the physical keyboard.
!
! ENVIRONMENT:
!   VAX workstation: 780, 750, 730 running VMS with at least one VAXstation
!   graphics subsystem.
!
!--
!
! TABLE OF CONTENTS:
!

!
! INCLUDE FILES:
!
LIBRARY 'VSTA$LIBRARY:VSVKB';		! Virtual Keyboard data structures
LIBRARY 'VSTA$LIBRARY:VBDEF';		! Unencoded bit definitions
LIBRARY 'VSTA$LIBRARY:TTYDEFS';		! Virtual terminal definitions
LIBRARY 'VSTA$LIBRARY:VSACPDEF';	! VSACP definitions
LIBRARY 'VSTA$LIBRARY:VSTADEF';		! VBDRIVER function codes + modifiers
LIBRARY 'VSTA$LIBRARY:VSTAGBL';		! Universal symbols
LIBRARY 'VSTA$LIBRARY:LIBMACROS';	! Symbols like irp_block
LIBRARY 'VSTA$LIBRARY:VSVDSPB';		! Pasteboard data base offsets
LIBRARY 'VSTA$LIBRARY:VSERRORS';	! Error block symbols
LIBRARY 'VSTA$LIBRARY:LINKAGE';		! Get access to VMS system linkages
LIBRARY 'SYS$LIBRARY:LIB';		! Get access to VMS system routines
!
! When a non-privileged user program performs some operation that involves
! manipulating an object that the user doesn't have access to
! (such as pasting vt100 on it's pasteboard or pasting header with tablet
! icon on a human interface pasteboard), we need to allow the operation.
! The "requestor_pid" OPTIONAL parameter allows the human interface to declare
! that this operation is being done by US rather than the USER.
!
! The following macro sees if a specific requestor was specified, and uses
! it.  Otherwise, the global calling process's pid is used.
!
macro $requestor =
	begin
	external vs$gl_pid;
	if $parameter_or_0 (requestor_pid) neq 0
	then .requestor_pid
	else .vs$gl_pid
	end % ;

%SBTTL 'DECLARATIONS'
!
FORWARD ROUTINE
!
! Public routines (public to the VAXstation ACP)
!
	vs$$create_vkb,			!To create a virtual keyboard device
	vs$$delete_vkb,			!To delete a virtual keyboard device
	vs$$set_vkb_mode,		!To set mode of virtual keyboard device
	vs$$set_vkb_state,		!To set the state of a VKB (internal)
	vs$$get_vkb_state,		!To get the state of a VKB (internal)
	vs$$set_vkb_output,		!To set up VKB for output stream (echo)
	vs$$vkb_init_port,		!Initialize VKB to port driver link
	vs$$set_default_vkb,		!To set up VKB as default active VKB
	vs$$clear_default_vkb,		!Undo "vs$$set_default_vkb"
	vs$$set_vkb_char,		!To set certain VKB characteristics
	vs$$set_vkb_trans_table,	!To set VKB translation table
	vs$$vkb_set_nrc,		!To set new NRC for terminals
	vs$$set_vkb_devdepend,		!To set terminal-type characteristics
	vs$$get_vkb_char,		!To get certain VKB characteristics
	vs$$get_emulator_vkb,		!To get the VKB_ID for a VD_ID
	vs$$inject_input_stream,	!To stuff characters into input buffer
	vs$$read_vkb,			!To read from a virtual keyboard device
	vs$$vkb_cancel_read,		!To cancel an ongoing read on a VKB
	vs$$vkb_do_control_r,		!To do control R processing
	vs$$inquire_current_vkb,	!Determines the active vkb
	vs$$activate_vkb,		!To activate a virtual keyboard
	vs$$activate_terminal,		!To activate a virtual terminal
	vs$$vkb_wake,			!Setup notification on character input
	vs$$deactivate_vkb,		!To deactivate a virtual keyboard
	vs$$deactivate_terminal,	!To deactivate a virtual terminal
	vs$$set_vkb_break_table,	!To change the break table of a vkb
	vs$$get_vkb_break_table,	!To get the break table of a vkb
!
! Private routines
!
	vs$$vkb_done_io: NOVALUE,	!VKB I/O completion processing routine
	vs$$read_complete_ast,		!VBDRIVER read completion AST
	vs$$read_timeout_ast,		!VKB read timeout AST
	vs$$typeahead_full_ast,		!Typeahead buffer full AST routine
	vs$$reconnect_kb_ast,		!Reconnect keyboard when lost
	vs$$do_unsolicited: NOVALUE,	!Process unsolicited input
	vs$$read_satisfied,		!Determine if read satisfied
	vs$$process_char,		!Process character during read
	vs$$char_available,		!Get next available character
	vs$$vkb_hi_key,			!See if key owned by human interface
	vsta$$vkb_encoder,		!Up/down to DECMS translation routine
	vs$$native_vkb_translator,	!Eight-bit/seven-bit native codes
	vs$$special_char,		!Special character processing
	vs$$display_prompt: NOVALUE,	!Display prompt string if appropriate
	vs$$echo_character: NOVALUE,	!Character echo processing
	vs$$do_control_r: NOVALUE,	!Control R processing
	vs$$do_control_u: NOVALUE,	!Control U processing
	vs$$purge_user_buffer: NOVALUE,	!Purge the user's buffer
	vs$$deactivate_current_vkb: NOVALUE, !Deactivate current VKB on PKB
	vs$$vkb_loadtt,			!To load new translation table
	vs$$vkb_load_nrc,		!To load new NRC table
	vs$$vkb_load_symbol_table,	!To load new symbol table
	vs$$vkb_found,			!To find a vkb data block by ID
	vs$$free_vkb: NOVALUE,		!To free up all VKB memory occupied
	vs$$flush_asts,			!To flush all VKB AST lists
	vs$$end_of_read,		!Max. char. count or break table match
!
! The following routines access the ring buffer or perform special processing
! and must run in kernel mode
!
	vs$$do_control_c: NOVALUE,	!Control C specific processing
	vs$$do_control_y: NOVALUE,	!Control Y processing
	vs$$control_y_handler: NOVALUE,	!Control Y handler
	vs$$do_control_o: NOVALUE,	!Control O processing
	vs$$do_control_q: NOVALUE,	!Control Q processing
	vs$$do_control_s: NOVALUE,	!Control S processing
	vs$$do_control_x: NOVALUE,	!Control X processing
	vs$$do_out_of_band,		!Out-of-band character processing
	vs$$do_delete: NOVALUE,		!Delete character processing
	vs$$delete_escape: NOVALUE,	!Delete escape sequence processing
	vs$$cancel_control_s: NOVALUE,	!Cancel control S processing
	vs$$purge_typeahead: NOVALUE,	!Purge the typeahead buffer of a VKB
	vs$$get_device_char: NOVALUE,	!Get VKB device characteristics
	vs$$no_typeahead: NOVALUE,	!Clear typeahead indicators (in UCB)
	vs$$send_mbx_msg,		!Send unsolicited data msg if needed
	vs$$check_escape,		!Validate escape sequence input
	vs$$escape_done,		!Validate escape sequence character
	vs$$get_encoded_char,		!Get encoded character (kernel mode)
	vs$$preview_typeahead,		!Preview typeahead for unsolicited data
	vs$$delete_typeahead,		!Delete last unsolicited character
	vs$$get_ring_buffer,		!Allocate ring buffer (non-paged pool)
	vs$$release_ring_buffer,	!Deallocate ring buffer
	vs$$kmode_move;			!Move the specified number of bytes
!
!
! EXTERNAL ROUTINES
!
EXTERNAL ROUTINE
	vsta$$get_ef,				! RTL event flag allocation
	lib$free_ef,				! RTL event flag deallocation
	com$delattnast: delattnast NOVALUE,	! VMS attn AST delivery routine
	com$delctrlast: delctrlast NOVALUE,	! VMS ctrl AST delivery routine
	com$flushattns: flushattns NOVALUE,	! VMS attn AST flush routine
	com$flushctrls: flushctrls NOVALUE,	! VMS ctrl AST flush routine
	exe$sndevmsg: sndevmsg,			! VMS unsolicited mailbox msg
	exe$alononpaged: alononpaged,		! VMS Non-paged pool allocate
	exe$deanonpaged: deanonpaged NOVALUE, 	! VMS deallocation
!
	vs$$post_ast_request,		!Queue operation for non-AST level
	vs$$post_ast_request_hipq,	!Queue operation for non-AST level
	vs$$vds_queue_int,		!Queue operation for non-AST level
	vsta$$popup_main_menu,		!Display main HI menu to user
	vsta$$help_button_pressed,	!Display HI help to user
	vsta$$hi_new_symbols,		!Show new symbol key mapping
	vsta$$hi_null_symbols_input,	!Symbol "nothing"
	vsta$$hi_bad_seed,		!Unknown symbol key
	vsta$$read_kernel_long,		!Read longword from system space
	vsta$$read_kernel_word,		!Read word from system space
	vsta$$symb_display_level_1,	!Show Level-1 keyboard attributes
	vsta$$symb_remove_level_1,	!UNshow Level-1 keyboard attributes
	vsta$$kernel_call,		!Call specified routine in kernel mode
	vs$$vds_vd_set_xon_xoff,	!Start/Stop output routine (control s,q)
	vs$$acp_delattnast,		!Delivery control-c,y ASTs to process
	vs$$acp_delctrlast,		!Delivery out-of-band ASTs to process
	vs$$acp_flush_reads,		!Flush blocked reads on a VKB
	vs$$acp_find_pcb,		!Return PCB address from PID
	vs$$acp_find_port_input,	!Find port driver input handler
	vs$$acp_set_input_char,		!Set terminal input characteristics
	vs$$acp_done_io: NOVALUE,	!ACP I/O completion routine
	vsta$$odrv_send_lf,		!Output driver send free <LF> indicator
	vsta$$odrv_skip_lf,		!Output driver skip <LF> indicator
	vsta$$odrv_control_o,		!Toggle output to device
	vsta$$odrv_mbx_enable,		!Device unsolicited data mbx enable bit
	vsta$$odrv_delete_last_char,	!Delete last char. from screen
	vsta$$odrv_current_column,	!Get current cursor position
	vs$$vds_synchronize_echo,	!vds synchronize echo to vd routine
	vs$$vds_pb_found,		!Find pasteboard data base by ID
	vsta$$error,			!ACP error return handler
	vsta$$error_logger,		!ACP error logger
	vsta$$acp_check_read_access,	!To check read access to VKB
	vsta$$acp_check_pb_read_access,	!To check read access to VKB
	vsta$$acp_check_write_access,	!To check write access to VKB
	vsta$$kbrd_sound_bell,		!Ring the keyboard bell
	vsta$$drive_noop,		!Perform device noop to flush output
	vsta$$srv_end_session,		!Cause end-session for unrecoverable errors
	vs$$acp_get_vm,			!RTL memory allocation routine
	vs$$acp_free_vm;		!RTL memory deallocation routine
!
! Define the 2 Dimensional array for the translation vector table
!	vecs [Translation_table_number , vector number]
!
! Zero based
!
structure
	ARRAY [I,J ; M,N] =
		[4*M*N]
		(ARRAY + 4*(I*N + J));
!
! EXTERNAL DATA
!
EXTERNAL
	vs$gl_oem_flags,			!OEM-mode flags for ACP
	vs$gl_template_ucb,			!Template UCB address
	vs$al_vd_ucb: VECTOR,			!Pointers to all VD UCB's
	vs$a_irp: REF irp_block,		!Pointer to current IRP
	vs$gl_pid,				!PID on current IRP
	vs$gw_vd_chan: WORD,			!Channel to template VD
	vtem$al_vkb_trans_vecs: array [0,17],   ! Vectors to translation tables
	vtem$al_vkb_trans_size: VECTOR,		! Vectors to trans. table sizes
	VTEM$AL_VKB_SYMBOL_VECS:vector [0,long],! Vectors to symbol tables
	VTEM$AL_VKB_SYMBOL_SIZE:vector,		! Vectors to symbol table sizes
	SYS$GL_JOBCTLMB,		!Job controller mailbox address
	TTY$GW_TYPAHDSZ: WORD,		!SYSGEN terminal typeahead buffer size
	SCH$GL_CURPCB,			!Current PCB pointer
	vsta$gl_keyboard;
!
! BLISS-32 BUILT-IN MACHINE INSTRUCTIONS
!
BUILTIN
	EMUL,				! Extended multiply instruction
	TESTBITSS,			! Test for bit set and set
	TESTBITSC,			! Test for bit set and clear
	INSQUE,				! Insert into queue
	REMQUE;				! Remove from queue
!
! EQUATED SYMBOLS:
!
!
! PSECTS
!
$VSTA_PSECT;
!
!
! OWN STORAGE:
!
LITERAL
	true = 1,
	false = 0;

COMPILETIME
	case_value = 0;

GLOBAL
	vs$vkb_list: VECTOR[2] INITIAL (REP 2 OF (vs$vkb_list[0]));
					!Virtual Keyboard List
OWN
	translation_table: INITIAL(-1),	!Current translation table
	nrc_table: INITIAL(-1),		!Current NRC table
	default_active_vkb: INITIAL(0),	!Default active virtual keyboard
	first_activate: INITIAL(true),	!First activation does some init.
	last_vkb_level: INITIAL(0),	!Previous active VKB level 1/2 state
	wake_ef,			!IO$M_WAKEKB event flag
	load_ef,			!IO$M_LOADKB event flag
	broadcast_on: INITIAL(false),	!For debugging
	reconnect_count: INITIAL(0),	!Count up KB reconnection attempts
	break_table: VECTOR[8]
	 INITIAL (%X'FFFFE0FF',0,0,%X'80000000',%X'FFFFE0FF',0,0,%X'80000000'),
	iosb: VECTOR[4,WORD],		!I/O status block for VB I/O
	vkb$wv_current_symbol_table: VECTOR [VS$K_ALL_SYMBOL_SIZE,WORD];
					    
!
!

%SBTTL 'vs$$create_vkb -- Create a Virtual Keyboard'
GLOBAL ROUTINE vs$$create_vkb(
				pb_id,		!Pasteboard ID of vkb
				pkb_chan	!Physical Keyboard channel no.
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for any setup operations necessary to
! create a virtual keyboard device.
!
! FORMAL PARAMETERS:
!
!	PB_ID       : Longword pasteboard ID of virtual keyboard
!			(input parameter)
!	PKB_CHAN    : Longword physical keyboard channel number
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	vs$vkb_list : Queue head pointer to known virtual keyboards
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! Returns "SS$_NORMAL" if successful, or error status returned by LIB$GET_VM
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	arg_list: VECTOR[3],			!$CMKRNL parameter block
	vkb_adr: REF vkb_block,			!Virtual Keyboard Block address
	rr_adr: REF vkb_read_request,		!Virtual Keyboard RR Block adr.
	status;					!To contain return status value

!
! If we already have a VKB with this ID then return an error indication
!
	IF vs$$vkb_found(.pb_id,vkb_adr) THEN
	  $return_error(vsta$_vkbalralloc);
!
! Allocate memory for the virtual keyboard data block
!
	IF (NOT (status = vs$$acp_get_vm (UPLIT (vs$vkb_k_block_size),
					vkb_adr))) THEN
	  $return_error(vsta$_vkbnotcre);
!
! Allocate memory for the virtual keyboard's typeahead buffer
!
	vkb_adr[vs$vkb_a_ring_buffer] = 0;
	vkb_adr[vs$vkb_a_break_table] = 0;
	vkb_adr[vs$vkb_a_current_read] = 0;
!
	arg_list[0] = 2;
	arg_list[1] = vkb_adr[vs$vkb_a_ring_buffer];
	arg_list[2] = vkb_adr[vs$vkb_l_buffer_size];
!
	IF (NOT (status = $CMKRNL(
				ROUTIN = vs$$get_ring_buffer,
				ARGLST = arg_list))) THEN
	  BEGIN
	    vs$$free_vkb(.vkb_adr);
	    $return_error(vsta$_vkbnotcre);
	  END;
!
! Allocate memory for and initialize the VKB break table (for unsolicited
! data).
!
	IF (NOT (status = vs$$acp_get_vm (UPLIT (vs$k_break_table_size),
					vkb_adr[vs$vkb_a_break_table]))) THEN
	  BEGIN
	    vs$$free_vkb(.vkb_adr);
	    $return_error(vsta$_vkbnotcre);
	  END;
	CH$MOVE(
		vs$k_break_table_size,
		break_table,
		.vkb_adr[vs$vkb_a_break_table]);
!
! Allocate memory for the virtual keyboard's current read request block
!
	IF (NOT (status = vs$$acp_get_vm (UPLIT (vs$rr_k_block_size),
					rr_adr))) THEN
	  BEGIN
	    vs$$free_vkb(.vkb_adr);
	    $return_error(vsta$_vkbnotcre);
	  END;
	vkb_adr[vs$vkb_a_current_read] = .rr_adr;
!
! Allocate memory for the local copy of the virtual keyboard's current
! read break table
!
	rr_adr[vs$rr_a_break_table] = 0;
	IF (NOT (status = vs$$acp_get_vm (UPLIT (vs$k_break_table_size),
					rr_adr[vs$rr_a_break_table]))) THEN
	  BEGIN
	    vs$$free_vkb(.vkb_adr);
	    $return_error(vsta$_vkbnotcre);
	  END;
!
! Initialize the rest of the virtual keyboard block
!
	vkb_adr[vs$vkb_w_size] = vs$vkb_k_block_size;
	vkb_adr[vs$vkb_w_type] = 0;
	vkb_adr[vs$vkb_l_id] = .pb_id;
	vkb_adr[vs$vkb_l_owner] = .vs$gl_pid;	!PID of VKB owner
	vkb_adr[vs$vkb_w_pkb_chan] = .pkb_chan;
	vkb_adr[vs$vkb_l_trans_table] = .vsta$gl_keyboard;
	vkb_adr[vs$vkb_l_nrc_table] = vsta$k_nrc_multinational;
	vkb_adr[vs$vkb_a_echo_routine] = 0;
	vkb_adr[vs$vkb_a_gchar_routine] = 0;
	vkb_adr[vs$vkb_l_gen_index] = -1;
	vkb_adr[vs$vkb_a_control_y_ast] = 0;
	vkb_adr[vs$vkb_a_control_c_ast] = 0;
	vkb_adr[vs$vkb_a_out_of_band_ast] = 0;
	vkb_adr[vs$vkb_l_out_of_band_mask] = 0;
	vkb_adr[vs$vkb_l_unsolicit_ptr] = 0;
	vkb_adr[vs$vkb_b_dead] = 0;
	vkb_adr[vs$vkb_l_escape_state] = vkb$k_not_doing_escape;
	vkb_adr[vs$vkb_l_state] = vsta$m_eightbit OR vsta$k_vkb_level_2;
	vkb_adr[vs$vkb_l_char] =
		TT$M_EIGHTBIT OR TT$M_LOWER OR TT$M_HOSTSYNC OR
		TT$M_MBXDSABL OR TT$M_NOBRDCST OR
		TT$M_NOECHO   OR TT$M_PASSALL;
	vkb_adr[vs$vkb_l_vd_id] = 0;
	vkb_adr[vs$vkb_a_vd] = 0;
	vkb_adr[vs$vkb_l_lower_symbol_map_boff] = 0;
	vkb_adr[vs$vkb_l_caps_symbol_map_boff] = 0;
	vkb_adr[vs$vkb_l_shift_symbol_map_boff] = 0;
!
! Insert this virtual keyboard block into the queue of known virtual keyboards
!
	INSQUE(.vkb_adr,vs$vkb_list[0]);
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$create_vkb


%SBTTL 'vs$$set_vkb_output -- Set up a Virtual Keyboard for Output Stream'
GLOBAL ROUTINE vs$$set_vkb_output(
			vkb_id,			!ID of vkb
			vd_id,			!ID of VD for output
			vd_adr,			!Address of VD for fast output
			echo_routine,		!Echo routine address
			gchar_routine,		!Emulator trans. routine addr.
			trans_table		!Translation table
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for any setup operations necessary to
! initialize a virtual keyboard device for output operations: echo, read
! with prompt, specific emulator modes, etc. and character code translation.
!
! FORMAL PARAMETERS:
!
!	VKB_ID          : Longword ID of virtual keyboard
!				(input parameter)
!	VD_ID           : Longword ID of virtual display for output
!				(input parameter)
!	VD_ADR          : Address of virtual display for faster output
!				(input parameter)
!	ECHO_ROUTINE	: Address of appropriate emulator's echo routine
!				(input parameter)
!	GCHAR_ROUTINE	: Address of appropriate emulator's translate routine
!				(input parameter)
!	TRANS_TABLE	: Longword Translation table constant
!				(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! Returns "SS$_NORMAL" if successful, or error status returned by vs$$acp_GET_VM
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	vkb_adr: REF vkb_block;		!Virtual Keyboard Block address

!
! First make sure that this virtual keyboard exists
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! Initialize the rest of the virtual keyboard block associated with the output
! stream. NOTE that the Up/Down translation table addresses are remembered by
! number and not actually copied here. They will presumably already be stored
! somewhere in memory. Also note that it is assumed that all parameters are
! correct as this is for internal use only.
!
	IF .vd_id NEQ 0 THEN
	  BEGIN
	    IF vs$$vkb_init_port(.vkb_adr,.vd_id) THEN
	      IF .vkb_adr[vs$vkb_v_current] THEN
		BEGIN
		  vkb_adr[vs$vkb_v_current] = false;
		  vs$$activate_vkb(.vkb_adr[vs$vkb_l_id]);
		END;
	    vkb_adr[vs$vkb_l_vd_id] = .vd_id;
	  END;
	IF .vd_adr NEQ 0 THEN
	  vkb_adr[vs$vkb_a_vd] = .vd_adr;
	IF .echo_routine NEQ 0 THEN
	  vkb_adr[vs$vkb_a_echo_routine] = .echo_routine;
	IF .gchar_routine NEQ 0 THEN
	  vkb_adr[vs$vkb_a_gchar_routine] = .gchar_routine;
	IF .trans_table LEQ vsta$k_tt_max THEN
	  vs$$vkb_loadtt(.vkb_adr,.trans_table);
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$set_vkb_output


%SBTTL 'vs$$vkb_init_port -- Set up a Virtual Keyboard/Output Port Link'
ROUTINE vs$$vkb_init_port(
			vkb_adr: REF vkb_block,		!VKB address
			vd_id				!VD ID
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for establishing the virtual keyboard
! to port driver link, and its not as impressive as it sounds. This routine
! is called as a result of this virtual keyboard being the input device of
! a particular terminal emulator. The previously allocated ring buffer will
! be replaced by a location in the terminal UCB of the specified device.
! When "activated", input will be placed directly into the UCB and VDDRIVER
! will be notified by VBDRIVER.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR : Address of virtual keyboard data base
!				(input parameter)
!	VD_ID   : Longword virtual display ID
!				(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! Returns "SS$_NORMAL" if successful, or error status returned by vs$$acp_GET_VM
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	ucb_adr: REF vd_ucb_block;	!UCB address for VD

!
! First make sure that there is a UCB
!
	ucb_adr = .vs$al_vd_ucb[.vd_id];
	IF .ucb_adr GEQ 0 THEN
	  RETURN SS$_NOSUCHDEV;
!
! If there is a ring buffer allocated, free up the non-paged pool
!
	IF .vkb_adr[vs$vkb_a_ring_buffer] NEQ 0 THEN
	  vsta$$kernel_call(
		vs$$release_ring_buffer,
		.vkb_adr);
!
! Now store the ring buffer (typeahead buffer) address in the VKB for
! future use.
!
	vkb_adr[vs$vkb_a_ring_buffer] = ucb_adr[ucb$b_vd_typahd];
	vkb_adr[vs$vkb_l_buffer_size] = ucb$k_vd_max_typahd;
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$vkb_init_port


%SBTTL 'vs$$set_default_vkb -- Set up Default Active Virtual Keyboard'
GLOBAL ROUTINE vs$$set_default_vkb(
				vkb_id			!ID of vkb
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for any setup operations necessary to
! initialize a virtual keyboard as the default, active virtual keyboard. When
! a virtual keyboard is explicitly deactivated, all characters will be moved
! into the typeahead buffer of this virtual keyboard as it will become active.
! Reads must be performed occasionally to empty this buffer. This routine
! permits the human interface to trap characters that otherwise would be thrown
! away, inform the user in some way of that fact while still able to respond to
! such human interface "owned" keys like HELP and MENU.
!
! FORMAL PARAMETERS:
!
!	VKB_ID          : Longword ID of virtual keyboard
!				(input parameter)
!
! IMPLICIT INPUTS:
!
!	DEFAULT_ACTIVE_VKB : Address of longword default active VKB ID
!
! IMPLICIT OUTPUTS:
!
!	DEFAULT_ACTIVE_VKB : Address of longword default active VKB ID
!
! ROUTINE VALUE
!
! Returns "SS$_NORMAL" 
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	vkb_adr: REF vkb_block;		!Virtual Keyboard Block address

!
! First make sure that this virtual keyboard exists
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! It exists. So initialize the default active virtual keyboard
!
	default_active_vkb = .vkb_id;
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$set_default_vkb

%SBTTL 'vs$$clear_default_vkb -- Undo vs$$set_Default_vkb'
GLOBAL ROUTINE vs$$clear_default_vkb =
!++
!--
BEGIN

default_active_vkb = 0;		!Zero the variable

RETURN SS$_NORMAL;
END;				! of routine vs$$clear_default_vkb

%SBTTL 'vs$$set_vkb_char -- Set Virtual Keyboard Characteristics'
GLOBAL ROUTINE vs$$set_vkb_char(
			vkb_id,			!ID of vkb
			mod_states,		!States of VKB to modify
			new_state_bits,		!New state bits of VKB
			requestor_pid		!Who's trying to do it
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for setting certain VKB characteristics
! for the caller which were deemed settable external to this module. Such
! states include Keypad application mode, cursor key mode, etc.
!
! FORMAL PARAMETERS:
!
!	VKB_ID          : Longword ID of virtual keyboard
!				(input parameter)
!	MOD_STATES	: Longword VKB states to be modified
!				(input parameter)
!	NEW_STATE_BITS	: Longword new VKB states
!				(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! Returns "SS$_NORMAL" if successful, or SS$_NOSUCHDEV if not found
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	on_bits,				!Temp. for bits to turn on
	old_level,				!Remember previous VKB level
	new_level,				!For new VKB level
	pb_adr: REF pb_block,			!Corresponding PB block address
	vkb_adr: REF vkb_block;			!Virtual Keyboard Block address

!
! First make sure that this virtual keyboard exists
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! If a corresponding pasteboard exists, check the caller's WRITE access to it
!
	IF vs$$vds_pb_found(.vkb_id,pb_adr) THEN
	  IF NOT vsta$$acp_check_write_access(
					$requestor,
					.pb_adr[vs$vds_l_pb_uic],
					.pb_adr[vs$vds_w_pb_prot]) THEN
	    $return_error(vsta$_noaccess,
			string_type, %ASCID 'WRITE',
			string_type, %ASCID 'Virtual Keyboard',
			integer_type, .vkb_id);
!
! Allow modification of only certain VKB state bits.
!
	mod_states = .mod_states AND
			(NOT (vs$vkb_m_read OR vs$vkb_m_read_active OR 
			vs$vkb_m_write OR vs$vkb_m_current OR
			vs$vkb_m_timeout OR vs$vkb_m_read_asts));
!
! Turn the correct bits on and off as specified
!
	on_bits = .mod_states AND .new_state_bits;
	old_level = .vkb_adr[vs$vkb_v_level];
	vkb_adr[vs$vkb_l_state] =
			(.vkb_adr[vs$vkb_l_state] OR
			.on_bits) AND
			(NOT (.on_bits XOR .mod_states));
!
! If this is an emulated terminal, update the UCB as well
!
	IF .vkb_adr[vs$vkb_l_vd_id] EQL 0 THEN
	  new_level = .vkb_adr[vs$vkb_v_level]
	ELSE
	  vsta$$kernel_call(
			vs$$acp_set_input_char,
			.vkb_adr[vs$vkb_l_vd_id],
			.mod_states,
			.on_bits,
			new_level);
!
! If the level of the keyboard has changed and the VKB is "active", then
! inform human interface to remap key representations on screen
!
	IF (.old_level NEQ .new_level) AND
	   (.vkb_adr[vs$vkb_v_current]) THEN
	  IF .new_level EQL vkb$k_level_1 THEN
	    BEGIN
	      vsta$$symb_display_level_1();
	      vkb_adr[vs$vkb_l_lower_symbol_map_boff] = 0;
	      vkb_adr[vs$vkb_l_caps_symbol_map_boff] = 0;
	      vkb_adr[vs$vkb_l_shift_symbol_map_boff] = 0;
	    END
	  ELSE
	    vsta$$symb_remove_level_1();
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$set_vkb_char


%SBTTL 'vs$$set_vkb_trans_table -- Set VKB Translation Table'
GLOBAL ROUTINE vs$$set_vkb_trans_table(
			vkb_id,			!ID of vkb
			trans_table,		!Translation table
			requestor_pid		!Who's trying to do it
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for setting the current translation
! being used by a VKB.
!
! FORMAL PARAMETERS:
!
!	VKB_ID          : Longword ID of virtual keyboard
!				(input parameter)
!	TRANS_TABLE	: Longword Translation table constant
!				(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! Returns "SS$_NORMAL" if successful, or SS$_NOSUCHDEV if not found
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	pb_adr: REF pb_block,			!Corresponding PB block address
	vkb_adr: REF vkb_block;			!Virtual Keyboard Block address

!
! First make sure that this virtual keyboard exists
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! If this is not a valid translation table number, just return indication
!
	IF (.trans_table GTR vsta$k_tt_max) AND
	   (.trans_table NEQ vsta$k_tt_unencoded) THEN
	  $return_error(vsta$_nosuchvtt);
!
! If a corresponding pasteboard exists, check the caller's WRITE access to it
!
	IF vs$$vds_pb_found(.vkb_id,pb_adr) THEN
	  IF NOT vsta$$acp_check_write_access(
					$requestor,
					.pb_adr[vs$vds_l_pb_uic],
					.pb_adr[vs$vds_w_pb_prot]) THEN
	    $return_error(vsta$_noaccess,
			string_type, %ASCID 'WRITE',
			string_type, %ASCID 'Virtual Keyboard',
			integer_type, .vkb_id);
!
! Assume that the caller knows what translation table to use and just set it.
!
	vs$$vkb_loadtt(.vkb_adr,.trans_table);
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$set_vkb_trans_table


%SBTTL 'vs$$vkb_set_nrc -- Set NRC for current VKB'
GLOBAL ROUTINE vs$$vkb_set_nrc (
					vkb_id,
					nrc
				) =
!++
!  Functional Description
!
!  This routine set the current NRC for the specified nrc.  It will
!  call the VS$$VKB_LOAD_NRC if this VKB is active.
!
!  Parameter Description
!
!  vkb_id		Virtual Keyboard Identification
!  nrc			VSTA$K_NRC_xxx identifying an NRC or DEC multinational
!
!--
BEGIN

LOCAL
	vkb_adr: REF vkb_block;

!
! First make sure that this virtual keyboard exists
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! Change the nrc for this VKB (if its a terminal)
!
	IF .vkb_adr[vs$vkb_l_vd_id] EQL 0 THEN
	  RETURN SS$_NORMAL;
!
	vkb_adr [vs$vkb_l_nrc_table] = .nrc;
!
! Call routine to load active tables if this VKB is active
!
	IF .vkb_adr[vs$vkb_v_current] THEN
	  VS$$VKB_LOAD_NRC( .vkb_adr);
!
return SS$_NORMAL;
end;



%SBTTL 'vs$$vkb_load_nrc -- Load current tables with NRC for this VKB'
GLOBAL ROUTINE vs$$vkb_load_nrc (
					 vkb: REF vkb_block
				) =
!++
!  Functional Description
!
!  This routine generates a translation table to translate from
!  DEC multinational to the NRC requested.  This table
!  and the matching symbol-key table are passed to the port driver.
!  When a VKB is made active then this routine should be called
!  to load new tables into the Port driver.
!
!  Parameter Description
!
!  VKB		Virtual Keyboard Address
!
!--
BEGIN
!
!  Define nation replacement sets
!
LITERAL  vkb$k_nrc_bcnt = 12;

BIND
	  vkb$bv_ascii_nrc = PLIT BYTE (
		  35,  64,  91,  92,  93,  94,  95,  96, 123, 124, 125, 126
				)	: VECTOR [,BYTE]
	 ,vkb$bv_uk_nrc = PLIT BYTE (
		 163,  64,  91,  92,  93,  94,  95,  96, 123, 124, 125, 126
				)	: VECTOR [,BYTE]
	 ,vkb$bv_french_nrc = PLIT BYTE (
		 163, 224, 176, 231, 167,  94,  95,  96, 233, 249, 232, 34
				)	: VECTOR [,BYTE]
	 ,vkb$bv_frcan_nrc = PLIT BYTE (
		  35, 224, 226, 231, 234, 238,  95, 244, 233, 249, 232, 251
				)	: VECTOR [,BYTE]
	 ,vkb$bv_nordan_nrc = PLIT BYTE (
		  35, 196, 198, 216, 197, 220,  95, 228, 230, 248, 229, 252
				)	: VECTOR [,BYTE]
	 ,vkb$bv_finnish_nrc = PLIT BYTE (
		  35,  64, 196, 214, 197, 220,  95, 233, 228, 246, 229, 252
				)	: VECTOR [,BYTE]
	 ,vkb$bv_german_nrc = PLIT BYTE (
		  35, 167, 196, 214, 220,  94,  95,  96, 228, 246, 252, 223
				)	: VECTOR [,BYTE]
	 ,vkb$bv_dutch_nrc = PLIT BYTE (
		 163, 179, 253, 189, 124,  94,  95,  96,  34, 102, 188,  39
				)	: VECTOR [,BYTE]
	 ,vkb$bv_italian_nrc = PLIT BYTE (
		 163, 167, 176, 231, 233,  94,  95, 249, 224, 242, 232, 236
				)	: VECTOR [,BYTE]
	 ,vkb$bv_swiss_nrc = PLIT BYTE (
		 249, 224, 233, 231, 234, 238, 232, 244, 228, 246, 252, 251
				)	: VECTOR [,BYTE]
	 ,vkb$bv_swedish_nrc = PLIT BYTE (
		  35, 201, 196, 214, 197, 220,  95, 233, 228, 246, 229, 252
				)	: VECTOR [,BYTE]
	 ,vkb$bv_spanish_nrc = PLIT BYTE (
		 163, 167, 161, 209, 191,  94,  95,  96, 176, 241, 231, 126
				)	: VECTOR [,BYTE]
	;

BIND
	 vkb$av_nrc_tables = PLIT (
		  vkb$bv_ascii_nrc 
		 ,vkb$bv_uk_nrc 
		 ,vkb$bv_french_nrc 
		 ,vkb$bv_frcan_nrc 
		 ,vkb$bv_nordan_nrc 
		 ,vkb$bv_finnish_nrc 
		 ,vkb$bv_german_nrc 
		 ,vkb$bv_dutch_nrc 
		 ,vkb$bv_italian_nrc 
		 ,vkb$bv_swiss_nrc 
		 ,vkb$bv_swedish_nrc 
		 ,vkb$bv_spanish_nrc )
				: VECTOR [,LONG]
	;

OWN
	 vkb$bv_ascii_table : VECTOR [256,BYTE] INITIAL (BYTE (
		 0,1,2,3,4,5,6,7,8,9
		,10,11,12,13,14,15,16,17,18,19
		,20,21,22,23,24,25,26,27,28,29
		,30,31,32,33,34,35,36,37,38,39
		,40,41,42,43,44,45,46,47,48,49
		,50,51,52,53,54,55,56,57,58,59
		,60,61,62,63,64,65,66,67,68,69
		,70,71,72,73,74,75,76,77,78,79
		,80,81,82,83,84,85,86,87,88,89
		,90,91,92,93,94,95,96,97,98,99
		,100,101,102,103,104,105,106,107,108,109
		,110,111,112,113,114,115,116,117,118,119
		,120,121,122,123,124,125,126,127,128,129
		,130,131,132,133,134,135,136,137,138,139
		,140,141,142,143,144,145,146,147,148,149
		,150,151,152,153,154,155,156,157,158,159
		,160,161,162,163,164,165,166,167,168,169
		,170,171,172,173,174,175,176,177,178,179
		,180,181,182,183,184,185,186,187,188,189
		,190,191,192,193,194,195,196,197,198,199
		,200,201,202,203,204,205,206,207,208,209
		,210,211,212,213,214,215,216,217,218,219
		,220,221,222,223,224,225,226,227,228,229
		,230,231,232,233,234,235,236,237,238,239
		,240,241,242,243,244,245,246,247,248,249
		,250,251,252,253,254,255))
	;

LOCAL
	nrc_characters	: REF VECTOR [,BYTE];

!
! If the "new" NRC is the same as the currently loaded one, then we're done
! before we knew what happened
!
	IF .vkb [vs$vkb_l_nrc_table] EQL .nrc_table THEN
	  RETURN SS$_NORMAL;
	nrc_table = .vkb [vs$vkb_l_nrc_table];
!
!  Is DEC multi-national being requested
!
	IF .vkb [vs$vkb_l_nrc_table] EQL vsta$k_nrc_multinational THEN
	  BEGIN
!
! Call driver to make tables active in Port driver
! No NRC specified and multinational symbol table
!
		  $QIO(
			EFN  = .load_ef,	!Used in VSVKB for synch. I/O
			CHAN = .vs$gw_vd_chan,	!Global ACP channel to template VDx0:
			FUNC = IO$_VSTAHI or IO$M_VD_NRC_TABLE,
			P1   = 0);		!NRC table address

!
! Call routine to load multinational symbol table
!
		  VS$$VKB_LOAD_SYMBOL_TABLE(.vkb, 0);

	  END			! End of loading multinational table
	ELSE 
	  BEGIN			! If are to load an NRC
	
!
! Get pointer to NRC descriptor
!
		nrc_characters = .vkb$av_nrc_tables [.vkb [vs$vkb_l_nrc_table]];

!
! Stage the NRC table in the module scratch table.
! Loop through the characters of the NRC and point them
! at their ASCII counter parts
!
		INCR i FROM 0 TO (vkb$k_nrc_bcnt - 1)
		DO BEGIN		! Change scratch table for this NRC

!
!  Set the 8th bit in the replaced character to indicate that it is not in
!  the nrc.  This will will get over-ridden if it turns out that this char
!  is in the nrc.
!
			vkb$bv_ascii_table [ .vkb$bv_ascii_nrc [ .i]] =
			   .vkb$bv_ascii_nrc [ .i] OR %X'80';

!
!  Replace the multinational character location with
!  a ascii index
!
			vkb$bv_ascii_table [ .nrc_characters[ .i]] =
				.vkb$bv_ascii_nrc [ .i];
	
		   END;			! End of changing scratch table

!
! Call driver to make tables active in Port driver
! Use VKB$BV_TRANS_TABLE and the matching symbol table
!
		  $QIO(
			EFN  = .load_ef,	!Used in VSVKB for synch. I/O
			CHAN = .vs$gw_vd_chan,	!Global ACP channel to template VDx0:
			FUNC = IO$_VSTAHI or IO$M_VD_NRC_TABLE,
			P1   = vkb$bv_ascii_table);	!NRC table address

!
! Before we return the scratch table to normal we first call the routine
! to load the symbol table which matches this NRC
!
		  VS$$VKB_LOAD_SYMBOL_TABLE(.vkb, vkb$bv_ascii_table);

!
! Return the NRC scratch table to its origional state
!
		INCR i FROM 0 TO (vkb$k_nrc_bcnt - 1)
		DO BEGIN		! Return tables to normal

!
!  Replace the multinational character location with
!  its own index
!
			vkb$bv_ascii_table [ .nrc_characters[ .i]] =
				.nrc_characters [ .i];

			vkb$bv_ascii_table [ .vkb$bv_ascii_nrc [ .i]] =
			  .vkb$bv_ascii_nrc [ .i];
	
		   END;			! End of returning table to normal

	  END;				! End of if not DEC multinational
	
	RETURN ss$_normal;
	END;


%sbttl 'VS$$VKB_LOAD_SYMBOL_TABLE'
GLOBAL ROUTINE vs$$vkb_load_symbol_table(
					vkb_adr: REF vkb_block,		!VKB address
					nrc_tab: ref vector [,byte]
					) = 
!++
! Functional Description
!
! This routine generates and loads the symbol conversion table after
! symbols not in the NRC have been excluded.
!
! Formal Parameters
!
!	NRC_TAB	The 8bit to 7bit (dec multinational to NRC) for
!		this NRC.  Or zero for dec multinational keyboards.
!--
begin

external
	vtem$aw_vkb_symbol_table_1: vector [,word],
	vtem$gl_vkb_symbol_table_size;

local
	temp_buffer: VECTOR [20,WORD,SIGNED],
	tbi,				! Temp_buffer index
	ctr: REF VECTOR [,WORD,SIGNED],	! Scratch table row
	ctri,				! Scratch table row index
	mtr: REF VECTOR [,WORD,SIGNED],	! Master table row
	mtri,				! Master table row index
	key,				! Key whos symbols we are looking at
	hack,				! Self explanitory
	tt_list: VECTOR [vs$k_max_mode_tables];

vtem$al_vkb_symbol_vecs[.vkb_adr[vs$vkb_l_trans_table]] = 
			vkb$wv_current_symbol_table [0];

IF .nrc_tab EQL 0
THEN BEGIN			! Load multinational symbols

	vtem$al_vkb_symbol_vecs[.vkb_adr[vs$vkb_l_trans_table]] = 
			vtem$aw_vkb_symbol_table_1 [0];

	vtem$al_vkb_symbol_size[.vkb_adr[vs$vkb_l_trans_table]] =
			.vtem$gl_vkb_symbol_table_size;

	!
	! Set up null symbol table sub list
	!
	INCR index FROM 0 TO (vs$k_max_mode_tables - 1)
	DO tt_list[.index] = 0;

	$QIO(
		EFN  = .load_ef,
		CHAN = .vs$gw_vd_chan,
		FUNC = IO$_VSTAHI or IO$M_VD_SYMBOL_TABLE,
		P1   = vtem$aw_vkb_symbol_table_1 [0],
		P2   = .vtem$gl_vkb_symbol_table_size,
		P3   = tt_list);

	RETURN ss$_normal;

     END;			! End of loading symbols for multinational
!
!  Set up master table row and scratch table row pointers
!
mtr = vtem$aw_vkb_symbol_table_1 [0];
ctr = vkb$wv_current_symbol_table [0];

!
!  Put 6 null entries at start of symbol table
!
INCR i FROM 0 to 5
DO ctr [.i] = 0;

!
!  Point at the second row of current table
!
ctr = .ctr + 12;

!
!  Loop until sentinal of -1 found in column 1 of master table row
!
WHILE (key = .mtr [0]) neq -1	! Key is stored in the master table row [0]
DO BEGIN			! Start  loop on rows

	tbi = 0;		! Init temporary index
	!
	!  Loop too look at all rows with this key.  Assumes that rows
	!  with same key are together.
	!
	hack = 0;		! Used to handle special comma and period case

	WHILE (.mtr [0] EQL .key) AND (NOT .hack)
	DO BEGIN		! Loop on key

		IF (.mtr [0] EQL %c'.') OR (.mtr [0] EQL %c',')
		THEN hack = 1
		ELSE hack = 0;

		!
		! Loop thru this row of the master table
		!
		INCR mtri FROM 1 to 5
		DO BEGIN	! Loop thru row
			!
			! If a null entry is found then ignore it
			!
			IF (.mtr [.mtri] GTR 0)
			THEN BEGIN	! Symbol entry not null

				!
				! Is symbol in NRC; if so then put symbol in
				! temporary buffer.  Symbol is in NRC if the
				! translation table entry converts the symbol
				! to a 7bit ascii character.
				!
				IF (.nrc_tab [.mtr [.mtri]] AND %X'80') EQL 0
				THEN BEGIN
					temp_buffer [.tbi] = .mtr [.mtri];
					tbi = .tbi + 1;
				     END
				ELSE BEGIN	! Is other case in

				!
				! Check to see if the other case of the symbol
				! is in the NRC if so then add this case as
				! Well
				!
				IF (.mtr [.mtri] GEQ 192) AND
				   (.mtr [.mtri] LEQ 221) 
				THEN IF (.nrc_tab [.mtr [.mtri] OR %X'20'] AND
				        %X'80') EQL 0
				     THEN BEGIN
					     temp_buffer [.tbi] = .mtr [.mtri];
					     tbi = .tbi + 1;
				          END;

				     END;	! End is other case in
	
			     END;	! End of symbol not null

		    END;	! Loop thru row

		mtr = .mtr + 12;! Update row pointer into master table

	   END;			! End loop on key


	!
	! Now we must transfer temporary buffer to the scratch symbol tab
	!
	ctr [0] = .key;		! Store key in first entry

	!
	!  If the number of symbols is greater than 5 then use continuation
	!  marker at end of choices
	!
	IF .tbi GTR 5
	THEN BEGIN		! # of symbols > 5

		!
		! Loop thru all characters in temporary buffer
		!
		ctri = 1;
		INCR i FROM 0 TO .tbi - 1
		DO BEGIN	! Loop on characters

			!
			! Continuation character needed?
			!
			IF .ctri EQL 5
			THEN BEGIN	! Continuation needed

				ctr [5] = -1;
				ctr = .ctr + 12;
				ctr [0] = .key;
				ctri = 1;

			     END;	! End Continuation needed

			ctr [.ctri] = .temp_buffer [.i];
			ctri = .ctri + 1;

		   END;		! End loop on characters
		!
		! Fill rest of scratch table row with nulls
		!
		INCR i FROM .ctri+1 TO 4
		DO ctr [.i] = 0;

		!
		! Put continuation character at end of row
		ctr [5] = -1;

		ctr = .ctr + 12; ! Get pointer to next scratch table row

	     END		! End # of symbols > 5
	ELSE IF .tbi GTR 0 
	THEN BEGIN		! # of symbols 0< .tbi <= 5 
		

		!
		! Transfer temporary buffer to scratch table
		!
		INCR i FROM 1 TO .tbi
		DO ctr [.i] = .temp_buffer [.i - 1];

		!
		! Fill rest of scratch table row with nulls
		!
		INCR i FROM (.tbi + 1) TO 5
		DO ctr [.i] = 0;

		ctr = .ctr + 12; ! Get pointer to next scratch table row

	     END;		! END # of symbols 0 < .tbi <= 5		
	
   END;				! END loop on rows

!
!  Put centinal at end of table
!
ctr [0] = -1;

!
! Set up null symbol table sub list
!
INCR index FROM 0 TO (vs$k_max_mode_tables - 1)
DO tt_list[.index] = 0;

!
! Store the size of the newly constructed symbol table
!
vtem$al_vkb_symbol_size[.vkb_adr[vs$vkb_l_trans_table]] =
	ctr [1] - vkb$wv_current_symbol_table [0];

$QIO(
	EFN  = .load_ef,
	CHAN = .vs$gw_vd_chan,
	FUNC = IO$_VSTAHI or IO$M_VD_SYMBOL_TABLE,
	P1   = vkb$wv_current_symbol_table [0],
	P2   = ctr [1] - vkb$wv_current_symbol_table [0],
	P3   = tt_list);

return SS$_NORMAL;

end;




%SBTTL 'vs$$set_vkb_devdepend -- Set VKB Terminal-type Characteristics'
GLOBAL ROUTINE vs$$set_vkb_devdepend(
			vkb_id,			!ID of vkb
			devdepend_bits,		!Char. bits of VKB to modify
			requestor_pid		!Who's trying to do it
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for setting certain VKB characteristics
! for the caller which apply to input-type terminal settings under VMS. The
! bit definitions are the TT$M_xxx as defined by $TTDEF. They will effect how
! certain characters are interpreted during processing.
!
! FORMAL PARAMETERS:
!
!	VKB_ID          : Longword ID of virtual keyboard
!				(input parameter)
!	DEVDEPEND_BITS	: Longword new VKB characteristics
!				(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! Returns "SS$_NORMAL" if successful, or SS$_NOSUCHDEV if not found
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	pb_adr: REF pb_block,			!Corresponding PB block address
	vkb_adr: REF vkb_block;			!Virtual Keyboard Block address

!
! First make sure that this virtual keyboard exists
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! If a corresponding pasteboard exists, check the caller's WRITE access to it
!
	IF vs$$vds_pb_found(.vkb_id,pb_adr) THEN
	  IF NOT vsta$$acp_check_write_access(
					$requestor,
					.pb_adr[vs$vds_l_pb_uic],
					.pb_adr[vs$vds_w_pb_prot]) THEN
	    $return_error(vsta$_noaccess,
			string_type, %ASCID 'WRITE',
			string_type, %ASCID 'Virtual Keyboard',
			integer_type, .vkb_id);
!
! Turn the bits on and off as specified
!
	vkb_adr[vs$vkb_l_char] = .devdepend_bits;
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$set_vkb_devdepend


%SBTTL 'vs$$get_vkb_char -- Get Virtual Keyboard Characteristics'
GLOBAL ROUTINE vs$$get_vkb_char(
			vkb_id,			!ID of vkb
			state_bits,		!State of VKB
			trans_table,		!Translation table
			char_bits,		!Terminal-type characteristics
			requestor_pid		!Who's asking
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for returning certain VKB characteristics
! to the caller which were deemed suitable for external knowledge.
!
! FORMAL PARAMETERS:
!
!	VKB_ID          : Longword ID of virtual keyboard
!				(input parameter)
!	STATE_BITS	: Address for longword current VKB states
!				(output parameter)
!	TRANS_TABLE	: Address for longword Translation table constant
!				(output parameter)
!	CHAR_BITS	: Address for longword current VKB characteristics
!				(output parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! Returns "SS$_NORMAL" if successful, or SS$_NOSUCHDEV if not found
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	pb_adr: REF pb_block,			!Corresponding PB block address
	vkb_adr: REF vkb_block;			!Virtual Keyboard Block address

!
! First make sure that this virtual keyboard exists
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! If a corresponding pasteboard exists, check the caller's READ access to it
!
	IF vs$$vds_pb_found(.vkb_id,pb_adr) THEN
	  IF NOT vsta$$acp_check_read_access(
					$requestor,
					.pb_adr[vs$vds_l_pb_uic],
					.pb_adr[vs$vds_w_pb_prot]) THEN
	    $return_error(vsta$_noaccess,
			string_type, %ASCID 'READ',
			string_type, %ASCID 'Virtual Keyboard',
			integer_type, .vkb_id);
!
! Return the information desired to the caller
!
	IF .state_bits NEQ 0 THEN
	  .state_bits = .vkb_adr[vs$vkb_l_state];
	IF .trans_table NEQ 0 THEN
	  .trans_table = .vkb_adr[vs$vkb_l_trans_table];
	IF .char_bits NEQ 0 THEN
	  .char_bits = .vkb_adr[vs$vkb_l_char];
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$get_vkb_char


%SBTTL 'vs$$inject_input_stream -- Inject into a VKB Input Stream'
GLOBAL ROUTINE vs$$inject_input_stream(
			vkb_id,			!ID of vkb
			buffer,			!Source address
			buffer_size		!Source buffer size
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for injecting characters into the
! input stream for a particular virtual keyboard device.
!
! FORMAL PARAMETERS:
!
!	VKB_ID      : Longword ID of virtual keyboard
!				(input parameter)
!	BUFFER 	    : Address of source buffer
!				(input parameter)
!	BUFFER_SIZE : Longword source buffer size
!				(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! Returns "SS$_NORMAL" if successful, or error status returned by vs$$acp_GET_VM
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	This routine must run in kernel mode.
!
!--
BEGIN

LOCAL
	unencoded_buffer: REF BLOCK[0,BYTE],	!Up/down char. buffer
	vkb_adr: REF vkb_block,			!Virtual Keyboard Block address
	status;					!To contain return status value

!
! *** THIS ENTIRE ROUTINE WILL BE COMMENTED OUT UNTIL OR UNLESS REQUIRED
!  FOR THE HUMAN INTERFACE COMPOSE KEY PROCESSING ***
!
! First make sure that this virtual keyboard exists
!
!	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
!	  $return_error(vsta$_nosuchvkb);
!
! Allocate local memory to hold unencoded buffer
!
!	IF (NOT (status = vs$$acp_get_vm (%REF (.buffer_size),
!					unencoded_buffer))) THEN
!	  RETURN .status;
!
! Convert ascii to up/down encoding in input buffer
!
!	IF (NOT (status = vs$$unencode_string(
!				.buffer,
!				.buffer_size,
!				.unencoded_buffer))) THEN
!	  RETURN .status;
!
! Pass unencoded buffer to physical keyboard driver to place into the input
! stream
!
!	status = $QIOW(
!			EFN  = .load_ef,
!			CHAN = .vkb_adr[vs$vkb_w_pkb_chan],
!			FUNC = IO$_LOADKB + IO$M_INJECT,
!			P1   = .unencoded_buffer,
!			P2   = .buffer_size
!		);
!
! Deallocate local memory holding unencoded buffer
!
!	vs$$acp_free_vm (%REF (.buffer_size),unencoded_buffer);
!
	RETURN .status;
END;				! of routine vs$$inject_input_stream


%SBTTL 'vs$$delete_vkb -- Delete a Virtual Keyboard'
GLOBAL ROUTINE vs$$delete_vkb(
				vkb_id		!Virtual Keyboard ID to delete
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for any clean-up operations necessary to
! delete a virtual keyboard device.
!
! FORMAL PARAMETERS:
!
!	VKB_ID : Longword virtual keyboard ID to be deleted
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! SS$_NOSUCHDEV if the virtual keyboard block is not found.
! Returns "SS$_NORMAL" if successful, or error status returned by vs$$acp_FREE_VM
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	asts_enabled,				!To see if need be reenabled
	arg_list: VECTOR[2],			!$CMKRNL argument block addr.
	vkb_adr: REF vkb_block,			!Virtual Keyboard Block address
	status;					!To contain return status value

!
! See if the virtual keyboard to be deleted is known
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! Deactivate this VKB if its active (the characters typed will be thrown
! away until another VKB is activated on this physical keyboard).
!
	asts_enabled = $SETAST( ENBFLG = false	);
	vs$$deactivate_vkb(.vkb_id);
!
! Terminate any I/O operations on this virtual keyboard on behalf of any
! application programs
!
	vsta$$kernel_call(
		vs$$acp_flush_reads,
		.vkb_id,
		0);				!All processes
!
	IF .vkb_adr[vs$vkb_v_read] THEN
	  vs$$vkb_done_io(.vkb_adr,SS$_NOSUCHDEV);
!
	IF .asts_enabled EQL SS$_WASSET THEN
	  $SETAST( ENBFLG = true );		!Reenable AST delivery
!
! Flush any outstanding AST's (control_c, control_y, and out_of_band)
! THIS SHOULD ALREADY BE HANDLED BY $CANCEL ON THE DEVICE ***
!
!	arg_list[0] = 1;
!	arg_list[1] = .vkb_adr;
!	$CMKRNL(
!		ROUTIN = vs$$flush_asts,
!		ARGLST = arg_list);
!
! Remove this virtual keyboard from the list of known keyboards and free the
! memory occupied by its data structure
!
	REMQUE(.vkb_adr,vkb_adr);
!
	vs$$free_vkb(.vkb_adr);
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$delete_vkb


%SBTTL 'vs$$set_vkb_mode -- Set the Mode/Char. of a Virtual Keyboard'
GLOBAL ROUTINE vs$$set_vkb_mode(
		vkb_id,				!Virtual Keyboard ID to affect
		ctrl_c_ast: REF BLOCK[0,BYTE],	!Address of Control C ACB
		ctrl_y_ast: REF BLOCK[0,BYTE],	!Address of Control Y ACB
		out_of_band_ast: REF BLOCK[0,BYTE],!Address of out-of-band ACB
		out_of_band_mask		!Mask of out-of-band characters
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for changing the mode/characteristics of
! a virtual keyboard device as if it was a standard terminal device for future
! I/O operations.
!
! FORMAL PARAMETERS:
!
!	VKB_ID		 : Longword virtual keyboard ID
!				(input parameter)
!	CTRL_C_AST	 : Control C AST control block address to be added
!			   to list
!				(input parameter)
!	CTRL_Y_AST	 : Control Y AST control block address to be added
!			   to list
!				(input parameter)
!	OUT_OF_BAND_AST  : Out-of-band AST control block address to be added
!			   to list
!				(input parameter)
!	OUT_OF_BAND_MASK : Out-of-band character mask for AST delivery
!				(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! SS$_NOSUCHDEV if the virtual keyboard block is not found.
! SS$_NORMAL if successful
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	This routine must run in kernel mode (ACB's in non-paged pool)
!
!--
BEGIN

LOCAL
	vkb_adr: REF vkb_block,			!Virtual Keyboard Block address
	status;					!To contain return status value

!
! See if the virtual keyboard is known
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! Virtual Keyboard found -- If any of the AST routine addresses are non-zero,
! add them to the appropriate list for this virtual keyboard
!
	IF .ctrl_c_ast NEQ 0 THEN
	  BEGIN
	    ctrl_c_ast[ACB$L_ASTQFL] = .vkb_adr[vs$vkb_a_control_c_ast];
	    vkb_adr[vs$vkb_a_control_c_ast] = .ctrl_c_ast;
	  END;
!
	IF .ctrl_y_ast NEQ 0 THEN
	  BEGIN
	    ctrl_y_ast[ACB$L_ASTQFL] = .vkb_adr[vs$vkb_a_control_y_ast];
	    vkb_adr[vs$vkb_a_control_y_ast] = .ctrl_y_ast;
	  END;
!
	IF .out_of_band_ast NEQ 0 THEN
	  BEGIN
	    out_of_band_ast[ACB$L_ASTQFL] = .vkb_adr[vs$vkb_a_out_of_band_ast];
	    vkb_adr[vs$vkb_a_out_of_band_ast] = .out_of_band_ast;
	    vkb_adr[vs$vkb_l_out_of_band_mask] = .out_of_band_mask;
	  END;
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$set_vkb_mode


%SBTTL 'vs$$set_vkb_state -- Set the State of a Virtual Keyboard'
GLOBAL ROUTINE vs$$set_vkb_state(
				vkb_id,		!Virtual Keyboard ID
				state		!Virtual keyboard state
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for setting the state of a virtual
! keyboard device as if it was a standard terminal device for future
! I/O operations. This routine is used to determine if read operations are
! to be blocked and therefore only allows the modification of the VS$VKB_M_WRITE
! bit in the state.
!
! FORMAL PARAMETERS:
!
!	VKB_ID : Longword virtual keyboard ID to be deleted
!			(input parameter)
!	STATE  : Longword virtual keyboard state information
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! SS$_NOSUCHDEV if the virtual keyboard block is not found.
! SS$_NORMAL if successful
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	vkb_adr: REF vkb_block;		!Virtual Keyboard Block address

!
! See if the virtual keyboard is known
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! Virtual Keyboard found -- Change its state (only the WRITE bit is settable
! from outside this module using this routine).
!
	vkb_adr[vs$vkb_l_state] = .vkb_adr[vs$vkb_l_state] AND
			((NOT vs$vkb_m_write) OR (.state AND vs$vkb_m_write));
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$set_vkb_state


%SBTTL 'vs$$get_vkb_state -- Get the State of a Virtual Keyboard'
GLOBAL ROUTINE vs$$get_vkb_state(
				vkb_id,		!Virtual Keyboard ID
				state		!Virtual keyboard state
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for getting the state of a virtual
! keyboard device as if it was a standard terminal device for future
! I/O operations.
!
! FORMAL PARAMETERS:
!
!	VKB_ID : Longword virtual keyboard ID to be deleted
!			(input parameter)
!	STATE  : Address for longword virtual keyboard state information
!			(output parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! SS$_NOSUCHDEV if the virtual keyboard block is not found.
! SS$_NORMAL if successful
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	vkb_adr: REF vkb_block;		!Virtual Keyboard Block address

!
! See if the virtual keyboard is known
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! Virtual Keyboard found -- Return its state
!
	.state = .vkb_adr[vs$vkb_l_state];
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$get_vkb_state


%SBTTL 'vs$$read_vkb -- Read from a Virtual Keyboard'
GLOBAL ROUTINE vs$$read_vkb(
				vkb_id,		!Virtual Keyboard to read
				func,		!$QIO function code
				buffer,		!Read buffer address
				buffer_size,	!Read buffer size
				timeout,	!I/O completion timeout
				break_table,	!I/O completion break table
				prompt_string,	!Read w/prompt string addr.
				prompt_length,	!Read w/prompt string length
				irp_adr,	!I/O request packet address
				requestor_pid	!Who's trying to read
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for reading from a virtual keyboard
! device as if it was a physical keyboard. If this virtual keyboard is not
! currently attached to the physical keyboard, then an outstanding read
! request is entered for this vkb. If this vkb is attached but VBDRIVER is
! busy with another request, then an outstanding read request is entered
! for this vkb. If this vkb IS attached to the physical keyboard AND
! VBDRIVER is not busy, then a VB read request is issued.
!
! FORMAL PARAMETERS:
!
!	VKB_ID      : Longword virtual keyboard ID from which to read
!			(input parameter)
!	FUNC	    : Longword $QIO function code
!			(input parameter)
!	BUFFER 	    : Read request buffer address		=> P1
!			(input parameter)
!	BUFFER_SIZE : Read request buffer size			=> P2
!			(input parameter)
!	TIMEOUT	    : Read timeout				=> P3
!			(input parameter)
!	BREAK_TABLE : Read termination break table address	=> P4
!			(input parameter)
!	PROMPT_STRING : Read w/prompt string address		=> P5
!			(input parameter)
!	PROMPT_LENGTH : Read w/prompt string length		=> P6
!			(input parameter)
!	IRP_ADR	    : I/O request packet address
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! Returns "SS$_NORMAL" if successful, or error status returned by vs$$acp_GET_VM
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	func_mask: INITIAL(%X'3F'),		!Mask off function code
	arg_list: VECTOR[4],			!$CMKRNL arg. block to copy prompt
	str_length,				!Length of ascii time string
	rr_adr: REF vkb_read_request,		!VKB current read context
	vkb_adr: REF vkb_block,			!Virtual Keyboard block address
	pb_adr: REF pb_block,			!Corresponding PB block address
	status;					!To contain return status value
!
! Make sure that this is a known virtual keyboard and that a read
! is not already active on it 
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  BEGIN
	    IF .irp_adr LSS 0 THEN
	      vs$$acp_done_io(SS$_NOSUCHDEV,0,.irp_adr);
	    $return_error(vsta$_nosuchvkb);
	  END;
	IF .vkb_adr[vs$vkb_v_read] THEN
	  BEGIN
	    vs$$vkb_done_io(.vkb_adr,SS$_DEVREQERR);
	    $return_error(vsta$_vkbrdactv);
	  END;
!
! If a corresponding pasteboard exists, check the caller's READ access to it.
! We use the special PB access routine so that even though OUR uic is stored
! as the pasteboard owner, the user on an emulated terminal can still read
! from the pasteboard.
!
	IF vs$$vds_pb_found(.vkb_id,pb_adr) THEN
	  IF NOT vsta$$acp_check_pb_read_access(
					$requestor,
					.pb_adr[vs$vds_l_pb_uic],
					.pb_adr[vs$vds_w_pb_prot],
					pb_adr[$base]) THEN
	    BEGIN
	      vs$$vkb_done_io(.vkb_adr,SS$_NOPRIV);
	      $return_error(vsta$_noaccess,
			string_type, %ASCID 'READ',
			string_type, %ASCID 'Virtual Keyboard',
			integer_type, .vkb_id);
	    END;
!
	vkb_adr[vs$vkb_v_read] = true;
!
! Save the current state of the device (We have to go get it if its an
! emulated terminal).
!
	IF .vkb_adr[vs$vkb_l_vd_id] NEQ 0 THEN
	  BEGIN
	    arg_list[0] = 1;
	    arg_list[1] = .vkb_adr;
	    $CMKRNL(
		ROUTIN = vs$$get_device_char,
		ARGLST = arg_list);
	    $CMKRNL(
		ROUTIN = vs$$no_typeahead,
		ARGLST = arg_list);
	  END;
!
! Initialize the new read request context
!
	rr_adr = .vkb_adr[vs$vkb_a_current_read];
	rr_adr[vs$rr_w_size] = vs$rr_k_block_size;
	rr_adr[vs$rr_w_type] = 0;
	rr_adr[vs$rr_a_vkb] = .vkb_adr;
	rr_adr[vs$rr_a_irp] = .irp_adr;
	rr_adr[vs$rr_l_full_function] = .func;
	rr_adr[vs$rr_l_function_code] = .func AND .func_mask;
	IF (.rr_adr[vs$rr_l_function_code] EQL IO$_READVBLK) OR
	   (.rr_adr[vs$rr_l_function_code] EQL IO$_READLBLK) OR
	   (.rr_adr[vs$rr_l_function_code] EQL IO$_READPROMPT) THEN
	  rr_adr[vs$rr_l_read_all] = false
	ELSE
	  rr_adr[vs$rr_l_read_all] = true;
	rr_adr[vs$rr_a_buffer] = .buffer;
	rr_adr[vs$rr_l_buffer_size] = .buffer_size;
	rr_adr[vs$rr_l_buffer_ptr] = 0;
	IF .vkb_adr[vs$vkb_l_trans_table] EQL vsta$k_tt_unencoded THEN
	  rr_adr[vs$rr_b_buffer_inc] = 2
	ELSE
	  rr_adr[vs$rr_b_buffer_inc] = 1;
	rr_adr[vs$rr_w_terminator] = 0;
	rr_adr[vs$rr_w_terminator_size] = 0;
	rr_adr[vs$rr_l_prompt_length] = .prompt_length;
	rr_adr[vs$rr_w_cursor_start] = 1;
!
! If the read buffer size is insufficient then do NOT continue
!
	IF .buffer_size LSS .rr_adr[vs$rr_b_buffer_inc] THEN
	  BEGIN
	    vs$$vkb_done_io(.vkb_adr,SS$_BUFNOTALIGN);
	    RETURN SS$_NORMAL;
	  END;
!
! Cancel control-o if enabled and if output device
!
	IF .vkb_adr[vs$vkb_l_vd_id] NEQ 0 THEN
	  vsta$$odrv_control_o(
			.vkb_adr[vs$vkb_l_vd_id],
			false);
!
! Make a local copy of the prompt string if there is one
!
	IF ((.rr_adr[vs$rr_l_function_code] EQL IO$_READPROMPT) OR
	    (.rr_adr[vs$rr_l_function_code] EQL IO$_TTYREADPALL)) AND
	    (.prompt_length GTR 0) THEN
	  BEGIN
	    IF (NOT (status = vs$$acp_get_vm (%REF(.prompt_length),
				rr_adr[vs$rr_a_prompt_string]))) THEN
	      rr_adr[vs$rr_l_prompt_length] = 0
	    ELSE
	      BEGIN
!
		arg_list[0] = 3;
		arg_list[1] = .prompt_length;
		arg_list[2] = .prompt_string;
		arg_list[3] = .rr_adr[vs$rr_a_prompt_string];
		$CMKRNL(
			ROUTIN = vs$$kmode_move,
			ARGLST = arg_list);
	      END;
	  END
	ELSE
	  rr_adr[vs$rr_l_prompt_length] = 0;
!
! Force out a line_feed before the read if not a passall type read and
! a free line-feed is required 
!
	IF .vkb_adr[vs$vkb_l_vd_id] NEQ 0 THEN
	  IF (NOT .rr_adr[vs$rr_l_read_all]) AND
	    ((.vkb_adr[vs$vkb_l_char] AND TT$M_PASSALL) EQL 0) AND
	    ((.rr_adr[vs$rr_l_full_function] AND IO$M_NOFILTR) EQL 0) THEN
	    BEGIN
	      IF vsta$$odrv_send_lf(.vkb_adr[vs$vkb_l_vd_id]) THEN
		vs$$vds_synchronize_echo(
			.vkb_adr[vs$vkb_l_vd_id],
			.vkb_adr[vs$vkb_a_echo_routine],
			UPLIT BYTE(line_feed),
			1);
	    END;
!
! If echo routine address for this virtual keyboard is nonzero,
! output the prompt string
!
	IF (.rr_adr[vs$rr_l_function_code] EQL IO$_READPROMPT) OR
	   (.rr_adr[vs$rr_l_function_code] EQL IO$_TTYREADPALL) THEN
	  BEGIN
	    vkb_adr[vs$vkb_v_read_active] = true;
	    vs$$display_prompt(.vkb_adr);
	  END;
!
! Make a local copy of the break table
!
	arg_list[0] = 3;
	arg_list[1] = vs$k_break_table_size;
	arg_list[2] = .break_table;
	arg_list[3] = .rr_adr[vs$rr_a_break_table];
	$CMKRNL(
		ROUTIN = vs$$kmode_move,
		ARGLST = arg_list);
!
! Purge the typeahead buffer before the read if requested or if none allowed
!
	IF ((.rr_adr[vs$rr_l_full_function] AND IO$M_PURGE) NEQ 0) OR
	   ((.vkb_adr[vs$vkb_l_char] AND TT$M_NOTYPEAHD) NEQ 0) THEN
	  BEGIN
	    arg_list[0] = 2;
	    arg_list[1] = .vkb_adr;
	    arg_list[2] = -1;
	    $CMKRNL(
		ROUTIN = vs$$purge_typeahead,
		ARGLST = arg_list);
	  END;
!
! Disable unsolicited data mailbox messages if so desired
!
	IF (.rr_adr[vs$rr_l_full_function] AND IO$M_DSABLMBX) NEQ 0 THEN
	  vsta$$odrv_mbx_enable(
			.vkb_adr[vs$vkb_l_vd_id],
			false);
!
! If the user specified a timeout on the read, set the timer
!
	IF (.rr_adr[vs$rr_l_full_function] AND IO$M_TIMED) NEQ 0 THEN
	  BEGIN
	    EMUL(
		%REF(-10000000),
		timeout,
		%REF(0),
		rr_adr[vs$rr_q_timeout]);
	    $SETIMR(
		DAYTIM = rr_adr[vs$rr_q_timeout],
		ASTADR = vs$$read_timeout_ast,
		REQIDT = .vkb_id);
	  END;
!
! See if the typeahead buffer for this virtual keyboard satisfies the
! request
!
	IF vs$$read_satisfied(
				.vkb_adr,
				status) THEN
	  BEGIN
!
! Typeahead buffer satisfied read request -- Inform VDDRIVER* and complete
! the I/O
!
	    vs$$vkb_done_io(.vkb_adr,.status);
	    RETURN SS$_NORMAL;
	  END;
!
! Typeahead buffer did NOT satisfy this read request. Flag that a read is
! in progress on this VKB.
!
! If the virtual keyboard specified is the "current" virtual keyboard, then
! inform VBDRIVER of new read context to use to terminate outstanding read.
!
	IF .vkb_adr[vs$vkb_v_timeout] THEN
	  vs$$vkb_done_io(.vkb_adr,SS$_TIMEOUT)
	ELSE
	  vkb_adr[vs$vkb_v_read_asts] = true;
!
	RETURN SS$_NORMAL;	!return control back to caller
END;				! of routine vs$$read_vkb


%SBTTL 'vs$$vkb_cancel_read -- Cancel the Current Read on a VKB'
GLOBAL ROUTINE vs$$vkb_cancel_read(
			vkb_id,			!ID of virtual keyboard
			requestor_pid,		!PID of cancel request
			vd_chan			!CHANNEL to cancel
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for canceling the current read on any
! VKBs with the specified ID by doing any I/O postprocessing with
! a return status of SS$_ABORT (to signify that it was in progress). If the
! owner of the VKB is requesting cancellation or the ACP itself, it shall be
! done. Otherwise, the request is ignored. Thus, the following are possible:
!		1. Cancel reads on a specific VKB for a specific channel
!		2. Cancel reads on a specific VKB for all channels
!		3. Cancel reads on all VKBs for all channels
!
! FORMAL PARAMETERS:
!
!	VKB_ID          : Longword ID of virtual keyboard
!				(input parameter)
!			 or ZERO to cancel reads on all VKBs
!	REQUESTOR_PID	: Longword PID of cancellation requestor
!				(input parameter)
!			 or ZERO to cancel reads for all processes
!
!	CHANNEL		: Longword CHANNEL, used with pid to selectively
!			  cancel only the correct reads
!				(input parameter)
!
! IMPLICIT INPUTS:
!
!	vs$vkb_list : Queue header for known virtual keyboards
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
! Returns "SS$_NORMAL" if successful
! Returns "SS$_NOSUCHDEV" if unable to locate VKB
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	asts_enabled,				!To see if need be reenabled
	vkb_adr: REF vkb_block;			!Virtual Keyboard Block address

!
! For each virtual keyboard in the list, if the output device corresponds
! to the one passed as a parameter and there is a read active on it, then
! cancel the read operation (Note that a vd_id of zero will cause the
! cancellation of all reads on all VKBs.)
!
	vkb_adr = .vs$vkb_list[0];
	WHILE .vkb_adr NEQ vs$vkb_list[0] DO
	  BEGIN
	    IF .vkb_adr[vs$vkb_l_id] EQL .vkb_id OR .vkb_id EQL 0
	    THEN
	      
		BEGIN
!
! Disable AST delivery until we verify that a read is active and do I/O
! post-processing
!
		  asts_enabled = $SETAST( ENBFLG = false	);
!
! Cancel any blocked reads for this virtual keyboard if pid and
! channel matches.
!
		  vsta$$kernel_call(
			vs$$acp_flush_reads,
			.vkb_adr[vs$vkb_l_id],
			.requestor_pid,
			.vd_chan);
!
! If there is a read currently active for the specified pid on specified
! channel, then SS$_ABORT it.
!
		IF .vkb_adr[vs$vkb_v_read] THEN
		    begin
		    bind
			rr_adr = .vkb_adr[vs$vkb_a_current_read]
			    : vkb_read_request,	
			cur_irp = .rr_adr[vs$rr_a_irp] : irp_block;
		    if (vsta$$read_kernel_long (cur_irp[irp$l_pid]) eql
			.requestor_pid
			    and vsta$$read_kernel_word (cur_irp[irp$w_chan])
				eql .vd_chan)
			 or .requestor_pid eql 0
		    then vs$$vkb_done_io (.vkb_adr,SS$_ABORT)
		    end;
!
		  IF .asts_enabled EQL SS$_WASSET THEN
		    $SETAST( ENBFLG = true );		!Reenable AST delivery
		END;		!Of if output device matched
	    vkb_adr = .vkb_adr[vs$vkb_a_next_ptr];
	  END;
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$vkb_cancel_read


%SBTTL 'vs$$vkb_do_control_r -- Control R Processing (for $BRDCSTs)'
GLOBAL ROUTINE vs$$vkb_do_control_r(
				vkb_id			!VKB ID
			) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for control-R processing. All echoing is
! done at a higher level. This routine will cause the current line to be
! redisplayed if the specified VKB exists and has a read active on it.
!
! FORMAL PARAMETERS:
!
!	VKB_ID	      : Longword ID of Virtual Keyboard
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	vkb_adr: REF vkb_block;		!VKB data block address

!
! Make sure the VKB exists. If not just return error indication.
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! Just use the internal control_r logic now that we've found the data base
! address
!
	vs$$do_control_r(.vkb_adr);
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$vkb_do_control_r


%SBTTL 'vs$$vkb_done_io -- VKB Read Completion Processing'
ROUTINE vs$$vkb_done_io(
		vkb_adr: REF vkb_block,		!Virtual Keyboard Block address
		status: WORD			!Return status value
				): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for VKB read completion processing.
! This involves copying the buffer into the caller's area, deleting the
! outstanding read request from the queue, canceling timeout timer requests,
! and delivering any AST's.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR		: Address virtual keyboard block
!				(input parameter)
!	STATUS		: Word read completion status
!				(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!  SS$_NORMAL or error status returned by vs$$acp_FREE_VM
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	byte_count: word,			! For IOSB data
	rr_adr: REF vkb_read_request;		!VKBs read request context
!
! Cancel timer requests for input on this virtual keyboard
!
	$CANTIM( REQIDT = .vkb_adr[vs$vkb_l_id] );
!
! If there is no read active, then we should just return
!
	IF NOT .vkb_adr[vs$vkb_v_read] THEN
	  RETURN;
!
! Clear the appropriate VKB state bits for read completion
!
	vkb_adr[vs$vkb_l_state] = .vkb_adr[vs$vkb_l_state] AND
		(NOT (vs$vkb_m_read OR vs$vkb_m_read_active OR vs$vkb_m_timeout
			OR vs$vkb_m_read_asts));
!
! Deallocate local copy of the prompt string
!
	rr_adr = .vkb_adr[vs$vkb_a_current_read];
	IF .rr_adr[vs$rr_l_prompt_length] neq 0
	THEN vs$$acp_free_vm (	rr_adr[vs$rr_l_prompt_length],
			rr_adr[vs$rr_a_prompt_string]);
!
! If the terminator was an escape sequence, recompute the buffer size
! and terminator size
!
	rr_adr[vs$rr_l_buffer_ptr] = .rr_adr[vs$rr_l_buffer_ptr] -
					.rr_adr[vs$rr_w_terminator_size];
	byte_count = .rr_adr[vs$rr_l_buffer_ptr];
!
! If IRP address is positive, this was an internal read request and its the
! address of a routine to call
!
	IF .rr_adr[vs$rr_a_irp] GTR 0 THEN
	  BEGIN
	    vs$$vds_queue_int(
			.rr_adr[vs$rr_a_irp],
			.status,
			.byte_count,
			.rr_adr[vs$rr_w_terminator],
			.rr_adr[vs$rr_w_terminator_size]);
	    $WAKE();			!In case hibernating
	    RETURN;
	  END;
!
! Complete the I/O operation on behalf of the user
!
	vs$$acp_done_io(
	  (.byte_count^16) + .status,
	  (.rr_adr[vs$rr_w_terminator_size]^16) + .rr_adr[vs$rr_w_terminator],
	   .rr_adr[vs$rr_a_irp]);
!
	RETURN;			!return
END;				! of routine vs$$vkb_done_io


%SBTTL 'vs$$read_complete_ast -- Read Completion AST from VBDRIVER'
ROUTINE vs$$read_complete_ast(
				astprm		!Read completion indicator
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for VBDRIVER read completion processing.
! This involves copying the buffer into the caller's area, deleting the
! outstanding read request from the queue, and queuing another request to
! VBDRIVER with or without a breaktable (depending on whether or not there
! is another read request to this vkb).
!
! FORMAL PARAMETERS:
!
!	ASTPRM : Longword read completion indicator
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!  SS$_NORMAL or error status returned by vs$$acp_FREE_VM
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	arg_list: VECTOR[2],			!$CMKRNL argument block
	rr_adr: REF vkb_read_request,		!Current VKB read context
	vkb_adr: REF vkb_block,			!Virtual Keyboard Block address
	status;					!To contain return status value

!
! If parameter to AST routine is negative, then typeahead buffer is full
! Ring the bell or something (depending on the mode of this VKB) ***
!
	IF .astprm LSS 0 THEN
	  astprm = -1 * .astprm;
!
! If parameter to AST routine is positive, then its the virtual keyboard ID
! of the read -- Make sure that this VKB hasn't been deleted while we waited.
!
	IF NOT vs$$vkb_found(.astprm,vkb_adr) THEN
	  RETURN SS$_NORMAL;
!
! If the virtual keyboard specified is the "current" virtual keyboard, then
! set up AST delivery on next character typed at physical keyboard
!
	IF .vkb_adr[vs$vkb_v_current] THEN
	  vs$$vkb_wake(.vkb_adr);
!
! Update the current state of the device (We have to go get it if its an
! emulated terminal from the UCB).
!
	IF .vkb_adr[vs$vkb_l_vd_id] NEQ 0 THEN
	  BEGIN
	    arg_list[0] = 1;
	    arg_list[1] = .vkb_adr;
	    $CMKRNL(
		ROUTIN = vs$$get_device_char,
		ARGLST = arg_list);
	  END;
!
! The virtual keyboard is still around. See if this is unsolicited data.
!
	IF NOT .vkb_adr[vs$vkb_v_read_asts] THEN
	  vs$$do_unsolicited(.vkb_adr)
	ELSE
	  BEGIN
!
! There is a read active on this virtual keyboard.
! See if the typeahead buffer for this virtual keyboard satisfies the
! request.
!
	    rr_adr = .vkb_adr[vs$vkb_a_current_read];
	    IF vs$$read_satisfied(
				.vkb_adr,
				status) THEN
!
! Typeahead buffer satisfied read request -- Inform VDDRIVER* and complete
! the I/O
!
	      vs$$vkb_done_io(.vkb_adr,.status)
	    ELSE
!
! If the user specified a timeout on the read, reset the timer
!
	      IF (.rr_adr[vs$rr_l_full_function] AND IO$M_TIMED) NEQ 0 THEN
	        BEGIN
		  $CANTIM( REQIDT = .vkb_adr[vs$vkb_l_id] );
		  $SETIMR(
			DAYTIM = rr_adr[vs$rr_q_timeout],
			ASTADR = vs$$read_timeout_ast,
			REQIDT = .astprm);
		END;
	  END;
!
	RETURN SS$_NORMAL;	!return status
END;				! of routine vs$$read_complete_ast


%SBTTL 'vs$$read_timeout_ast -- Read Timeout AST'
ROUTINE vs$$read_timeout_ast(
				astprm		!Read completion indicator
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for VBDRIVER read timeout processing.
! This involves copying the buffer into the caller's area, deleting the
! outstanding read request from the queue, and queuing another request to
! VBDRIVER with or without a breaktable (depending on whether or not there
! is another read request to this vkb).
!
! FORMAL PARAMETERS:
!
!	ASTPRM : Longword read completion indicator (Virtual Keyboard ID)
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!  SS$_NORMAL or error status returned by vs$$acp_FREE_VM
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	rr_adr: REF vkb_read_request,		!Current VKB read context
	vkb_adr: REF vkb_block,			!Virtual Keyboard Block address
	status;					!To contain return status value

!
! We timed out on read request -- Complete I/O processing if the VKB is
! still around (else its already been completed)
!
	IF NOT vs$$vkb_found(.astprm,vkb_adr) THEN
	  RETURN SS$_NORMAL;
!
! The virtual keyboard is still around -- Complete I/O processing with the
! appropriate information
!
	rr_adr = .vkb_adr[vs$vkb_a_current_read];
!
	IF .vkb_adr[vs$vkb_v_read_asts] THEN
	  vs$$vkb_done_io(.vkb_adr,SS$_TIMEOUT)
	ELSE
	  vkb_adr[vs$vkb_v_timeout] = true;
!
	RETURN SS$_NORMAL;
END;				! of routine vs$$read_timeout_ast


%SBTTL 'vs$$typeahead_full_ast -- VKB Typeahead Buffer Full Processing'
ROUTINE vs$$typeahead_full_ast(
				vkb_id				!VKB ID
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for processing when a virtual keyboard
! typeahead buffer is full. This means ringing the keyboard bell (if
! appropriate), reestablishing this AST, and finding out what character was
! typed and if processing is in order.
!
! FORMAL PARAMETERS:
!
!	VKB_ID	    : Virtual keyboard ID
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	status,					!$QIO return status value
	vkb_adr: REF vkb_block;			!VKB data base address

!
! Make sure that this VKB hasn't been deleted while we waited.
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  RETURN SS$_NORMAL;
!
! Make sure we find out next time the typeahead buffer is full
!
	IF NOT (status = $QIOW(
				EFN  = .load_ef,
				CHAN = .vkb_adr[vs$vkb_w_pkb_chan],
				FUNC = (IO$_VB_KEYBOARD or IO$M_VB_LOADKB),
				IOSB = iosb,
				P1   = .vkb_adr[vs$vkb_a_ring_buffer],
				P2   = .vkb_adr[vs$vkb_l_buffer_size],
				P3   = vs$$typeahead_full_ast,
				P4   = .vkb_id,
				P5   = 0	!Threshold based on mode
				)) THEN
	  vsta$$error_logger(.status);
!
! For lack of anything better to do here before returning, ring the keyboard
! bell at the current volume setting.  However, don't do it at ast level,
! because the mechanism uses the native graphics queues.
!
	vs$$post_ast_request (vsta$$kbrd_sound_bell,
	    .vkb_adr[vs$vkb_w_pkb_chan]);
!
	RETURN SS$_NORMAL;	!return with a positive attitude
END;				! of routine vs$$typeahead_full_ast


%SBTTL 'vs$$reconnect_kb_ast -- Attempt KB Reconnection After Error'
ROUTINE vs$$reconnect_kb_ast(
				vkb_id				!VKB ID
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for attempting to reestablish keyboard
! connection after it was lost due to some error. In other words, during the
! normal processing of keyboard input, the $QIO which requests notification
! when the next keycode transition occurs returned an error status. This
! means we have no way of finding out that anything is being typed on the
! keyboard forever! In that situation, we will attempt to cause the ACP to
! flush all its output to the driver and then call this routine to reestablish
! the keyboard connection. This assumes that we got an error due to some sort
! of quota problem. This routine will continue this loop until successful.
!
! FORMAL PARAMETERS:
!
!	VKB_ID	    : Virtual keyboard ID
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LITERAL
	reconnect_retry_limit = 10;		!Max. allowed retries
LOCAL
	status,					!$QIO return status value
	vkb_adr: REF vkb_block;			!VKB data base address

!
! Make sure that this VKB hasn't been deleted while we waited.
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  RETURN SS$_NORMAL;
!
! Let's try to find out the next time a character is typed on the keyboard
!
	IF (status = vs$$vkb_wake(.vkb_adr)) THEN
	  BEGIN
	    reconnect_count = 0;
	    RETURN SS$_NORMAL;
	  END;
!
! If it failed again, set up to try this again sometime if less than
! our maximum retry limit.
!
	reconnect_count = .reconnect_count + 1;
	IF .reconnect_count LSS reconnect_retry_limit THEN
	  BEGIN
	    vs$$post_ast_request(
			vsta$$drive_noop,
			.vkb_adr[vs$vkb_w_pkb_chan],
			0,
			vs$$reconnect_kb_ast,
			.vkb_id);
	    RETURN SS$_NORMAL;
	  END;
!
! We've failed this $QIO for the last time! Might as well do an end-session
! and see if we can get the keyboard back
!
	reconnect_count = 0;
	vs$$post_ast_request( vsta$$srv_end_session );
!
	RETURN SS$_NORMAL;	!return with a positive attitude
END;				! of routine vs$$reconnect_kb_ast




%SBTTL 'vs$$inquire_current_vkb'
GLOBAL ROUTINE vs$$inquire_current_vkb(
				vkb_id_reta,
				vd_id_reta
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine determines the currently active vkb and returns its vkb id
! and its emulator vd id if an emulator owns this vkb.
!
! FORMAL PARAMETERS:
!
!  vkb_id_reta - Address which to place the vkb id of the currently
!                attached vkb
!
!  vd_id_reta  - Address which to place the vd_id of the emulator if
!	 	 this vkb belongs to an emulator
!
!--
BEGIN

LOCAL
	vkb_ptr: REF vkb_block;			!Ptr to arbitrary VKB

!
! Search through the list of known virtual keyboards for the physical keyboard
! channel number passed as a parameter and clear the "current" bit in its
! state if current.
!
	vkb_ptr = .vs$vkb_list[0];
	WHILE (.vkb_ptr NEQ vs$vkb_list[0]) DO
	  BEGIN

!*************************************************************
!	    IF .vkb_ptr[vs$vkb_w_pkb_chan] EQL .pkb_chan THEN
!*************************************************************


!
! Look for current vkb
!
	      IF .vkb_ptr[vs$vkb_v_current] THEN
		BEGIN

!
! Return the vkb id and vd id of this vkb
!
		  .vkb_id_reta = .vkb_ptr[vs$vkb_l_id];
		  .vd_id_reta = .vkb_ptr[vs$vkb_l_vd_id];
		  RETURN ss$_normal;

		END;
!
! Not found look at next one
!
	    vkb_ptr = .vkb_ptr[vs$vkb_a_next_ptr];

	  END;
!
	$return_error(vsta$_nosuchvkb);

END;				! of routine vs$$inquire_current_vkb


%SBTTL 'vs$$activate_vkb -- Attach a Virtual Keyboard to the Physical Keyboard'
GLOBAL ROUTINE vs$$activate_vkb(
				vkb_id		!Virtual Keyboard ID
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for associating a virtual keyboard to
! the physical keyboard device. This involves making this vkb the "current"
! vkb and if VBDRIVER is busy, issuing a read request to this vkb, else
! issuing the request to VBDRIVER.
!
! FORMAL PARAMETERS:
!
!	VKB_ID : Longword virtual keyboard ID (same as pasteboard ID)
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
! Returns "SS$_NORMAL" if successful, or error status returned by vs$$acp_GET_VM
! or SS$_NOSUCHDEV if device not found
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	vkb_adr: REF vkb_block,			!Virtual Keyboard Block address
	old_level,				!Previous VKB level 1/2 state
	table,					!Symbol table address
	status;					!To contain return status value

!
! Make sure that this is a known virtual keyboard and if so, make it the
! "current" virtual keyboard
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! If this VKB is already current, then we're done
!
	IF .vkb_adr[vs$vkb_v_current] THEN
	  RETURN SS$_NORMAL;
!
! If this is the first time we've activated a keyboard, allocate a couple
! of event flags for VBDRIVER $QIO interface.
!
	IF .first_activate THEN
	  BEGIN
	    IF (NOT (status = vsta$$get_ef( load_ef ))) THEN
	      RETURN .status;
!
	    IF (NOT (status = vsta$$get_ef( wake_ef ))) THEN
	      BEGIN
		lib$free_ef( load_ef );
		RETURN .status;
	      END;
!
	    first_activate = false;
	  END;
!
! First deactivate the "current" VKB on the same physical keyboard as this
! one (if there is one) and then make this one "current"
!
	vs$$deactivate_current_vkb(.vkb_adr[vs$vkb_w_pkb_chan],old_level);
!
! If this is an emulated terminal, "activate" the UCB
!
	IF .vkb_adr[vs$vkb_l_vd_id] NEQ 0 THEN
	  vs$$activate_terminal(.vkb_adr);
!
! If there is a pending read request for this virtual keyboard, initiate it
! by unblocking read requests in VDDRIVER* for this VKB and loading new context
!
	IF NOT (status = $QIOW(
				EFN  = .load_ef,
				CHAN = .vkb_adr[vs$vkb_w_pkb_chan],
				FUNC = (IO$_VB_KEYBOARD or IO$M_VB_LOADKB),
				IOSB = iosb,
				P1   = .vkb_adr[vs$vkb_a_ring_buffer],
				P2   = .vkb_adr[vs$vkb_l_buffer_size],
!***				P3   = vs$$typeahead_full_ast,
!***				P4   = .vkb_id,
				P5   = 0	!Threshold based on mode
				)) THEN
	  RETURN vsta$$error(.status);
!
	vkb_adr[vs$vkb_v_current] = true;
	vs$$vkb_wake(.vkb_adr);

!
! Tell the Human Interface to re-map the symbol keys and level-1/2 keys (if
! necessary)
!
	IF .vkb_adr[vs$vkb_l_trans_table] EQL vsta$k_tt_unencoded THEN
	  vsta$$hi_new_symbols( UPLIT(WORD(0,0,0,0,0,0)) )
	ELSE
	  BEGIN
	    table = .vtem$al_vkb_symbol_vecs[.vkb_adr[vs$vkb_l_trans_table]];
!
! Load translation table for this vkb
!
	    vs$$vkb_loadtt(.vkb_adr,.vkb_adr[vs$vkb_l_trans_table]);

!
! Load the NRC table associated with this virtual keyboard
!
	    vs$$vkb_load_nrc(.vkb_adr);

	    vsta$$hi_new_symbols(.table +
			.vkb_adr[vs$vkb_l_shift_symbol_map_boff]);
	  END;
!
	IF .old_level NEQ .vkb_adr[vs$vkb_v_level] THEN
	  BEGIN
	    IF .vkb_adr[vs$vkb_v_level] EQL vkb$k_level_1 THEN
	      vsta$$symb_display_level_1()
	    ELSE
	      vsta$$symb_remove_level_1();
	  END;
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$activate_vkb


%SBTTL 'vs$$activate_terminal -- Activate a Virtual Terminal'
ROUTINE vs$$activate_terminal(
			vkb_adr: REF vkb_block		!Virtual Keyboard adr.
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for activating a virtual terminal.
! This is done as part of virtual keyboard activation when it is part of
! an emulated terminal. This is the mechanism by which VDDRIVER knows which
! UCB is currently "active" on a particular VAXstation.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR : Address of virtual keyboard data base
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	LOAD_EF		: Event flag used for activation
!	IOSB		: I/O status block
!	VS$GW_VD_CHAN	: Channel to template VD device for this VAXstation
!	VS$AL_VD_UCB 	: Vector of VD UCBs
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
! Returns "SS$_NORMAL" if successful, or error status returned by vs$$acp_GET_VM
! or SS$_NOSUCHDEV if device not found
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	status;					!To contain return status value
!
! Inform VDDRIVER as to which UCB is "active" for this VAXstation
!
	IF NOT (status = $QIOW(
				EFN  = .load_ef,
				CHAN = .vs$gw_vd_chan,
				FUNC = IO$_ACTIVATE or IO$M_VD,
				IOSB = iosb,
				P3   = .vs$al_vd_ucb[.vkb_adr[vs$vkb_l_vd_id]]
				)) THEN
!
! If it failed, log the error before returning
!
	  vsta$$error_logger(.status);
!
	RETURN .status;		!return success
END;				! of routine vs$$activate_terminal


%SBTTL 'vs$$vkb_wake -- Setup Notification on Character Input'
ROUTINE vs$$vkb_wake(
			vkb_adr: REF vkb_block		!Virtual Keyboard adr.
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for setting up notification on character
! input from the physical keyboard device. If this virtual keyboard is not
! associated with a VD or UCB, then this is done via "wake" ASTs being
! delivered by VBDRIVER and reenabled by the ACP. If the VKB has an associated
! UCB, as with terminal emulators, the address of the port driver input service
! routine will be specified with a function modifier which indicates that the
! routine should be called directly by VBDRIVER. Since no ASTs are involved in
! the latter case, this need not be reenabled.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR : Address of virtual keyboard data base
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	WAKE_EF : Event flag to use for wakekb ASTs
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
! Returns "SS$_NORMAL" if successful, or error status returned by vs$$acp_GET_VM
! or SS$_NOSUCHDEV if device not found
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

OWN
	port_input_routine: INITIAL(0);		!Port driver input routine
LOCAL
	status;					!To contain return status value

!
! If this is a native virtual keyboard (no associated UCB), then setup a
! WAKEKB AST
!
	IF .vkb_adr[vs$vkb_l_vd_id] EQL 0 THEN
	  BEGIN
	    IF NOT (status = $QIOW(
				EFN  = .wake_ef,
				CHAN = .vkb_adr[vs$vkb_w_pkb_chan],
				FUNC = (IO$_VB_KEYBOARD or IO$M_VB_KB_SYSRTN or
					IO$M_VB_CANCEL),
				IOSB = iosb
				)) THEN
!
! If it failed, log the error and set up to try this again sometime
!
	      BEGIN
	        vsta$$error_logger(.status);
	        vs$$post_ast_request(
			vsta$$drive_noop,
			.vkb_adr[vs$vkb_w_pkb_chan],
			0,
			vs$$reconnect_kb_ast,
			.vkb_adr[vs$vkb_l_id]);
		RETURN SS$_NORMAL;
	      END;
!
	    IF NOT (status = $QIOW(
				EFN  = .wake_ef,
				CHAN = .vkb_adr[vs$vkb_w_pkb_chan],
				FUNC = (IO$_VB_KEYBOARD or IO$M_VB_WAKEKB),
				IOSB = iosb,
				P3   = vs$$read_complete_ast,
				P4   = .vkb_adr[vs$vkb_l_id],
				P5   = 1
				)) THEN
!
! If it failed, log the error and set up to try this again sometime
!
	      BEGIN
	        vsta$$error_logger(.status);
	        vs$$post_ast_request(
			vsta$$drive_noop,
			.vkb_adr[vs$vkb_w_pkb_chan],
			0,
			vs$$reconnect_kb_ast,
			.vkb_adr[vs$vkb_l_id]);
	      END;
	    RETURN SS$_NORMAL;
	  END;
!
! Determine the port driver input routine for terminal emulators
!
	IF .port_input_routine EQL 0 THEN
	  IF NOT (status = vsta$$kernel_call(
				vs$$acp_find_port_input,
				port_input_routine)) THEN
	    BEGIN
	      port_input_routine = 0;
	      vsta$$error_logger(.status);
	      RETURN .status;
	    END;
!
! Inform VBDRIVER of port driver input service routine to pass characters to
!
	IF NOT (status = $QIOW(
				EFN  = .wake_ef,
				CHAN = .vkb_adr[vs$vkb_w_pkb_chan],
				FUNC = (IO$_VB_KEYBOARD or IO$M_VB_KB_SYSRTN),
				IOSB = iosb,
				P3   = .port_input_routine
				)) THEN
!
! If it failed, log the error and set up to try this again sometime
!
	  BEGIN
	    vsta$$error_logger(.status);
	    vs$$post_ast_request(
			vsta$$drive_noop,
			.vkb_adr[vs$vkb_w_pkb_chan],
			0,
			vs$$reconnect_kb_ast,
			.vkb_adr[vs$vkb_l_id]);
	  END;
!
	RETURN .status;		!return status value
END;				! of routine vs$$vkb_wake


%SBTTL 'vs$$deactivate_vkb -- Detach a Virtual Keyboard from Physical Keyboard'
GLOBAL ROUTINE vs$$deactivate_vkb(
				vkb_id		!Virtual Keyboard ID
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for disassociating a virtual keyboard from
! the physical keyboard device. This involves making the default active VKB the
! "current" vkb.
!
! FORMAL PARAMETERS:
!
!	VKB_ID : Longword virtual keyboard ID (same as pasteboard ID)
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	DEFAULT_ACTIVE_VKB : Address of longword default active VKB ID
!
! IMPLICIT OUTPUTS:
!
!	DEFAULT_ACTIVE_VKB : Address of longword default active VKB ID
!	LAST_VKB_LEVEL     : "Boolean" last activated VKB level 1/2 indicator
!
! ROUTINE VALUE
! Returns "SS$_NORMAL" if successful, or error status returned by vs$$acp_GET_VM
! or SS$_NOSUCHDEV if device not found
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	All future characters typed at the physical keyboard will be directed
! to the default active VKB until another virtual keyboard is activated.
!
!--
BEGIN
EXTERNAL
	vsta$gl_end_session_flag;		!=1 if VB channel is deassigned
LOCAL
	vkb_adr: REF vkb_block,			!Virtual Keyboard Block address
	status;					!To contain return status value

!
! Make sure that this is a known virtual keyboard and if so, make sure its not
! the "current" virtual keyboard
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! If this VKB is not "current" on any physical keyboard devices, then return
! no-harm-done.
!
	IF NOT .vkb_adr[vs$vkb_v_current] THEN
	  RETURN SS$_NORMAL;
!
	vkb_adr[vs$vkb_v_current] = false;
!
! If this is an emulated terminal, "deactivate" the UCB
!
	IF .vkb_adr[vs$vkb_l_vd_id] NEQ 0 THEN
	  vs$$deactivate_terminal(.vkb_adr);
!
! If we are ending session, however, we have already deassigned the VB
! channel and can just return
!
	IF (.vsta$gl_end_session_flag) THEN
	  BEGIN
	    last_vkb_level = 0;
	    RETURN SS$_NORMAL;
	  END;
!
! Inform the physical keyboard driver not to use the current context for the
! input stream and to throw the characters away until further notice
!
	IF NOT (status = $QIOW(
				EFN  = .load_ef,
				CHAN = .vkb_adr[vs$vkb_w_pkb_chan],
				FUNC = (IO$_VB_KEYBOARD or IO$M_VB_LOADKB
				 or IO$M_VB_CANCEL),
				IOSB = iosb,
				P1   = 0,
				P2   = 0
				)) THEN
	  vsta$$error_logger(.status);
!
! Activate the default active virtual keyboard until another is explicitly
! activated (if such a thing exists)
!
	last_vkb_level = .vkb_adr[vs$vkb_v_level];
	IF .default_active_vkb EQL 0 THEN
	  vsta$$hi_new_symbols( UPLIT(WORD(0,0,0,0,0,0)) )
	ELSE
	  vs$$activate_vkb(.default_active_vkb);
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$deactivate_vkb


%SBTTL 'vs$$deactivate_terminal -- Deactivate a Virtual Terminal'
ROUTINE vs$$deactivate_terminal(
			vkb_adr: REF vkb_block		!Virtual Keyboard adr.
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for deactivating a virtual terminal.
! This is done as part of virtual keyboard deactivation when it is part of
! an emulated terminal. This is the mechanism by which VDDRIVER knows which
! UCB is currently "active" on a particular VAXstation.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR : Address of virtual keyboard data base
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	LOAD_EF		: Event flag used for activation
!	IOSB		: I/O status block
!	VS$GW_VD_CHAN	: Channel to template VD device for this VAXstation
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
! Returns "SS$_NORMAL" if successful, or error status returned by vs$$acp_GET_VM
! or SS$_NOSUCHDEV if device not found
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	status;				!To contain return status value

!
! Inform VDDRIVER that no UCB is "active" for this VAXstation
!
	IF NOT (status = $QIOW(
				EFN  = .load_ef,
				CHAN = .vs$gw_vd_chan,
				FUNC = IO$_DEACTIVATE or IO$M_VD,
				IOSB = iosb
				)) THEN
!
! If it failed, log the error before returning
!
	  vsta$$error_logger(.status);
!
	RETURN .status;		!return success
END;				! of routine vs$$deactivate_terminal


%SBTTL 'vs$$set_vkb_break_table -- Change a Virtual Keyboard Break Table'
ROUTINE vs$$set_vkb_break_table(
			vkb_id,		!Virtual Keyboard ID
			break_table	!New break table address
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for changing the break table of an
! existing virtual keyboard device for any subsequent read operations.
!
! FORMAL PARAMETERS:
!
!	VKB_ID      : Longword virtual keyboard ID
!			(input parameter)
!	BREAK_TABLE : Address of new break table to use for vkb
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	vkb_adr: REF vkb_block,			!Virtual Keyboard Block address
	status;					!To contain return status value

!
! Make sure that this virtual keyboard is known
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! For now, just copy in the new break table
!
	CH$MOVE(vs$k_break_table_size,		 !Number of bytes to copy
		.break_table,			 !Source address
		.vkb_adr[vs$vkb_a_break_table]); !Destination address
!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$set_vkb_break_table


%SBTTL 'vs$$get_vkb_break_table -- Get a Virtual Keyboard Break Table'
ROUTINE vs$$get_vkb_break_table(
			vkb_id,		!Virtual Keyboard ID
			break_table	!Break table address
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for getting the break table of an
! existing virtual keyboard device and returning it to the calling routine.
!
! FORMAL PARAMETERS:
!
!	VKB_ID      : Longword virtual keyboard ID
!			(input parameter)
!	BREAK_TABLE : Address to contain current break table
!			(output parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	vkb_adr: REF vkb_block,			!Virtual Keyboard Block address
	status;					!To contain return status value

!
! Make sure that this virtual keyboard is known
!
	IF NOT vs$$vkb_found(.vkb_id,vkb_adr) THEN
	  $return_error(vsta$_nosuchvkb);
!
! For now, just copy in the new break table
!
	CH$MOVE(vs$k_break_table_size,		 !Number of bytes to copy
		.vkb_adr[vs$vkb_a_break_table],  !Destination address
		.break_table);			 !Source address

!
	RETURN SS$_NORMAL;	!return success
END;				! of routine vs$$get_vkb_break_table


%SBTTL 'vs$$special_char -- Special Character Processing'
ROUTINE vs$$special_char(
			vkb_adr: REF vkb_block,		!Virtual Keyboard addr.
			special_char: REF vkb_ascii_word,
							!Special character
			action_only,			!Action-only character
			echoed				!Echoed or not flag
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for determining if the character passed
! is a special character and if so (and the modes and states of the VKB allow
! interpretation of the character) processes the special character by
! delivering AST's and adjusting the input and output streams accordingly.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!	SPECIAL_CHAR  : Address of special character word
!			(input parameter)
!	ACTION_ONLY   : Address to store action-only character indicator
!			(output parameter)
!	ECHOED	      : Address to store echoed/not-echoed indicator
!			(output parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	include_char: BYTE,			!Include char in input stream
	rr_adr: REF vkb_read_request,		!Current VKB read context
	arg_list: VECTOR[4],			!$CMKRNL argument block
	status;					!To contain return status value

	.action_only = .echoed = false;
!
! If this is not a special character then return false indication
!
	IF ((.special_char[vs$aw_b_char_code] GEQ space) AND 
	    (.special_char[vs$aw_b_char_code] NEQ delete)) OR
	    (.special_char[vs$aw_v_special]) THEN
	  RETURN false;
!
! Character is special. See if the VKB is in PASSALL mode or unencoded
! and if so, ignore it.
!
	IF .vkb_adr[vs$vkb_l_trans_table] EQL vsta$k_tt_unencoded THEN
	  RETURN true;
!
	IF (.vkb_adr[vs$vkb_l_char] AND TT$M_PASSALL) NEQ 0 THEN
	  RETURN true;
!
! See if we are supposed to interpret this character or just put it into
! the read buffer (if there is an active read)
!
	IF .vkb_adr[vs$vkb_v_read] THEN
	  BEGIN
	    rr_adr = .vkb_adr[vs$vkb_a_current_read];
	    IF  (.rr_adr[vs$rr_l_read_all]) OR
		((((.vkb_adr[vs$vkb_l_char] AND TT$M_ESCAPE) NEQ 0) OR
		((.rr_adr[vs$rr_l_full_function] AND IO$M_ESCAPE) NEQ 0)) AND
		 (.special_char[vs$aw_b_char_code] EQL escape)) OR
	      (((.rr_adr[vs$rr_l_full_function] AND IO$M_NOFILTR) NEQ 0) AND
	       (SELECTONE .special_char[vs$aw_b_char_code] OF
		  SET
		    [control_u] : true;
		    [control_r] : true;
		    [delete]    : true;
		    [OTHERWISE] : false;
		  TES)) THEN
!
! Character is special, but we're in passall mode or starting escape mode
! processing -- Just put in the user's buffer
!
	      RETURN true;
	  END;			!If active read on VKB
!
! This is a special character which must be interpreted.
! If there is an out-of-band AST routine defined for this character, use it.
!
	arg_list[0] = 3;
	arg_list[1] = .vkb_adr;
	arg_list[2] = .special_char[vs$aw_b_char_code];
	arg_list[3] = include_char;
!
	IF $CMKRNL(
		ROUTIN = vs$$do_out_of_band,
		ARGLST = arg_list) THEN
	  BEGIN
	    IF .include_char GTR 0 THEN
	      special_char[vs$aw_b_char_code] = .include_char
	    ELSE
	      BEGIN
	        .action_only = true;
	        RETURN true;
	      END;
	  END;
!
! We have now determined that special character interpretation is needed.
! However, if a passall-type read is active, the special character may also
! be used to terminate the read operation. So set the flag appropriately.
!
	IF .vkb_adr[vs$vkb_v_read] THEN
	  IF (NOT .rr_adr[vs$rr_l_read_all]) THEN
	    BEGIN
	      IF (.rr_adr[vs$rr_l_full_function] AND IO$M_NOFILTR) EQL 0 THEN
	        .action_only = true;
!
! For non-passall type reads, remaining processing for control_x is that of
! control_u.
!
	      IF .special_char[vs$aw_b_char_code] EQL control_x THEN
		special_char[vs$aw_b_char_code] = control_u;
	    END;
!
! Call the routine which is equipped to handle this particular character
!
	arg_list[0] = 1;
!
	SELECTONE .special_char[vs$aw_b_char_code] OF
	  SET
	    [delete]	: BEGIN
			    .echoed = true;
			    vs$$do_delete(.vkb_adr);
			  END;
	    [OTHERWISE] : CASE .special_char[vs$aw_b_char_code]
					FROM control_c TO control_y OF
			    SET
			     [control_c] : BEGIN
					     .echoed = true;
					    .action_only = false;
					     vs$$echo_character(
							.vkb_adr,
							.special_char);
					     $CMKRNL(
						ROUTIN = vs$$do_control_c,
						ARGLST = arg_list);
					   END;
			     [control_o] : BEGIN
					     .echoed = true;
					     vs$$do_control_o(.vkb_adr);
					   END;
			     [control_q] : BEGIN
					     .echoed = true;
					     vs$$do_control_q(.vkb_adr);
					   END;
			     [control_r] : BEGIN
					     .echoed = true;
			 		     IF .vkb_adr[vs$vkb_v_read] THEN
					       vs$$echo_character(
							.vkb_adr,
							.special_char);
					     vs$$do_control_r(.vkb_adr);
					   END;
			     [control_s] : BEGIN
					     .echoed = true;
					     vs$$do_control_s(.vkb_adr);
					   END;
			     [control_u] : BEGIN
					     .echoed = true;
					     vs$$do_control_u(.vkb_adr);
					   END;
			     [control_x] : BEGIN
					     .echoed = true;
					     vs$$do_control_x(.vkb_adr);
					   END;
			     [control_y] : BEGIN
					     .echoed = true;
					     .action_only = false;
			 		     vs$$echo_character(
							.vkb_adr,
							.special_char);
					     $CMKRNL(
						ROUTIN = vs$$do_control_y,
						ARGLST = arg_list);
					   END;
			     [INRANGE]   : BEGIN
					     .action_only = false;
					     RETURN true;
					   END;
			     [OUTRANGE]  : BEGIN
					     .action_only = false;
					     RETURN true;
					   END;
			    TES;	!Case of control character echoing
	  TES;				!To save on space since delete big
!
	RETURN true;		!return success
END;				! of routine vs$$special_char


%SBTTL 'vs$$do_control_c -- Control C Processing'
ROUTINE vs$$do_control_c(
			vkb_adr: REF vkb_block	!VKB address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for control-C processing. All echoing is
! done at a higher level. This routine will determine if there are any
! AST enables.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	This routine runs in kernel mode.
!
!--
BEGIN

LOCAL
	ucb_adr: REF vd_ucb_block,		!Unit Control Block address
	irp_adr: REF irp_block,			!I/O request packet address
	rr_adr: REF vkb_read_request;		!Read context for this VKB
!
! See if we have any Control-C AST's to deliver (only VKBs with output devices)
!
	IF .vkb_adr[vs$vkb_l_vd_id] EQL 0 THEN
	  vs$$do_control_y(.vkb_adr)
	ELSE
	  BEGIN
	    ucb_adr = .vs$al_vd_ucb[.vkb_adr[vs$vkb_l_vd_id]];
	    IF .ucb_adr[UCB$L_TL_CTRLC] NEQ 0 THEN
	      BEGIN
	        vs$$acp_delattnast(ucb_adr[UCB$L_TL_CTRLC],
			   .ucb_adr);
	      END
	    ELSE
	      vs$$do_control_y(.vkb_adr);
	  END;
!
! COMMENTED OUT UNTIL VKB AST DELIVERY FINALIZED ***
!
!	IF .vkb_adr[vs$vkb_a_control_c_ast] NEQ 0 THEN
!	  BEGIN
!	    IF .vkb_adr[vs$vkb_v_read] THEN
!	      BEGIN
!		rr_adr = .vkb_adr[vs$vkb_a_current_read];
!		irp_adr = .rr_adr[vs$rr_a_irp];
!		com$delattnast(.vkb_adr[vs$vkb_a_control_c_ast],
!			   .irp_adr[IRP$L_UCB]);
!	      END
!	    ELSE
!	      com$delattnast(.vkb_adr[vs$vkb_a_control_c_ast],
!			   .vs$gl_template_ucb);
!	    vs$$control_y_handler(.vkb_adr);
!	  END
!
!
	RETURN;			!return success
END;				! of routine vs$$do_control_c


%SBTTL 'vs$$do_control_y -- Control Y Processing'
ROUTINE vs$$do_control_y(
			vkb_adr: REF vkb_block	!VKB address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for control-Y processing. All echoing is
! done at a higher level. This routine will determine if there are any
! AST enables.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	This routine runs in kernel mode.
!
!--
BEGIN

LOCAL
	ucb_adr: REF vd_ucb_block,		!Unit Control Block address
	irp_adr: REF irp_block,			!I/O request packet address
	rr_adr: REF vkb_read_request;		!Read context for this VKB
!
! See if we have any Control-Y AST's to deliver (only VKBs with output devices)
!
	IF .vkb_adr[vs$vkb_l_vd_id] NEQ 0 THEN
	  BEGIN
	    ucb_adr = .vs$al_vd_ucb[.vkb_adr[vs$vkb_l_vd_id]];
	    IF .ucb_adr[UCB$L_TL_CTRLY] NEQ 0 THEN
	      BEGIN
	        vs$$acp_delattnast(ucb_adr[UCB$L_TL_CTRLY],
			   .ucb_adr);
	      END;
	  END;
!
! COMMENTED OUT UNTIL VKB AST DELIVERY FINALIZED ***
!
!	IF .vkb_adr[vs$vkb_a_control_y_ast] NEQ 0 THEN
!	  BEGIN
!	    IF .vkb_adr[vs$vkb_v_read] THEN
!	      BEGIN
!		rr_adr = .vkb_adr[vs$vkb_a_current_read];
!		irp_adr = .rr_adr[vs$rr_a_irp];
!		com$delattnast(.vkb_adr[vs$vkb_a_control_y_ast],
!			   .irp_adr[IRP$L_UCB]);
!	      END
!	    ELSE
!	      com$delattnast(.vkb_adr[vs$vkb_a_control_y_ast],
!			   .vs$gl_template_ucb);
!	  END;
!
	vs$$control_y_handler(.vkb_adr);
!
	RETURN;			!return success
END;				! of routine vs$$do_control_y


%SBTTL 'vs$$control_y_handler -- Control Y Handler'
ROUTINE vs$$control_y_handler(
			vkb_adr: REF vkb_block	!VKB address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for the bulk of control-Y processing.
! This routine will signal, via an AST, the holder of any AST enables. If
! none are enabled, then an attempt to signal the job controller is made.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

!
! Cancel all I/O operations to this device (Read done automatically),
! purge the typeahead buffer, and cancel any hold-screen attributes
!
	vs$$purge_typeahead(.vkb_adr,
			    .vkb_adr[vs$vkb_l_unsolicit_ptr]);
!
! Cancel control-O and control-S
!
	IF .vkb_adr[vs$vkb_l_vd_id] NEQ 0 THEN
	  vsta$$odrv_control_o(
			.vkb_adr[vs$vkb_l_vd_id],
			false);
!
	vs$$cancel_control_s(.vkb_adr);
!
	RETURN;			!return success
END;				! of routine vs$$control_y_handler


%SBTTL 'vs$$do_control_o -- Control O Processing'
ROUTINE vs$$do_control_o(
			vkb_adr: REF vkb_block	!VKB address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for control-O processing. All echoing is
! done at a higher level. This routine will toggle output to the virtual
! display which corresponds to this virtual keyboard by setting and clearing
! the control_o bit in the VKB for this output device. Output is stopped until
! the next read operation, IO$_WRTCANCTRLO, or control-O is typed.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	control_o_status;			!Current status of control-O
!
! If there is an active read, then ignore
!
	IF .vkb_adr[vs$vkb_v_read] THEN
	  RETURN;
!
! Address the output device for this VKB and if non-existent, return
!
	IF .vkb_adr[vs$vkb_l_vd_id] EQL 0 THEN
	  RETURN;
!
! Toggle the control_o bit in the output device state to have future output
! either restarted or discarded
!
	control_o_status = vsta$$odrv_control_o(.vkb_adr[vs$vkb_l_vd_id]);
!
	CASE .control_o_status FROM false TO true OF
	  SET
	    [false] : BEGIN
			vs$$echo_character(
					.vkb_adr,
					UPLIT WORD(control_o));
			vs$$post_ast_request_hipq(
					vsta$$odrv_control_o,
					.vkb_adr[vs$vkb_l_vd_id],
					true);
		      END;
	    [true]  : BEGIN
			vsta$$odrv_control_o(
					.vkb_adr[vs$vkb_l_vd_id],
					false);
			vs$$cancel_control_s(.vkb_adr);
			vs$$echo_character(
					.vkb_adr,
					UPLIT WORD(control_o));
		      END;
	  TES;
!
! Now that the action has been performed, remove traces of the character
!
	vsta$$kernel_call(
			vs$$delete_typeahead,
			.vkb_adr);
!
	RETURN;			!return success
END;				! of routine vs$$do_control_o


%SBTTL 'vs$$do_control_q -- Control Q Processing'
ROUTINE vs$$do_control_q(
			vkb_adr: REF vkb_block	!VKB address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for control-Q processing. All echoing is
! done at a higher level. This routine will start output to the virtual display
! which corresponds to this virtual keyboard by setting the interrupt enable
! bit in the UCB for this device (if TT$_NOTTSYNC is not set) if it was
! previously clear.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

!
! Cancel control-s if enabled and the terminal has TT$M_TTSYNC set.
!
	IF ((.vkb_adr[vs$vkb_l_char] AND TT$M_TTSYNC) NEQ 0) OR
	   ((.vkb_adr[vs$vkb_l_char] AND TT$M_HOSTSYNC) NEQ 0) OR
	   ((.vkb_adr[vs$vkb_l_char] AND TT$M_READSYNC) NEQ 0) THEN
	  vs$$cancel_control_s(.vkb_adr);
!
! Now that the action has been performed, remove traces of the character
! (if it was typed unsolicited)
!
	IF NOT .vkb_adr[vs$vkb_v_read] THEN
	  vsta$$kernel_call(
			vs$$delete_typeahead,
			.vkb_adr);
!
	RETURN;			!return success
END;				! of routine vs$$do_control_q


%SBTTL 'vs$$do_control_r -- Control R Processing'
ROUTINE vs$$do_control_r(
			vkb_adr: REF vkb_block	!VKB address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for control-R processing. All echoing is
! done at a higher level. This routine will cause the current line to be
! redisplayed.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	arg_list: VECTOR[4],			!$CMKRNL argument block
	rr_adr: REF vkb_read_request,		!Current VKB read context
	prompt_adr: REF VECTOR[0,BYTE],		!Prompt string
	prompt_length,				!Length of prompt minus LF
	str_length,				!Length of string to redisplay
	string: REF VECTOR[0,BYTE];		!String address to redisplay

!
! If there is no active read, then wait until there is one to do anything
!
	IF NOT .vkb_adr[vs$vkb_v_read] THEN
	  RETURN;
!
! If there is no output stream defined for this VKB, this is a no-op
!
	IF (.vkb_adr[vs$vkb_l_vd_id] EQL 0) THEN
	  RETURN;
!
! Compute the length of the string and allocate a temporary buffer for it
!
	rr_adr = .vkb_adr[vs$vkb_a_current_read];
!
	prompt_adr = .rr_adr[vs$rr_a_prompt_string];
	IF .prompt_adr[0] EQL line_feed THEN
	  BEGIN
	    prompt_length = MAX(0,.rr_adr[vs$rr_l_prompt_length] - 1);
	    prompt_adr = .prompt_adr + 1;
	  END
	ELSE
	  IF (.prompt_adr[0] EQL carriage_return) AND
	     (.prompt_adr[1] EQL line_feed) THEN
	    BEGIN
	      prompt_length = MAX(0,.rr_adr[vs$rr_l_prompt_length] - 2);
	      prompt_adr = .prompt_adr + 2;
	    END
	  ELSE
	    prompt_length = .rr_adr[vs$rr_l_prompt_length];
!
	str_length = 2 + .prompt_length + .rr_adr[vs$rr_l_buffer_ptr];
!
	IF NOT (vs$$acp_get_vm (%REF(.str_length),
				string)) THEN
	  RETURN;
!
! Create the text to be output
!
	string[0] = carriage_return;
	string[1] = line_feed;
!
	IF .prompt_length GTR 0 THEN
	  CH$MOVE(
		.prompt_length,
		.prompt_adr,
		string[2]);
!
	IF .rr_adr[vs$rr_l_buffer_ptr] GTR 0 THEN
	  BEGIN
	    arg_list[0] = 3;
	    arg_list[1] = .rr_adr[vs$rr_l_buffer_ptr];
	    arg_list[2] = .rr_adr[vs$rr_a_buffer];
	    arg_list[3] = string[2 + .prompt_length];
	    $CMKRNL(
		ROUTIN = vs$$kmode_move,
		ARGLST = arg_list);
	  END;
!
! Now output the string
!
	vs$$vds_synchronize_echo(
			.vkb_adr[vs$vkb_l_vd_id],
			.vkb_adr[vs$vkb_a_echo_routine],
			.string,
			.str_length);
!
! Free the temporary storage for the output string
!
	vs$$acp_free_vm ( %REF(.str_length),
			string);
!
	RETURN;			!return success
END;				! of routine vs$$do_control_r


%SBTTL 'vs$$do_control_s -- Control S Processing'
ROUTINE vs$$do_control_s(
			vkb_adr: REF vkb_block	!VKB address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for control-S processing. All echoing is
! done at a higher level. This routine will stop output to the virtual display
! which corresponds to this virtual keyboard by clearing the interrupt enable
! bit in the UCB for this device (if TT$_NOTTSYNC is not set).
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LITERAL
	xon  = 0,			!Turn output on
	xoff = 1;			!Turn output off

!
! Stop the output...Stop the output (if we're allowed)
!
	IF ((.vkb_adr[vs$vkb_l_char] AND TT$M_TTSYNC) NEQ 0) OR
	   ((.vkb_adr[vs$vkb_l_char] AND TT$M_HOSTSYNC) NEQ 0) OR
	   ((.vkb_adr[vs$vkb_l_char] AND TT$M_READSYNC) NEQ 0) THEN
	  BEGIN
	    vs$$vds_vd_set_xon_xoff(
				.vkb_adr[vs$vkb_l_vd_id],
				xoff);
	  END;
!
! Now that the action has been performed, remove traces of the character
! (if it was typed unsolicited)
!
	IF NOT .vkb_adr[vs$vkb_v_read] THEN
	  vsta$$kernel_call(
			vs$$delete_typeahead,
			.vkb_adr);
!
	RETURN;			!return success
END;				! of routine vs$$do_control_s


%SBTTL 'vs$$do_control_u -- Control U Processing'
ROUTINE vs$$do_control_u(
			vkb_adr: REF vkb_block	!VKB address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for control-U processing. All echoing is
! done at a higher level. This routine will purge the typeahead buffer.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	rr_adr: REF vkb_read_request;		!Current VKB read context
!
! Purge the user's buffer if there is an active, non-passall-type read on it
!
	IF NOT .vkb_adr[vs$vkb_v_read] THEN
	  RETURN;
!
	rr_adr = .vkb_adr[vs$vkb_a_current_read];
	IF (.rr_adr[vs$rr_l_full_function] AND IO$M_NOFILTR) NEQ 0 THEN
	  RETURN;
!
	vs$$echo_character(
			.vkb_adr,
			UPLIT WORD(control_u));
!
	vs$$purge_user_buffer(.vkb_adr[vs$vkb_a_current_read]);
!
! Redisplay prompt string (if any) if there is an output device associated
! with this virtual keyboard
!
	vs$$do_control_r(.vkb_adr);
!
	RETURN;			!return success
END;				! of routine vs$$do_control_u


%SBTTL 'vs$$do_control_x -- Control X Processing'
ROUTINE vs$$do_control_x(
			vkb_adr: REF vkb_block	!VKB address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for control-X processing. All echoing is
! done at a higher level. This routine will purge the typeahead buffer.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	arg_list: VECTOR[3];			!$CMKRNL argument block

!
! Purge the typeahead buffer and perform a Control U.
!
	arg_list[0] = 2;
	arg_list[1] = .vkb_adr;
	arg_list[2] = .vkb_adr[vs$vkb_l_unsolicit_ptr];
	$CMKRNL(
		ROUTIN = vs$$purge_typeahead,
		ARGLST = arg_list);
!
! If there is a read active, then a control_u is in order
!
!	vs$$do_control_u(.vkb_adr);
!
	RETURN;			!return success
END;				! of routine vs$$do_control_x


%SBTTL 'vs$$do_out_of_band -- Out-of-Band Processing'
ROUTINE vs$$do_out_of_band(
			vkb_adr: REF vkb_block,		!VKB address
			control_char,			!Control character
			include_char: REF VECTOR[0,BYTE]!Include character
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for out-of-band processing. All echoing is
! done at a higher level. This routine will determine if any AST's are enabled
! for specified control character and initiate them if so.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!	CONTROL_CHAR  : Byte control character to be processed
!			(input parameter)
!	INCLUDE_CHAR  : Address of byte character code to be included as input
!			(output parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
! COMPLETION CODES:
!
!	TRUE  (=1) : Out-of-band AST delivered on character input
!	FALSE (=0) : NO out-of-band AST delivered on character
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

MACRO
	vs$v_include = 0,15,1,0 %;		!Character to be included flag
LOCAL
	input_char: vkb_ascii_word,		!The data stream character
	ucb_adr: REF vd_ucb_block,		!Unit Control Block address
	irp_adr: REF irp_block,			!I/O request packet address
	rr_adr: REF vkb_read_request,		!Read context for this VKB
	out_of_band: REF BITVECTOR;		!Out-of-band char. mask

!
! VKBs without associated output devices (emulators) do not get out-of-band
! ASTs.
!
	include_char[0] = 0;
	IF .vkb_adr[vs$vkb_l_vd_id] EQL 0 THEN
	  RETURN false;
!
! See if we have any Out-of-band AST's to deliver for this character
!
	ucb_adr = .vs$al_vd_ucb[.vkb_adr[vs$vkb_l_vd_id]];
	out_of_band = ucb_adr[UCB$L_TL_OUTBAND];
!
	IF (.out_of_band[.control_char]) THEN
	  BEGIN
	    vs$$acp_delctrlast(
			.control_char,
			ucb_adr[UCB$L_TL_BANDQUE],
			.ucb_adr,
			input_char);
!
! We delivered the out-of-band ASTs -- Now if bit 15 is
! set in input_char by com$delctrlast, this means that the low byte is to be
! included in the input stream. Otherwise, it implies immediate action only
! and if no read is active, deleted from the typeahead buffer.
!
	    IF .input_char[vs$v_include] THEN
	      include_char[0] = .input_char[vs$aw_b_char_code]
	    ELSE
	      BEGIN
		IF NOT .vkb_adr[vs$vkb_v_read] THEN
		  vs$$delete_typeahead(.vkb_adr);
	      END;
!
	    RETURN true;		!Out-of-band ASTs were delivered
	  END;
!
! COMMENTED OUT UNTIL VKB AST DELIVERY FINALIZED ***
!
!	out_of_band = vkb_adr[vs$vkb_l_out_of_band_mask];
!
!	IF .out_of_band[.control_char] EQL true THEN
!	  IF .vkb_adr[vs$vkb_a_out_of_band_ast] NEQ 0 THEN
!	    BEGIN
!	      IF .vkb_adr[vs$vkb_v_read] THEN
!		BEGIN
!	          rr_adr = .vkb_adr[vs$vkb_a_current_read];
!	          irp_adr = .rr_adr[vs$rr_a_irp];
!	          com$delattnast(.vkb_adr[vs$vkb_a_out_of_band_ast],
!			   .irp_adr[IRP$L_UCB]);
!		END
!	      ELSE
!	        com$delattnast(.vkb_adr[vs$vkb_a_out_of_band_ast],
!			   .vs$gl_template_ucb);
!	    END;
!
	RETURN false;		!return "not-delivered" indication
END;				! of routine vs$$do_out_of_band


%SBTTL 'vs$$do_delete -- Delete Character Processing'
ROUTINE vs$$do_delete(
			vkb_adr: REF vkb_block	!VKB block address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for deleting the previous character in
! the input stream. It is only the responsibility of this routine to modify
! the user's buffer. It is the responsibility of the emulator's echo routine
! to cause the previously displayed character to be erased.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	arg_list: VECTOR[2],			!$CMKRNL argument block
	control_r_flag: INITIAL(false),		!Do control_r indicator
	rr_adr: REF vkb_read_request;		!Current VKB read context

!
! If there is no active read on this VKB, don't process the delete
!
	IF NOT .vkb_adr[vs$vkb_v_read] THEN
	  RETURN;
!
	rr_adr = .vkb_adr[vs$vkb_a_current_read];
!
! If currently processing an escape sequence, the entire thing
! must be deleted (nothing will be on the screen anyway).
!
	IF .vkb_adr[vs$vkb_l_escape_state] NEQ vkb$k_not_doing_escape THEN
	  BEGIN
	    arg_list[0] = 1;
	    arg_list[1] = .rr_adr;
	    $CMKRNL(
		ARGLST = arg_list[0],
		ROUTIN = vs$$delete_escape);
	    RETURN;
	  END;
!
! If there is an output stream defined for this VKB and this is a read
! with echo and we have anything in the read buffer to delete then
! output the string to delete the character
!
	IF (.vkb_adr[vs$vkb_l_vd_id] NEQ 0) AND
	  ((.vkb_adr[vs$vkb_l_char] AND TT$M_NOECHO) EQL 0) AND
	  ((.rr_adr[vs$rr_l_full_function] AND IO$M_NOECHO) EQL 0) AND
	   (.rr_adr[vs$rr_l_buffer_ptr] GTR 0) THEN
		vsta$$odrv_delete_last_char(
			.vkb_adr[vs$vkb_l_vd_id],
			.rr_adr[vs$rr_w_cursor_start],
			.rr_adr[vs$rr_a_buffer],
			.rr_adr[vs$rr_l_buffer_ptr],
			.vkb_adr[vs$vkb_a_echo_routine],
			control_r_flag);
!
! Adjust the pointer into the user's buffer (which effectively deletes the
! last character put into the read buffer)
!
	rr_adr[vs$rr_l_buffer_ptr] =
	    MAX(0,.rr_adr[vs$rr_l_buffer_ptr] - .rr_adr[vs$rr_b_buffer_inc]);
!
! If the control_r flag was set above, then do it to refresh the current line
!
	IF .control_r_flag THEN
	  vs$$do_control_r(.vkb_adr);
!
	RETURN;			!return success
END;				! of routine vs$$do_delete


%SBTTL 'vs$$delete_escape -- Delete Escape Sequence Processing'
ROUTINE vs$$delete_escape(
			rr_adr: REF vkb_read_request
					! Read reqest block adr.
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for deleting the escape sequence which is
! in progress on the specified VKB. The characters back to the initial escape
! are deleted and the state reset.
!
! FORMAL PARAMETERS:
!
!	RR_ADR	      : Address of current read request Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	found: INITIAL(false),			!"Boolean" esc-found indicator
	read_buffer: REF VECTOR[0,BYTE];	!Read buffer
!
	read_buffer = .rr_adr[vs$rr_a_buffer];
!
! Decrement the current read buffer pointer until we discover the escape which
! started the escape sequence
!
	WHILE (.rr_adr[vs$rr_l_buffer_ptr] GTR 0) AND
	      (NOT .found) DO
	  BEGIN
	    rr_adr[vs$rr_l_buffer_ptr] = .rr_adr[vs$rr_l_buffer_ptr] - 1;
	    IF .read_buffer[.rr_adr[vs$rr_l_buffer_ptr]] EQL escape THEN
	      found = true;
	  END;
!
	RETURN;			!return success
END;				! of routine vs$$delete_escape


%SBTTL 'vs$$cancel_control_s -- Cancel Control S Processing'
ROUTINE vs$$cancel_control_s(
			vkb_adr: REF vkb_block	!VKB address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for control-S cancelation processing.
! This routine will start output to the virtual display which corresponds
! to this virtual keyboard by clearing the interrupt enable bit in the UCB
! for this device (if TT$_NOTTSYNC is not set).
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LITERAL
	xon  = 0,			!Turn output on
	xoff = 1;			!Turn output off

!
! Start the output (if we're allowed)
!
	IF ((.vkb_adr[vs$vkb_l_char] AND TT$M_TTSYNC) NEQ 0) OR
	   ((.vkb_adr[vs$vkb_l_char] AND TT$M_HOSTSYNC) NEQ 0) OR
	   ((.vkb_adr[vs$vkb_l_char] AND TT$M_READSYNC) NEQ 0) THEN
	  BEGIN
	    vs$$vds_vd_set_xon_xoff(
				.vkb_adr[vs$vkb_l_vd_id],
				xon);
	    $WAKE();
	  END;
!
	RETURN;			!return success
END;				! of routine vs$$cancel_control_s


%SBTTL 'vs$$display_prompt -- Display Prompt String'
ROUTINE vs$$display_prompt(
			vkb_adr: REF vkb_block		!VKB address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for displaying the prompt string (as is)
! on a read with prompt operation when there is an output device associated
! with the virtual keyboard. This routine assumes that it is alright to display
! the prompt string (i.e. the modes and states of the output device permit it).
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	rr_adr: REF vkb_read_request;		!Current VKB read context

!
! If there is no output stream defined for this VKB, this is a no-op
!
	IF (.vkb_adr[vs$vkb_a_echo_routine] EQL 0) THEN
	  RETURN;
!
! If there is no prompt string to output, just return
!
	rr_adr = .vkb_adr[vs$vkb_a_current_read];
	IF .rr_adr[vs$rr_l_prompt_length] LEQ 0 THEN
	  RETURN;
!
! Now output the string
!
	vs$$vds_synchronize_echo(
			.vkb_adr[vs$vkb_l_vd_id],
			.vkb_adr[vs$vkb_a_echo_routine],
			.rr_adr[vs$rr_a_prompt_string],
			.rr_adr[vs$rr_l_prompt_length]);
!
	RETURN;			!return success
END;				! of routine vs$$display_prompt


%SBTTL 'vs$$echo_character -- Character Echo Processing'
ROUTINE vs$$echo_character(
			vkb_adr: REF vkb_block,		!Virtual Keyboard addr.
			echo_word: REF vkb_ascii_word	!ASCII word to echo
					): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for echoing the ascii character specified
! if the modes and states of the specified virtual keyboard allow it and an
! emulator echo routine exists.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard block
!			(input parameter)
!	ECHO_WORD     : Address of ascii word generated for echo
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	echo_length,				!Echo string length
	echo_string: VECTOR[2,BYTE] INITIAL(BYTE(0,backspace)),
	rr_adr: REF vkb_read_request,		!Current VKB read context
	passall: INITIAL(false),		!Passall mode? (Boolean)
	status;					!To contain return status value

!
! If echo routine address for this virtual keyboard is zero or the keyboard
! is in noecho mode or there is a read active either with noecho or termnoecho
! and the character is a terminator, return
!
	IF (.vkb_adr[vs$vkb_a_echo_routine] EQL 0) THEN
	  RETURN;
	IF (.vkb_adr[vs$vkb_l_char] AND TT$M_NOECHO) NEQ 0 THEN
	  RETURN;
	IF .vkb_adr[vs$vkb_v_read] THEN
	  BEGIN
	    rr_adr = .vkb_adr[vs$vkb_a_current_read];
	    IF (.rr_adr[vs$rr_l_read_all]) OR
	      ((.rr_adr[vs$rr_l_full_function] AND IO$M_NOFILTR) NEQ 0) THEN
	      passall = true;
	    IF (.rr_adr[vs$rr_l_full_function] AND IO$M_NOECHO) NEQ 0 THEN
	      RETURN;
	    IF .rr_adr[vs$rr_w_terminator] NEQ 0 THEN
	      IF (.rr_adr[vs$rr_l_full_function] AND IO$M_TRMNOECHO) NEQ 0 THEN
		RETURN;
	  END;
!
! Compute echo string and length based on whether or not this is a dead key
!
	echo_length = 1;
	echo_string[0] = .echo_word[vs$aw_b_char_code];
	IF (.echo_word[vs$aw_v_dead]) THEN
	  echo_length = 2;
!
! Echoing is different for passall. So if passall, send this character directly
! to the output device (emulator) without interpretation.
!
	IF (.passall) OR
	  ((.vkb_adr[vs$vkb_l_char] AND TT$M_PASSALL) NEQ 0) THEN
	  BEGIN
	    vs$$vds_synchronize_echo(
				.vkb_adr[vs$vkb_l_vd_id],
				.vkb_adr[vs$vkb_a_echo_routine],
				echo_string,
				.echo_length);
	    RETURN;
	  END;
!
! The virtual keyboard state allows it, call specified echo routine after
! converting certain control characters into their corresponding text strings
!
	CASE .echo_word[vs$aw_b_char_code] FROM control_c TO escape OF
	  SET
	      [control_c] : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					UPLIT BYTE(carriage_return,line_feed,
					%C'^',%C'Y',
					line_feed,carriage_return),
					6);
	      [carriage_return] : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					UPLIT BYTE(carriage_return,line_feed),
					2);
	      [control_o] : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					UPLIT BYTE(carriage_return,line_feed,
					%C'^',%C'O',%C'.',%C'.',%C'.',
					line_feed,carriage_return),
					9);
	      [control_r] : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					UPLIT BYTE('^R'),
					2);
	      [control_u] : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					UPLIT BYTE('^U'),
					2);
	      [control_x] : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					UPLIT BYTE('^U'),
					2);
	      [control_y] : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					UPLIT BYTE(carriage_return,line_feed,
						%C'^',%C'Y',
						line_feed,carriage_return),
					6);
	      [control_z] : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					UPLIT BYTE(%C'^',%C'Z',
					carriage_return,line_feed),
					4);
	      [escape]    : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					UPLIT BYTE('$'),
					1);
	      [INRANGE]   : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					echo_string,
					.echo_length);
	      [OUTRANGE]  : SELECTONE .echo_word[vs$aw_b_char_code] OF
			      SET
				[ss3] : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					UPLIT BYTE('$O'),
					2);
				[csi] : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					UPLIT BYTE('$['),
					2);
				[OTHERWISE] : vs$$vds_synchronize_echo(
					.vkb_adr[vs$vkb_l_vd_id],
					.vkb_adr[vs$vkb_a_echo_routine],
					echo_string,
					.echo_length);

			      TES;
	  TES;
!
	RETURN;			!return success
END;				! of routine vs$$echo_character


%SBTTL 'vs$$purge_typeahead -- Purge the Typeahead Buffer of a Virtual Keyboard'
ROUTINE vs$$purge_typeahead(
			vkb_adr: REF vkb_block,		!VKB addr.
			up_to_ptr			!Purge up to where?
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for purging the typeahead buffer of a
! particular virtual keyboard. This routine assumes that the buffer address
! passed as a parameter is the proper format.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!			(input parameter)
!	UP_TO_PTR     : Longword new head pointer for ring buffer (if known)
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	rb_adr: REF VECTOR[0,WORD];		!Ring buffer address

	rb_adr = .vkb_adr[vs$vkb_a_ring_buffer];
!
! Just reset the head and tail pointers of the ring buffer. Don't bother
! deleting anything.
!
	IF .up_to_ptr LSS 0 THEN
	  rb_adr[0] = .rb_adr[1]
	ELSE
	  rb_adr[0] = .up_to_ptr;
!
	vkb_adr[vs$vkb_l_unsolicit_ptr] = .rb_adr[0];
	vkb_adr[vs$vkb_l_gen_index] = -1;
!
	RETURN;			!return
END;				! of routine vs$$purge_typeahead


%SBTTL 'vs$$purge_user_buffer -- Purge the User Buffer'
ROUTINE vs$$purge_user_buffer(
			rr_adr: REF vkb_read_request
					! VKB read context
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for purging the user's buffer for a
! particular read request. This routine assumes that the buffer address
! passed as a parameter is the proper format.
!
! FORMAL PARAMETERS:
!
!	RR_ADR	      : Address of Virtual Keyboard current read Block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

!
! Reset the pointer into the user buffer
!
	rr_adr[vs$rr_l_buffer_ptr] = 0;
!
	RETURN;			!return
END;				! of routine vs$$purge_user_buffer


%SBTTL 'vs$$do_unsolicited -- Process Unsolicited Input'
ROUTINE vs$$do_unsolicited(
			vkb_adr: REF vkb_block	!VKB address
					): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for processing unsolicited input
! indicated by delivery of an AST as a result of a character being typed
! into an active VKB where no read was outstanding. This routine will perform
! any immediate action which must take place with certain special characters.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR		: Address of Virtual Keyboard block
!				(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	status,					!Return status value
	action_only,				!"Boolean" action-only char.
	echoed,					!"Boolean" echoed indicator
	encoded_char,				!Encoded character store
	arg_list: VECTOR[3],			!Arg block to get_encoded_char
	mystery_flag,				!To continue scan or not
	ascii_word: vkb_ascii_word;		!Ascii translation of code

!
! label to get out of pass off loop 
!
LABEL
	this_pass;

!
! Loop until there are no more characters in typeahead
!
	mystery_flag = 1;

	WHILE .mystery_flag EQL 1
	DO 


	this_pass: 		! Label the inside of loop

	BEGIN			! Begin loop processing

!
! Get the next unsolicited input character
!
	arg_list[0] = 2;
	arg_list[1] = encoded_char;
	arg_list[2] = .vkb_adr;
!
	IF (NOT (mystery_flag = $CMKRNL(
			ROUTIN = vs$$preview_typeahead,
			ARGLST = arg_list))) THEN
	  RETURN;
!
! If this was an upstroke, then we've seen enough for now
! Make sure you use ..arg_list [1] insted of .encoded_char because
! compiler will optimize out the condition generation.
!
	IF (..arg_list [1] AND vb$m_char_tran) EQL 0 THEN
	LEAVE this_pass;
!
! If this character code is owned by the human interface (i.e. gets out-of-band
! action from the human interface instead of normal characters processing),
! then perform the appropriate action
!
	IF vs$$vkb_hi_key(.vkb_adr,.encoded_char) THEN
	LEAVE this_pass;
!
! If the VKB is unencoded, then just leave it where it is
!
	IF .vkb_adr[vs$vkb_l_trans_table] EQL vsta$k_tt_unencoded THEN
	LEAVE this_pass;
!
! Translate the character code into ascii as future processing will depend
! on the ascii codes (ignore dead keys).
!
	IF NOT vsta$$vkb_encoder(
				.encoded_char,
				.vkb_adr[vs$vkb_b_dead],
				.vkb_adr[vs$vkb_l_trans_table],
				.vkb_adr,
				ascii_word,
				vkb_adr[vs$vkb_b_dead]) THEN
	LEAVE this_pass;
!
! If this character warrants an unsolicited mailbox message then send it away.
! Also update the UCB fields for unsolicited input available.
!
	arg_list[0] = 2;
	arg_list[1] = ascii_word;
	arg_list[2] = .vkb_adr;
!
	$CMKRNL(
		ROUTIN = vs$$send_mbx_msg,
		ARGLST = arg_list);
!
! If the program defined special character bit is set, no interpretation
! should be performed
!
	IF (.vkb_adr[vs$vkb_l_char] AND TT$M_PASSALL) NEQ 0 THEN
	LEAVE this_pass;
!
	IF .ascii_word[vs$aw_v_special] THEN
	LEAVE this_pass;
!
! Strip off the eighth bit of this character if not TT$M_EIGHTBIT and
! an emulator is present
!
! *************** Let all Eight bits through for now ****************
!
!	IF .vkb_adr[vs$vkb_l_vd_id] NEQ 0 THEN
!	  IF (.vkb_adr[vs$vkb_l_char] AND TT$M_EIGHTBIT) EQL 0 THEN
!	    ascii_word[vs$aw_b_char_code] =
!			.ascii_word[vs$aw_b_char_code] AND %X'7f';

!
! Special character requires special processing if specified in the VKB
! break table
!
	vs$$special_char(
			.vkb_adr,
			ascii_word,
			action_only,
			echoed);
!
	END;			! Of inside of labeled task

END;				! of routine vs$$do_unsolicited


%SBTTL 'vs$$read_satisfied -- Try to Satisfy Request with Typeahead'
ROUTINE vs$$read_satisfied(
			vkb_adr: REF vkb_block,		!VKB address
			read_status			!Read status address
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for attempting to satisfy the read
! request given the current contents of the typeahead buffer. While
! attempting to satisfy the request, the characters encountered will be
! echoed (using the appropriate emulator routine) and stuffed into the user's
! buffer while maintaining its count. All appropriate character translation
! is also performed here before the echo routine sees the character and
! whether or not the routine is called at all depends upon the state of the
! virtual keyboard being read.
!	VDDRIVER is informed when a read is in progress so that no write
! operations will be permitted in half-duplex.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR		: Address of Virtual Keyboard block
!				(input parameter)
!	READ_STATUS	: Address to contain read status (word)
!				(output parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	true (= 1)	=> Typeahead buffer satisfied read request
!	false (= 0)	=> Typeahead buffer DID NOT satisfy read request
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	status,					!Return status value
	satisfied,				!"Boolean" search criteria
	encoded_char,				!Encoded character store
	arg_list: VECTOR[3],			!Arg block to get_encoded_char
	ascii_word: WORD;			!Ascii translation of code

!
	.read_status = SS$_NORMAL;
!
! Loop until either read satisfied or no characters left in typeahead buffer
! or emulator input buffer
!
	encoded_char = -1;
	satisfied = false;
!
	arg_list[0] = 2;
	arg_list[1] = encoded_char;
	arg_list[2] = .vkb_adr;
!
	WHILE (NOT .satisfied) DO
	  BEGIN
	    WHILE (NOT .satisfied) AND 
		  (vs$$char_available(
				.vkb_adr,
				.encoded_char,
				ascii_word)) DO
	      BEGIN
!
! We have an ascii character -- Process it
!
		satisfied = vs$$process_char(
					.vkb_adr,
					ascii_word,
					.read_status);
		encoded_char = -1;
	      END;		!While emulator characters available
!
! If the read is still not satisfied, get the next character out of the
! typeahead buffer
!
	    IF NOT .satisfied THEN
	      IF NOT $CMKRNL(
			ROUTIN = vs$$get_encoded_char,
			ARGLST = arg_list) THEN
		RETURN .satisfied;
	  END;			!While read not satisfied + still characters
!
	RETURN .satisfied;	!return whether or not satisfied
END;				! of routine vs$$read_satisfied


%SBTTL 'vs$$process_char -- Process the Next Character'
ROUTINE vs$$process_char(
			vkb_adr: REF vkb_block,		!VKB address
			ascii_word: REF vkb_ascii_word,	!ASCII char. to process
			read_status			!Read status address
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for attempting to satisfy the read and
! any special processing required for the character passed as a parameter.
! While attempting to satisfy the request, the characters encountered will be
! echoed (using the appropriate emulator routine) and stuffed into the user's
! buffer while maintaining its count.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR		: Address of Virtual Keyboard block
!				(input parameter)
!	ASCII_WORD	: Address of WORD ascii character to be processed
!				(input parameter)
!	READ_STATUS	: Address to contain read status (word)
!				(output parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	true (= 1)	=> Satisfied read request
!	false (= 0)	=> DID NOT satisfy read request
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	status,					!Return status value
	satisfied,				!"Boolean" EOR indicator
	term_flag,				!"Boolean" terminator flag
	action_only,				!"Boolean" action-only char.
	esc_sequence,				!"Boolean" esc sequence flag
	echoed,					!"Boolean" char. echoed flag
	rr_adr: REF vkb_read_request,		!Current VKB read context
	mchar_list: VECTOR[4];			!Arg block to kmode_move

!
! Initialize the read context and return value
!
	action_only = esc_sequence = satisfied = false;
	rr_adr = .vkb_adr[vs$vkb_a_current_read];
!
! If the keyboard translation table for this VKB is not unencoded then
! apply device modes and states to it
!
	IF .vkb_adr[vs$vkb_l_trans_table] NEQ vsta$k_tt_unencoded THEN
	  BEGIN
!
! Strip off the eighth bit of this character if not TT$M_EIGHTBIT,
! not in TT$M_PASSALL, and not unencoded (for now strip it off if
! in sevenbit transmission mode and conforming to level 1).
!
!	        IF (.vkb_adr[vs$vkb_l_char] AND 
!	           (TT$M_EIGHTBIT OR TT$M_PASSALL)) EQL 0 THEN
!
		IF NOT .vkb_adr[vs$vkb_v_eightbit] THEN
		  IF .vkb_adr[vs$vkb_v_level] EQL vkb$k_level_1 THEN
	            ascii_word[vs$aw_b_char_code] = 
			.ascii_word[vs$aw_b_char_code] AND %X'7f';

!
! Satisfy the hackers that use ALTMODE by converting it to an escape when
! TT$M_LOWER is not set
!
	        IF (.vkb_adr[vs$vkb_l_char] AND TT$M_LOWER) EQL 0 THEN
	          IF (.ascii_word[vs$aw_b_char_code] EQL altmode_1) OR
		     (.ascii_word[vs$aw_b_char_code] EQL altmode_2) THEN
		    ascii_word[vs$aw_b_char_code] = escape;
!
! If we're not doing a passall-type read, then some conversions may be in order
!
		IF (NOT .rr_adr[vs$rr_l_read_all]) AND
	          ((.vkb_adr[vs$vkb_l_char] AND TT$M_PASSALL) EQL 0) THEN
		  BEGIN
!
! Convert the character to uppercase if applicable
!
		    IF (.rr_adr[vs$rr_l_full_function] AND IO$M_CVTLOW) NEQ 0
		    THEN
		      IF (.ascii_word[vs$aw_b_char_code] GEQ %C'a') AND
	                 (.ascii_word[vs$aw_b_char_code] LEQ %C'z') THEN
	                ascii_word[vs$aw_b_char_code] = 
				.ascii_word[vs$aw_b_char_code] - 32;
		  END;
!
! Special character requires special processing
!
		vs$$special_char(
			.vkb_adr,
			.ascii_word,
			action_only,
			echoed);
	  END;			!Of if keyboard not unencoded
!
! See if we have satisfied the read based on whether or not escape mode
! and an escape sequence are in progress after updating the user's buffer
!
	IF NOT .action_only THEN
	  BEGIN
!
! Put it into the user's buffer and increment the pointer into the user's
! buffer if the keyboard in unencoded or its not a dead key code
!
	    mchar_list[0] = 3;
	    mchar_list[1] = .rr_adr[vs$rr_b_buffer_inc];
	    mchar_list[2] = .ascii_word;
	    mchar_list[3] = .rr_adr[vs$rr_a_buffer] +
					.rr_adr[vs$rr_l_buffer_ptr];
	    $CMKRNL(
		ROUTIN = vs$$kmode_move,
		ARGLST = mchar_list);
!
	    IF (.vkb_adr[vs$vkb_l_trans_table] EQL vsta$k_tt_unencoded) OR
	      ((.vkb_adr[vs$vkb_l_trans_table] NEQ vsta$k_tt_unencoded) AND
		(NOT .ascii_word[vs$aw_v_dead])) THEN
	      BEGIN
		IF .rr_adr[vs$rr_l_buffer_ptr] EQL 0 THEN
		  rr_adr[vs$rr_w_cursor_start] = vsta$$odrv_current_column(
						     .vkb_adr[vs$vkb_l_vd_id]);
!
	        rr_adr[vs$rr_l_buffer_ptr] =
		  .rr_adr[vs$rr_l_buffer_ptr] + .rr_adr[vs$rr_b_buffer_inc];
	      END;
!
! See if the read has been satisfied (first based on whether we are in
! escape mode and if not based on normal mode)
!
	    IF NOT (esc_sequence = vs$$check_escape(
					.vkb_adr,
					.ascii_word,
					term_flag,
					.read_status)) THEN
	      satisfied = vs$$end_of_read(
					.vkb_adr,
					.ascii_word,
					term_flag)
	    ELSE
	      satisfied = .term_flag;
!
! Echo the character if the modes and states of this virtual keyboard dictate
!
	    IF .vkb_adr[vs$vkb_l_trans_table] NEQ vsta$k_tt_unencoded THEN
	      IF NOT .echoed THEN
	        IF NOT .esc_sequence THEN
	          BEGIN
	            vs$$echo_character(.vkb_adr,
				   .ascii_word);
		    vkb_adr[vs$vkb_v_read_active] = true;
	          END;
	  END;
!
	RETURN .satisfied;	!return whether or not satisfied
END;				! of routine vs$$process_char


%SBTTL 'vs$$char_available -- Get the Next Available Character'
ROUTINE vs$$char_available(
			vkb_adr: REF vkb_block,		!VKB address
			encoded_char,			!Encoded char.
			ascii_word: REF VECTOR[0,WORD]	!Ascii char. address
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for finding the next available ascii
! character to satisfy a read on the specified VKB. The ascii character to
! be returned will be whatever the emulator tells me is the correct ascii
! character. The encoded character passed as a parameter may undergo as
! many as two translations or as few as none.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR		: Address of Virtual Keyboard block
!				(input parameter)
!	ENCODED_CHAR	: Longword encoded character to be processed (or -1)
!				(input parameter)
!	ASCII_WORD	: Address for word ascii character to be returned
!				(output parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	true (= 1)	=> Found a character to return in ASCII_WORD
!	false (= 0)	=> DID NOT find a character
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

    LITERAL
	compose_character = 1 ^ 12;		!Bit indicating compose down
!
! If this character code is owned by the human interface (i.e. gets out-of-band
! action from the human interface instead of normal characters processing),
! then perform the appropriate action
!
	IF vs$$vkb_hi_key(.vkb_adr,.encoded_char) THEN
	  RETURN false;
!
! If both the encoded character is less than zero (which indicates that we
! are looking for any characters in the input stream for a given emulator)
! and the VKB is unencoded, we have NO characters available
!
	IF .vkb_adr[vs$vkb_l_trans_table] EQL vsta$k_tt_unencoded THEN
	  IF .encoded_char LSS 0 THEN
	    RETURN false;
!
! If the (un)encoded character is greater than zero, it requires translation.
!
	IF .encoded_char LSS 0 THEN
	  ascii_word[0] = -1
	ELSE
	  BEGIN
	    IF (.encoded_char AND compose_character) NEQ 0 THEN
	      IF .vkb_adr[vs$vkb_v_level] EQL vkb$k_level_1 THEN
		RETURN false;
!
	    IF NOT vsta$$vkb_encoder(
				.encoded_char,
				.vkb_adr[vs$vkb_b_dead],
				.vkb_adr[vs$vkb_l_trans_table],
				.vkb_adr,
				ascii_word[0],
				vkb_adr[vs$vkb_b_dead]) THEN
	      RETURN false;
	  END;
!
! Perform next level of translation (expanding special characters into escape
! sequences based on keyboard modes)
!
	IF .vkb_adr[vs$vkb_l_trans_table] EQL vsta$k_tt_unencoded THEN
	  RETURN true
	ELSE
	  RETURN vs$$native_vkb_translator(
				.vkb_adr,
				.ascii_word[0],
				ascii_word[0]);
!
END;				! of routine vs$$char_available


%SBTTL 'vs$$vkb_hi_key -- Determine if Key Owned by Human Interface'
ROUTINE vs$$vkb_hi_key(
			vkb_adr: REF vkb_block,		!VKB block
			unencoded_char			!Unencoded char.
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for determining if the specified
! unencoded character code belongs to the human interface or undergoes the
! normal character processing. These keys (like HELP, MENU, etc.) are
! completely "out-of-band" with respect to all other keys on the keyboard
! and are unreadable. Only human interface action may be taken as a result
! of pressing these keys.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR		: Address of virtual keyboard block
!				(input parameter)
!	UNENCODED_CHAR	: Word unencoded character to be examined
!				(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	true (= 1)	=> Character does belong to the human interface
!	false (= 0)	=> Character DOES NOT belong to human interface
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LITERAL
	help_key = %X'7c',
	menu_key = %X'7d';

LOCAL
	char_code: WORD;			!Temp. storage for char. code
!
! The human interface doesn't own ANY keys in OEM mode
!
	IF .vs$gl_oem_flags THEN
	  RETURN false;
!
! For now, if this isn't the HELP key or the MENU key, then its not a
! human interface owned keystroke
!
	char_code = .unencoded_char AND vb$m_char_code;
	IF (.char_code NEQ help_key) AND
	   (.char_code NEQ menu_key) THEN
	  RETURN false;
!
! If the keystroke was received unsolicited, then remove it from the
! typeahead buffer of this virtual keyboard so it will be ignored on
! subsequent read operations
!
	IF NOT .vkb_adr[vs$vkb_v_read] THEN
	  vsta$$kernel_call(
			vs$$delete_typeahead,
			.vkb_adr);
!
! If this was an upstroke on a human interface key, then indicate that its
! a human interface key, but don't inform the human interface
!
	IF (.unencoded_char AND vb$m_char_tran) EQL 0 THEN
	  RETURN true;
!
! Call the appropriate human interface routine for this keystroke
!
	SELECTONE .char_code OF
	  SET
	    [help_key] : vs$$post_ast_request(
				vsta$$help_button_pressed);
	    [menu_key] : vs$$post_ast_request(
				vsta$$popup_main_menu);
	  TES;
!
	RETURN true;
END;				! of routine vs$$vkb_hi_key


%sbttl	'VSTA$$VKB_ENCODER -- Encodes un-encoded VKB data'
global routine VSTA$$VKB_ENCODER(
		INWORD: word,			! Input data
		DEADIN: byte,			! Previous character, if dead
		TRANS_TABLE,			! Which keyboard, or up/down
		VKB: ref vkb_block,		! Address of VKB data structure
		OUTWORD: ref vector [0,word],	! Address of translation code
		DEADOUT:ref vector [0,byte]	! Previous character, if dead
				) =		!

!++
! FUNCTIONAL DESCRIPTION:
!		Translates un-encoded keyboard input according to a specified 
!	translation table.  Every keystroke is reported to this routine, which 
!	attempts to translate that stroke.  If the stroke is translatable, the 
!	translation is stored in address OUTWORD.  DEADOUT indicates whether
!	the character is a "dead" diacritical, i.e., whether it should be
!	echoed without cursor advancement.  If so, DEADOUT contains the 
!	identity of the diacritical.  This value is passed back to this 
!	routine in DEADIN during translation of the next character.  If non-zero, it 
!	indicates that the following normal character must undergo another 
!	translation, using a special "dead" table, to define the final dipthong
!	character.
!		If the key was pressed DOWN, then the translation table 
!	given in DOWNTABLE will be used; if it was released, the UPTABLE translation 
!	table will be used.  (A zero in UPTABLE will cause a NULL character
!	to be returned for all upstrokes; a zero in DOWNTABLE
!	causes the standard VT100 translation table to be used.)
!		If the character is not translatable, then the DECMCS code
!	SUB, echoed as a reversed question mark, will be returned.
!
! FORMAL PARAMETERS:
!	INWORD		The value of the unencoded keypress, used as input 
!			into the translation table, is stored in the low byte. 
!
!				15   13  11  9 8 7             0
!				+-+-+-+-+-+-+-+-+---------------+
!				| | | | | | | | |    keycode	|
!				+-+-+-+-+-+-+-+-+---------------+
!				     | | | | | +--- up/down: 1=down, 0=up
!				     | | | | +----- caps_lock
!				     | | | +------- shift
!				     | | +--------- control
!				     | +----------- symbol (i.e., "compose")
!				     +------------- delete
!
!			Bits 8 through 13 encode the keyboard state at the time
!			of the keystroke.
!
!	DEADIN		A byte indicating whether the previous character 
!			input to the VKB was a dead character.  If not, this
!			byte equals zero.  If it was, then this byte equals
!			the low 8 bits of OUTWORD for that character.
!
!	TRANS_TABLE	Longword translation table indentifier.  The table is
!			organized in such a way that the first ENTRIES words
!			represent the values corresponding to the ENTRIES
!			unshifted keys.  (ENTRIES is the maximum number of
!			keys supported by the hardware, KEY_NUM, minus the
!			number of unused keycodes, currently 86, that are
!			removed from the front of the list.)
!			The next ENTRIES words contain the values
!			for the ENTRIES keys when SHIFTed.  The third set of ENTRIES
!			words contains the CONTROL values, and the fourth set
!			have the LOCKED-CAPS values.  The last section 
!			contains entries for however many combinations of
!			dead diacritical symbols and normal letter pairs
!			exist for the translation table.  The last entry 
!			must be all zeroes, to indicate the end of the table.
!			N.B. THE FINAL LONGWORD IN THE TABLE MUST BE A ZERO,
!			to mark the end of the table, even if there are no
!			"dead" entries.
!				The index into the dead table is the keycode of
!			INWORD.  Each table entry in the first 4 sections is 
!			a 16 bit word containing 3 bits of TYPE information,
!			and 13 bits of CODE:
!
!			       15 14 13        8 7             0
!				+-+-+-+---------+---------------+
!				| | | | 	|     code	|
!				+-+-+-+---------+---------------+
!				 | | +-----"symbol" key
!				 | +-------"dead" key
!				 +---------program-defined
!
!			If the "Program Defined" bit is 0, then this is a normal
!			character, and the "dead" and "symbol" bits are 
!			meaningful.  In 
!			that case, the code is the DEC Multinational Character 
!			Set code.  Otherwise, if bit 15 is set, the code
!			is used by the application programmer, or terminal
!			emulator, or identify whatever special-case actions
!			(e.g., escape sequences) he wishes to define.  Such
!			a character will always terminate the READ request.
!				The CODE for a "symbol" key provides a (word)
!			index into the Symbol Map.  Each entry in the map
!			consists of 6 words:
!			    map[0] = DECMS code of seed letter
!			    map[1] = DECMS code of first symbol (or Null, or Next)
!						.
!						.
!						.
!			    map[5] = DECMS code of last symbol (or Null, or Next)
!			The VKB data structure points to the current entry
!			with VS$VKB_L_SYMBOL_MAP_BOFF.  This pointer is established
!			when the symbol key is simultaneously pressed with a
!			legal seed key, or when a "Next" symbol key is pressed.
!				In the dead table, there is one longword
!			defined for every diacritical-letter pair:
!
!				31	      16 15    8 7      0
!				+---------------+-------+-------+
!				| 16 bit entry	|letter	|diacrit|
!				| 		|code	|code	|
!				+---------------+-------+-------+
!
!			The first byte is the 8-bit translation code for
!			the diacritical symbol.  The next byte is the 8-bit
!			translation code for the normal letter.  The high
!			order word contains the 16-bit code + TYPE for the
!			combination.

!
!			+-------------------------------------------+ 
!			|					    | TABLE:
!			|					    |
!			|	ENTRIES words	[Lower Case]	    |
!			|					    |
!			|					    |
!			+-------------------------------------------+
!			|					    |
!			|					    |
!			|	ENTRIES words	[SHIFTed]	    |
!			|					    |
!			|					    |
!			+-------------------------------------------+
!			|					    |
!			|					    |
!			|	ENTRIES words	[CONTROL]	    |
!			|					    |
!			|					    |
!			+-------------------------------------------+
!			|					    |
!			|					    |
!			|	ENTRIES words	[LOCKED-CAPS]	    |
!			|					    |
!			|					    |
!			+-------------------------------------------+
!			|					    |
!			|					    |
!			|	?? longwords	[DEAD combinations] |
!			|					    |
!			+-------------------------------------------+
!			|		    0			    |
!			+-------------------------------------------+
!
!	VKB		The address of the VKB data structure corresponding
!			to the currently active VKB
!
!	OUTWORD		The address into which the 16-bit translation (from the 
!			translation table) will be returned.
!
!	DEADOUT		The address of a byte into which either the low 8 bits
!			of OUTWORD (if this is a dead key), or zero (if this
!			is a normal key) is returned.  The VKB routine will
!			provide this value in DEADIN on the next call.
!
! IMPLICIT INPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	true  (=1) : Able to translate
!	false (=0) : Unable to translate
!
! SIDE EFFECTS:
!	NONE
!
!--

begin


!
! Literals
!
literal
	CTRL = %X'AF',		! Control key input code
	CPSLCK = %X'B0',	! Caps Lock input code
	SHFT = %X'AE',		! Shift key input code
	ALL_UPS = %X'B3',	! No-keys-currently-pressed input code
	METRONOME = %X'B4',	! Autorepeat input code
	SUB = %X'1A',		! Unrecognized character DECMCS code
	KEY_NUM = 256,		! Number of unique keyboard codes required
	KEYS_UNUSED = 86,	! Unused keycodes, 0-n.
	ENTRIES = KEY_NUM - KEYS_UNUSED, ! Number of table entries in each section
	PRESSED_MAX = 12,	! Maximum # of rollover keys allowed
	VS$K_DEAD_VEC = 16,	! Offset to Dead section of Translation Table
	NEXT = -1,		! Symbol key code
	NULL = 0,		! Symbol key code
	M_DEAD = 1^6,		! Mask for RESULT (considered as a byte)
	M_SYMBOL_KEY = 1^13,	! Mask for RESULT (considered as a word)
	M_CAPS_LOCK = 1^9,	! Mask for INWORD
	M_SHIFT = 1^10,		! Mask for INWORD
	M_CONTROL = 1^11,	! Mask for INWORD
	M_COMPOSE = 1^12,	! Mask for INWORD
	M_UP_DOWN = 1^8;	! Mask for INWORD
!
! VARIABLES
!

local	INDEX,			! Calculated index into translation table
	TABLE:ref vector [0,word,signed], ! Pointer to the table we'll use 
	DISPLACEMENT,		!
	LAST_SEED,
	LAST_SEED_ADDR,
	UPPER_SEED:signed word,
	LOWER_SEED:signed word,
	RESULT:signed word,	! Translated value (2 bytes long)
	LETTER: byte,		! Remembers current character translation
	INBYTE: byte;		! Low byte of INWORD

!
! Translate the character.
! If we are using the keyboard as unencoded, then don't translate the character
! If the keyboard is encoded, and this is an upstroke, then return a Null character
!
	if .TRANS_TABLE eql vsta$k_tt_unencoded 
	    then 
		begin			! Unencoded
		OUTWORD [0] = .INWORD;		! No translation
		return true;
		end			! Unencoded

	    else
		begin			! Encoded
		if (.INWORD and M_UP_DOWN) eql 0 then
		    begin		! Encoded Upstroke
			OUTWORD [0] = 0;		! Null Character
			return false;
		    end;		! Encoded Upstroke
		end;			! Encoded
!
! Check the parameters, and return the SUB character if they're no good.
!
	INBYTE = .INWORD;
	if    (	(.INBYTE eql METRONOME) or
		(.INBYTE eql ALL_UPS)   or
		(.INBYTE eql CTRL)	or
		(.INBYTE eql SHFT)	or
		(.INBYTE eql CPSLCK)	)
	    then 
		begin
		OUTWORD [0] = SUB;			! Unrecognized character
		return false;
		end;

!
! Set up the appropriate translation table in TABLE
!
	INDEX = .INWORD<9,4,0>;			! Keyboard state
	TABLE = .VTEM$AL_VKB_TRANS_VECS [.TRANS_TABLE, .INDEX];
	if (.TABLE eql 0) then			! Dis-allowed keyboard state
		begin
		OUTWORD [0] = SUB;		! Unrecognized character
		return false;
		end;

!
! Get the 16-bit table entry
!
	INDEX = .INBYTE - KEYS_UNUSED;
	RESULT = .TABLE [.INDEX];

!
! SYMBOL character handling
!
! First, if the compose key and a seed key were simultaneously pressed,
! we must re-define the symbol map displayed by the Human Interface on the
! screen.
!
    if (.INWORD and M_COMPOSE) neq 0 then
	begin		! Compose key simultaneously pressed with seed
   !
   ! Remember the seed values for both upper- and lower-case instances
   ! of this key
   !
	TABLE = .VTEM$AL_VKB_TRANS_VECS [.TRANS_TABLE, 2]; ! Shift table
	if (.TABLE eql 0) then	return false;	! Dis-allowed keyboard state
	INDEX = .INBYTE - KEYS_UNUSED;
	UPPER_SEED = .TABLE [.INDEX];

	TABLE = .VTEM$AL_VKB_TRANS_VECS [.TRANS_TABLE, 0]; ! Lower-case table
	if (.TABLE eql 0) then	return false;	! Dis-allowed keyboard state
	LOWER_SEED = .TABLE [.INDEX];

   !
   ! Store the address of the UPPER case symbols in the VKB
   !
	TABLE = .VTEM$AL_VKB_SYMBOL_VECS [.TRANS_TABLE]; !Top of symbol table
	INDEX = 6;	! Start with first non-null entry in symbol table
	until .TABLE [.INDEX] eql .UPPER_SEED  do ! Look for upper-seed character
	    begin	! Seed search loop
	    if .TABLE [.INDEX] lss 0 then
		begin	! Bad seed character
		VSTA$$HI_BAD_SEED (.UPPER_SEED); ! Inform Human Interface of failure
		return false;		! No translation
		end;	! Bad seed character
	    INDEX = .INDEX + 6;		! Next entry in symbol table
	    end;	! Seed search loop
    !
    ! Now save the entry position, and inform the Human Interface,
    ! so that he can display the UPPER case symbols on the monitor
    !
	VKB [VS$VKB_L_SHIFT_SYMBOL_MAP_BOFF] = .INDEX * 2;  ! Convert to bytes
	VSTA$$HI_NEW_SYMBOLS ( TABLE [.INDEX] );	! Entry's address

   !
   ! Store the address of the LOWER case symbols in the VKB
   !
	TABLE = .VTEM$AL_VKB_SYMBOL_VECS [.TRANS_TABLE]; !Top of symbol table
	INDEX = 6;	! Start with first non-null entry in symbol table
	until .TABLE [.INDEX] eql .LOWER_SEED  do ! Look for lower-seed character
	    begin	! Seed search loop
	    if .TABLE [.INDEX] lss 0 then
		begin	! Bad seed character
		VSTA$$HI_BAD_SEED (.LOWER_SEED); ! Inform Human Interface of failure
		return false;		! No translation
		end;	! Bad seed character
	    INDEX = .INDEX + 6;		! Next entry in symbol table
	    end;	! Seed search loop
    !
    ! If this is a ',' or a '.', which are the same for upper- and lower-case,
    ! then the lower case entry is the one AFTER the one we found here.
    !
	if (.LOWER_SEED eql .UPPER_SEED) then INDEX = .INDEX + 6;
    !
    ! Just save the entry position; don't inform the Human Interface
    ! of this address.
    !
	VKB [VS$VKB_L_LOWER_SYMBOL_MAP_BOFF] = .INDEX * 2;  ! Convert to bytes
    !
    ! Return to VKB
    !
	return false;	! Nothing for the buffer
	end;		! Compose key simultaneously pressed with seed

!
! If this key is a Symbol key, i.e., one of keys "F1"-"F5", then we must
! return whatever DECMS code corresponds to that key at the moment.
! We must also be sensitive to the 'CAPS_LOCK' and 'SHIFT' states present
! when the function key was pressed.
!
    if (.RESULT and M_SYMBOL_KEY) neq 0 then
	begin		! Symbol (Function) Key pressed
   !
   ! Point to the appropriate Symbol table entry with TABLE
   !
	TABLE = .VTEM$AL_VKB_SYMBOL_VECS [.TRANS_TABLE]; ! TOP of symbol table
	if (.INWORD and M_SHIFT) neq 0 then
		TABLE = .TABLE	+ .VKB [VS$VKB_L_SHIFT_SYMBOL_MAP_BOFF] ! SHIFT
	else	if (.INWORD and M_CAPS_LOCK) neq 0 then
		TABLE = .TABLE	+ .VKB [VS$VKB_L_SHIFT_SYMBOL_MAP_BOFF] ! CAPS
	else	TABLE = .TABLE	+ .VKB [VS$VKB_L_LOWER_SYMBOL_MAP_BOFF]; ! LOWER

   !
   ! Consistency check the table and the function-key index into the entry
   !
	LETTER = .RESULT;	! Save low byte of RESULT (== index)
	if (.LETTER geq 6) or (.TABLE leq 0) then
		begin		! Bad Function Key pressed
		VSTA$$HI_BAD_SEED (.LETTER);
		return false;
		end;		! Bad Function Key pressed

	RESULT = .TABLE [.LETTER]; ! This is the composite symbol, if any

   !
   ! If the entry is a NULL, or a NEXT, do the appropriate thing
   !
	selectone .RESULT of
	set
	    [0]:
		begin		! Null Symbol Translation
		VSTA$$HI_NULL_SYMBOLS_INPUT ();
		return false;
		end;		! Null Symbol Translation

	    [-1]:
	    begin		! NEXT Symbol Translation
	 !
	 ! See if the next entry is for the same seed character
	 !
	    if (.TABLE [6] eql .TABLE [0]) then
		begin	! Next entry is good
		VKB [VS$VKB_L_SHIFT_SYMBOL_MAP_BOFF] = 
			.VKB [VS$VKB_L_SHIFT_SYMBOL_MAP_BOFF] +12; !Bytes, remember
		VKB [VS$VKB_L_LOWER_SYMBOL_MAP_BOFF] = 
			.VKB [VS$VKB_L_LOWER_SYMBOL_MAP_BOFF] +12; !Bytes, remember
		TABLE = .VTEM$AL_VKB_SYMBOL_VECS [.TRANS_TABLE] ! TOP of symbol table
			+ .VKB [VS$VKB_L_SHIFT_SYMBOL_MAP_BOFF]; ! Shifted entry
		VSTA$$HI_NEW_SYMBOLS ( .TABLE ); ! Next Entry's address
		return false;	! Nothing for the buffer
		end	! Next entry is good
	 !
	 ! If not, start over again with the first entry with this seed
	 !
	    else
		begin	! Wrap around to first seed entry
		LAST_SEED = .TABLE [0];		! Save current seed 
		LAST_SEED_ADDR = TABLE [0];	! Save current seed address 
		TABLE = .VTEM$AL_VKB_SYMBOL_VECS [.TRANS_TABLE]; !Top of symbol table
		INDEX = 6;	! Start with first non-null entry in symbol table
		until .TABLE [.INDEX] eql .LAST_SEED  do ! Look for seed character
		    begin	! Seed search loop
		    if .TABLE [.INDEX] lss 0 then
			begin	! Bad seed character
			VSTA$$HI_BAD_SEED (.LAST_SEED); ! Inform Human Interface of failure
			return false;		! No translation
			end;	! Bad seed character
		    INDEX = .INDEX + 6;		! Next entry in symbol table
		    end;	! Seed search loop
	    !
	    ! Now save the entry position, and inform the Human Interface
	    !
		DISPLACEMENT = .LAST_SEED_ADDR - TABLE [.INDEX];! 6*(# entries - 1)
		VKB [VS$VKB_L_SHIFT_SYMBOL_MAP_BOFF] = 
			.VKB [VS$VKB_L_SHIFT_SYMBOL_MAP_BOFF] - .DISPLACEMENT;
		VKB [VS$VKB_L_LOWER_SYMBOL_MAP_BOFF] = 
			.VKB [VS$VKB_L_LOWER_SYMBOL_MAP_BOFF] - .DISPLACEMENT;
		TABLE = .VTEM$AL_VKB_SYMBOL_VECS [.TRANS_TABLE] ! TOP of symbol table
			+ .VKB [VS$VKB_L_SHIFT_SYMBOL_MAP_BOFF]; ! Shifted entry
		VSTA$$HI_NEW_SYMBOLS ( .TABLE ); ! Next Entry's address
		return false;	! Nothing for the buffer
		
		end;	! Wrap around to first seed entry

	    end;		! NEXT Symbol Translation

	[otherwise] :
	begin		! Ordinary Symbol Key Press
     !
     ! If we're here, we have a legitimate symbol character.  Tell the world 
     ! about it.
     !
	OUTWORD [0] = .RESULT;
	return true;		! We pass the character back for the buffer
	end;		! Ordinary Symbol Key Press

	tes;


    end;		! Symbol (Function) Key pressed

!
! DEAD character handling
!
   begin				! RESULT a byte vector now

	map RESULT:vector [0,byte,signed]; ! Refer to this as a byte vector
					!	for this block
!
! Fill in DEADOUT
!
	    begin			! DEADOUT
		if ((.RESULT [1] and M_DEAD) neq 0)
		    then DEADOUT [0] = .RESULT [0]	! Dead character code
		    else DEADOUT [0] = 0;
	    end;			! DEADOUT

	    LETTER = .RESULT [0];	! Save the code in case we must re-translate it

   end;				! RESULT a word again

!
! If previous character was dead, re-translate the RESULT
!
    if (.DEADIN neq 0) then
	begin			! Combination character
	    TABLE = .VTEM$AL_VKB_TRANS_VECS [.TRANS_TABLE , 
					VS$K_DEAD_VEC]; !Dead table
	    INDEX = 0;			! Start at beginning, shall we?
	    until .RESULT eql 0 do	! RESULTs in 0 if no entry matched
		begin			! Dead list loop
		RESULT = .TABLE [.INDEX];

		    begin		! RESULT a byte vector now
		    map RESULT:vector [0,byte,signed];
		    if ((.RESULT [0] eql .DEADIN) and	! Diacritical match?
			(.RESULT [1] eql .LETTER)) 	! Letter match?
			then
			begin		! Matching deceased
			    OUTWORD [0] = .TABLE [.INDEX + 1]; ! Next word is goody
			    return true;
			end;		! Matching deceased
		    end;		! RESULT re-mapping

		INDEX = .INDEX + 2;	! Entries are longwords
		end;			! Dead list loop

	end;			! Combination character

!
! Now return the translated value
!
	OUTWORD [0] = .RESULT;
	return true;

end;			!End of routine VSTA$$VKB_ENCODER

%SBTTL 'vs$$native_vkb_translator -- Native VKB Eight-bit/Seven-bit'
ROUTINE vs$$native_vkb_translator(
		vkb_adr: REF vkb_block,		! address of VKB data block
		input_word: WORD,		! value of input word
		output_byte: REF VECTOR [,BYTE]	! address to put output word
			) =
!++
!  FUNCTIONAL DESCRIPTION:
!
!   This routine receives a word from the vkb.  This word can be -1 which
!   indicates that the next word in the generation buffer is to be put in
!   the output byte or returns bad status if the gereration buffer is empty.  
!   If the input word is not -1 then it is checked for being a %x'80nn' or
!   a %x'81nn' number which implies that it is a special key code. Then
!   according to the mode of the terminal (seven-bit or eight-bit) and the mode
!   of the special keys the appropriate escape sequence is put into
!   the generation buffer and the output word will be the first of the
!   generated sequence.  If the input word is not X80nn or X8100 then the
!   output word gets set to the input word.  This is the same mechanism that
!   answer back and terminal status is reported.
!
!  FORMAL PARAMETERS:
!
!	VKB_ADR	     : Address of VKB data block
!				(input parameter)
!	INPUT_WORD   : Word value of input word (from translation table)
!				(input parameter)
!	OUTPUT_BYTE  : Address to put output word
!				(output parameter)
!
!  IMPLICIT INPUTS: 
!
!	NONE
!
!  IMPLICIT OUTPUTS:
!
!	NONE
!
!  RETURN VALUE:
!
!	NONE
!
!  COMPLETION CODES:
!
!	TRUE  (=1) if something was returned to the address of output_word_a
!	FALSE (=0) otherwise
!
!  SIDE EFFECTS:
!
!	Escape sequences are generated for the keypad, cursor keys, editing
!	keypad keys, and function keys based on whether or not there is an
!	emulator responsible for this translation, and if not, on modes and
!	states of the device.
!
!--
BEGIN

    LOCAL
	gen_buffer: REF VECTOR[0,BYTE],		!VKB generation buffer
	input_byte: REF VECTOR[0,BYTE];		!Individual bytes of inword

!
! If there is an emulator, see if it has anything to go into the input stream
! and if so, use that
!
	IF .vkb_adr[vs$vkb_l_vd_id] NEQ 0 THEN
	  IF .vkb_adr[vs$vkb_a_gchar_routine] NEQ 0 THEN
	    IF (.vkb_adr[vs$vkb_a_gchar_routine])(
					.vkb_adr[vs$vkb_a_vd],
					.input_word,
					.output_byte) THEN
	      RETURN SS$_NORMAL;
!
! No emulator data means that we should use any data we have stored up.
!
	gen_buffer = vkb_adr[vs$vkb_a_gen_buffer];
	input_byte = input_word;
	output_byte[1] = 0;	

!
! If the input is -1 then put the next byte of the generation buffer into
! the output byte and decriment the generation buffer index
! if the generation buffer is empty (index=-1) then return bad status
!
	IF .input_byte[1] EQL %x'ff' THEN
	  BEGIN
	    IF .vkb_adr[vs$vkb_l_gen_index] LSS 0 THEN
	      RETURN false;
	    output_byte[0] = .gen_buffer[.vkb_adr[vs$vkb_l_gen_index]];
	    vkb_adr[vs$vkb_l_gen_index] = .vkb_adr[vs$vkb_l_gen_index] - 1;
	    RETURN SS$_NORMAL;
	  END;
!
! Check if this word back from the translation table has the upper bit
! set. This indicates that special processing needs to be performed.
!
	IF (.input_byte[1] AND %x'80') EQL 0 THEN
	  IF (.input_byte[1] AND %x'10') NEQ 0 THEN
	    BEGIN
	      output_byte[0] = .input_byte[0];
	      vkb_adr[vs$vkb_l_gen_index] = -1;
	      RETURN false;
	    END
	  ELSE
	    BEGIN
!
! If new-line mode is enabled and this is a carriage return, then we need
! to convert it into a <CR><LF>
!
	      IF .vkb_adr[vs$vkb_v_new_line] THEN
	        IF .input_byte[0] EQL carriage_return THEN
		  BEGIN
		    output_byte[0] = carriage_return;
		    gen_buffer[0] = line_feed;
		    vkb_adr[vs$vkb_l_gen_index] = 0;
		    RETURN SS$_NORMAL;
		  END;
!
! Normal ascii then send back just the lower byte
!
	      output_byte[0] = .input_byte[0];
	      vkb_adr[vs$vkb_l_gen_index] = -1;

	      ! If the key is a Dead Diacritical key then set the Dead Key
	      ! bit of the upper byte of the output word. 

	      IF (.input_word AND %X'4000') NEQ 0 THEN
		    output_byte[1] = %X'40';


              RETURN SS$_NORMAL;
	    END;
!
! Special key then it is one of three classes strip off bit 8 and
! perform a case statement
!
	CASE (.input_byte[1] AND %X'7f') FROM 0 TO 4 OF
	  SET
!
! 0: this is a PF key
!
	    [0]: BEGIN
		   gen_buffer[0] = .input_byte[0];
		   IF NOT .vkb_adr[vs$vkb_v_eightbit] THEN
		     BEGIN
!
! SEVEN_BIT conformance - Generate <ESC><input-byte> in VT52 mode and
! <ESC>O<input-byte> in ansi
!
		       output_byte[0] = escape;
		       IF .vkb_adr[vs$vkb_v_vt52] THEN
			 vkb_adr[vs$vkb_l_gen_index] = 0
		       ELSE
		         BEGIN
			   gen_buffer[1] = %C'O';
			   vkb_adr[vs$vkb_l_gen_index] = 1;
		         END;
		       RETURN SS$_NORMAL;
		     END;
!
! EIGHT_BIT conformance - Generate <ss3><input-byte>
!
		   output_byte[0] = ss3;
		   vkb_adr[vs$vkb_l_gen_index] = 0;
		   RETURN SS$_NORMAL;
		 END;

!
! 1: This is a numeric keypad key
! 
	    [1]: BEGIN
!
! SEVEN_BIT and EIGHT_BIT conformance - if the keypad not in keypad application
! mode then just send back lower byte.
!
		   IF NOT .vkb_adr[vs$vkb_v_keypad] THEN
		     BEGIN
		       output_byte[0] = .input_byte[0];
		       RETURN SS$_NORMAL;
		     END;
!
		   gen_buffer[0] = .input_byte[0] + 64;
		   IF NOT .vkb_adr[vs$vkb_v_eightbit] THEN
		     BEGIN
!
! SEVEN_BIT conformance - If so then output byte becomes an escape
! and generation buffer looks like O"n", where n = lower-byte + 64
! or looks like ?"n" for VT52 mode
!
		       output_byte[0] = escape;
		       IF .vkb_adr[vs$vkb_v_vt52] THEN
		         gen_buffer[1] = %C'?'
		       ELSE
		         gen_buffer[1] = %C'O';
		       vkb_adr[vs$vkb_l_gen_index] = 1;
		       RETURN SS$_NORMAL;
		     END;
!
! EIGHT_BIT conformance - Generate <ss3><input-byte + 64>
!
		   output_byte[0] = ss3;
		   vkb_adr[vs$vkb_l_gen_index] = 0;
		   RETURN SS$_NORMAL;
		 END;

!
! 2: this is a cursor key. 
!
	    [2]: BEGIN
		   gen_buffer[0] = .input_byte[0];
		   IF NOT .vkb_adr[vs$vkb_v_eightbit] THEN
		     BEGIN
!
! SEVEN_BIT conformance - If in cursor key mode gen_buffer = O .code_byte.
! If not, then gen_buffer = [ .code_byte. In either case, once again, the
! output byte is always escape. (In VT52 mode, you just get <ESC><input-byte>.
!
		       output_byte[0] = escape;
		       IF .vkb_adr[vs$vkb_v_vt52] THEN
			 BEGIN
			   vkb_adr[vs$vkb_l_gen_index] = 0;
			   RETURN SS$_NORMAL;
			 END;
!
		       IF .vkb_adr[vs$vkb_v_cursor_key] THEN
		         gen_buffer[1] = %C'O'
		       ELSE
		         gen_buffer[1] = %C'[';
		       vkb_adr[vs$vkb_l_gen_index] = 1;
		       RETURN SS$_NORMAL;
		     END;
!
! EIGHT_BIT conformance - Generate <csi><input-byte> if cursor key
! mode off and <ss3><input-byte> if its on
!
		   IF .vkb_adr[vs$vkb_v_cursor_key] THEN
		     output_byte[0] = ss3
		   ELSE
		     output_byte[0] = csi;
		   vkb_adr[vs$vkb_l_gen_index] = 0;
		   RETURN SS$_NORMAL;
		 END;
!
! 3: this is a keypad edit key. If level 1 keyboard, we don't transmit
! anything. If level 2, then proceed.
!
	    [3]: BEGIN
		   IF .vkb_adr[vs$vkb_v_level] EQL vkb$k_level_1 THEN
		     BEGIN
		       output_byte[0] = .input_byte[0];
		       vkb_adr[vs$vkb_l_gen_index] = -1;
		       RETURN false;
		     END;
!
! If not in eight-bit mode gen_buffer =  <ESC>[.code_byte~ and output byte is
! always escape. Otherwise, generate <csi><input-byte>~
!
		   gen_buffer[0] = %C'~';
		   gen_buffer[1] = .input_byte[0];
		   IF NOT .vkb_adr[vs$vkb_v_eightbit] THEN
		     BEGIN
		       output_byte[0] = escape;
		       gen_buffer[2] = %C'[';
		       vkb_adr[vs$vkb_l_gen_index] = 2;
		     END
		   ELSE
		     BEGIN
		       output_byte[0] = csi;
		       vkb_adr[vs$vkb_l_gen_index] = 1;
		     END;
		   RETURN SS$_NORMAL;
		 END;
!
! 4: these are the application function keys. If level 1 keyboard, only
! keys F11, F12, F13 transmit (escape, backspace, and line-feed respectively).
!
	    [4]: BEGIN
		   IF .vkb_adr[vs$vkb_v_level] EQL vkb$k_level_1 THEN
		     SELECTONE .input_byte[0] OF
		       SET
		         [23]	     : BEGIN
					 output_byte[0] = escape;
					 vkb_adr[vs$vkb_l_gen_index] = -1;
					 RETURN SS$_NORMAL;
				       END;
		         [24]	     : BEGIN
					 output_byte[0] = backspace;
					 vkb_adr[vs$vkb_l_gen_index] = -1;
					 RETURN SS$_NORMAL;
				       END;
		         [25]	     : BEGIN
					 output_byte[0] = line_feed;
					 vkb_adr[vs$vkb_l_gen_index] = -1;
					 RETURN SS$_NORMAL;
				       END;
		         [OTHERWISE] : BEGIN
					 output_byte[0] = .input_byte[0];
					 vkb_adr[vs$vkb_l_gen_index] = -1;
					 RETURN false;
				       END;
		         TES;
!
! For a level 2 keyboard, SEVEN_BIT mode gen_buffer = 
! <ESC>[<input-byte/10><input-byte MOD 10>~ and output byte is always escape.
! In EIGHT_BIT mode, gen_buffer = <csi><input-byte/10><input-byte MOD 10>~
! and output byte is always <csi>.
!
		   gen_buffer[0] = %C'~';
		   gen_buffer[1] = %C'0' + (.input_byte[0] MOD 10);
		   gen_buffer[2] = %C'0' + (.input_byte[0] / 10);
!
		   IF NOT .vkb_adr[vs$vkb_v_eightbit] THEN
		     BEGIN
		       output_byte[0] = escape;
		       gen_buffer[3] = %C'[';
		       vkb_adr[vs$vkb_l_gen_index] = 3;
		     END
		   ELSE
		     BEGIN
		       output_byte[0] = csi;
		       vkb_adr[vs$vkb_l_gen_index] = 2;
		     END;
		   RETURN SS$_NORMAL;
		 END;
	  TES;

END;				!End of routine vs$$native_vkb_translator


%SBTTL 'vs$$get_device_char -- Get VKB Device Characteristics'
ROUTINE vs$$get_device_char(
			vkb_adr: REF vkb_block		!VKB block address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for storing the device characteristics
! in the VKB as currently set in the UCB on which the IRP arrived. Therefore,
! once a read operation has commenced, the characteristics of the device will
! not change with respect to changes in the UCB until the next read request.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	  : Address of VKB data base in which to store characteristics
!			(Input and output parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	This routine runs in kernel mode.
!
!--
BEGIN

LOCAL
	ucb_adr: REF vd_ucb_block;		!Unit Control Block address
!
! Find the UCB which the IRP came in on and return the characteristics
! longword of that UCB to the caller
!
	ucb_adr = .vs$al_vd_ucb[.vkb_adr[vs$vkb_l_vd_id]];
	IF .ucb_adr NEQ 0 THEN
	  vkb_adr[vs$vkb_l_char] = .ucb_adr[UCB$L_DEVDEPEND];
!
	RETURN;			!return success
END;				! of routine vs$$get_device_char


%SBTTL 'vs$$no_typeahead -- Get Rid of VKB Typeahead Info'
ROUTINE vs$$no_typeahead(
			vkb_adr: REF vkb_block		!VKB block address
			): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for clearing out typeahead buffer info
! stored in the UCB for an emulated terminal.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	  : Address of VKB data base
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	This routine runs in kernel mode.
!
!--
BEGIN

LOCAL
	typeahead: REF ttytadef,		!Typeahead buffer block
	ucb_adr: REF vd_ucb_block;		!Unit Control Block address
!
! Find the UCB which the IRP came in on and return the characteristics
! longword of that UCB to the caller
!
	IF (ucb_adr = .vs$al_vd_ucb[.vkb_adr[vs$vkb_l_vd_id]]) EQL 0 THEN
	  RETURN;
!
	IF (ucb_adr = .ucb_adr[UCB$L_TL_PHYUCB]) EQL 0 THEN
	  RETURN;
!
	IF (typeahead = .ucb_adr[UCB$L_TT_TYPAHD]) EQL 0 THEN
	  RETURN;
!
	typeahead[TTY$W_TA_INAHD] = 0;
	.typeahead[TTY$L_TA_GET] = 0;
!
	RETURN;			!return success
END;				! of routine vs$$no_typeahead


%SBTTL 'vs$$send_mbx_msg -- Send Unsolicited Data Message'
ROUTINE vs$$send_mbx_msg(
			ascii_word: REF vkb_ascii_word,	!Unsolicited char.
			vkb_adr: REF vkb_block		!VKB address
			) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for determining if an unsolicited data
! message need be sent, and if so sends it to either the job controller or
! the user's mailbox based on the UCB reference count and whether or not that
! mailbox exists. This routine is also responsible for updating those UCB
! fields pertaining to unsolicited data input when an emulator is present.
!
! FORMAL PARAMETERS:
!
!	ASCII_WORD : Address of ascii word character code
!			(input parameter)
!	VKB_ADR	   : Address of Virtual Keyboard block
!			(input parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
! COMPLETION CODES:
!
!	SS$_NORMAL : Always successful for now
!
! SIDE EFFECTS:
!
!	This routine runs in kernel mode.
!
!--
BEGIN

LOCAL
	status,					!Return status value
	typeahead: REF ttytadef,		!Typeahead buffer
	rr_adr: REF vkb_read_request,		!VKB current read context
	ucb_adr: REF vd_ucb_block;		!Unit Control Block address
!
! No unsolicited data mailbox messages for VKBs without output devices
!
	IF .vkb_adr[vs$vkb_l_vd_id] EQL 0 THEN
	  RETURN SS$_NORMAL;
!
! Find the UCB which corresponds to the output device for this VKB
!
	IF (ucb_adr = .vs$al_vd_ucb[.vkb_adr[vs$vkb_l_vd_id]]) EQL 0 THEN
	  RETURN SS$_NORMAL;
	IF (ucb_adr = .ucb_adr[UCB$L_TL_PHYUCB]) EQL 0 THEN
	  RETURN SS$_NORMAL;
	IF (typeahead = .ucb_adr[UCB$L_TT_TYPAHD]) EQL 0 THEN
	  RETURN SS$_NORMAL;
!
! Update the UCB with this unsolicited data information
!
	IF .typeahead[TTY$W_TA_INAHD] EQL 0 THEN
	  .typeahead[TTY$L_TA_GET] = .ascii_word[vs$aw_b_char_code];
	typeahead[TTY$W_TA_INAHD] = .typeahead[TTY$W_TA_INAHD] + 1;
!
! If we are not allowed to send unsolicited mailbox messages, then return
!
	IF NOT vsta$$odrv_mbx_enable(.vkb_adr[vs$vkb_l_vd_id]) THEN
	  RETURN SS$_NORMAL;
!
! If this message is to be sent to the job controller then address its mailbox
!
!***	IF .ucb_adr[UCB$W_REFC] EQL 0 THEN
!
! If we get here, then we have a message to send to the job controller
!*** DON'T SEND UNTIL IMPLEMENTED IN HUMAN INTERFACE ***
!
!	  BEGIN
!	    status = exe$sndevmsg(
!			SYS$GL_JOBCTLMB,
!			MSG$_TRMUNSOLIC,
!			.ucb_adr);
!	  END
!	ELSE
!
! If this message is to be sent to the user and a mailbox exists and
! it hasn't been notified already then address that mailbox
!
!	  BEGIN
	    IF .ucb_adr[UCB$L_AMB] EQL 0 THEN
	      RETURN SS$_NORMAL;
!
! If we get here, then we have a message to send to the user's mailbox
!
	    status = exe$sndevmsg(
			.ucb_adr[UCB$L_AMB],
			MSG$_TRMUNSOLIC,
			.ucb_adr);
!	  END;
!
	RETURN .status;		!return status
END;				! of routine vs$$send_mbx_msg


%SBTTL 'vs$$check_escape -- Check and Validate Esacpe Sequences'
ROUTINE vs$$check_escape(
			vkb_adr: REF vkb_block,		!VKB address
			ascii_word: REF vkb_ascii_word,	!ASCII word input
			term_flag,			!Read terminator flag
			read_status			!Read completion status
			) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for determining if a read with esacpe
! mode is active and if so validates the esacpe sequence and sets term_flag
! to true when either a valid sequence has been processed or an invalid
! character was interpreted in the sequence.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	   : Address of Virtual Keyboard block
!			(input parameter)
!	ASCII_WORD : Address of ascii word to validate in escape sequence
!			(input parameter)
!	TERM_FLAG  : Address for "Boolean" read terminator indicator
!			(output parameter)
!	READ_STATUS : Address for ascii read completion status (word)
!			(output parameter)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
! COMPLETION CODES:
!
!	TRUE  (=1) => When an escape sequence is in progress
!	FALSE (=0) => When NO esacpe sequence is in progress
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	rr_adr: REF vkb_read_request;		!VKB current read context

	rr_adr = .vkb_adr[vs$vkb_a_current_read];
!
! If we do not have escape mode enabled, then return indication
!
	IF NOT (((.vkb_adr[vs$vkb_l_char] AND TT$M_ESCAPE) NEQ 0)
	   OR  ((.rr_adr[vs$rr_l_full_function] AND IO$M_ESCAPE) NEQ 0)) THEN
	  RETURN false;
!
! If the escape state is zero and the character passed does not initiate an
! escape sequence, or its a special or dead character, we need not bother with
! the rest of this
!
	IF (.vkb_adr[vs$vkb_l_trans_table] EQL vsta$k_tt_unencoded) OR
	   (.ascii_word[vs$aw_v_special]) THEN
	  RETURN false;
!
	IF .vkb_adr[vs$vkb_l_escape_state] EQL vkb$k_not_doing_escape THEN
	  SELECTONE .ascii_word[vs$aw_b_char_code] OF
	    SET
	      [escape]    : rr_adr[vs$rr_w_terminator] = escape;
	      [ss3]	  : rr_adr[vs$rr_w_terminator] = ss3;
	      [csi]	  : rr_adr[vs$rr_w_terminator] = csi;
	      [OTHERWISE] : RETURN false;
	    TES;
!
! Now validate what we are storing for an escape sequence and return indicator
! of whether or not we have a read terminator
!
	IF vs$$escape_done(
			vkb_adr[vs$vkb_l_escape_state],
			.ascii_word[vs$aw_b_char_code],
			.term_flag,
			.read_status
			) THEN
	  rr_adr[vs$rr_w_terminator_size] = .rr_adr[vs$rr_w_terminator_size]
						+ .rr_adr[vs$rr_b_buffer_inc];
!
! If we terminated because of the escape sequence itself, reset the escape
! state for the next escape sequence
!
	IF (..term_flag) THEN
	  vkb_adr[vs$vkb_l_escape_state] = vkb$k_not_doing_escape;
!
! If we are still in the process of evaluating an escape sequence, but the
! buffer is full, return term_flag indication (preserving the vkb escape state
! for the next read
!
	IF .rr_adr[vs$rr_l_buffer_ptr] GEQ .rr_adr[vs$rr_l_buffer_size] THEN
	  .term_flag = true;
!
	RETURN true;		!return success
END;				! of routine vs$$check_escape


%SBTTL 'vs$$escape_done -- Check and Validate Esacpe Sequences'
GLOBAL ROUTINE vs$$escape_done (
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine checks the syntax of an escape sequence, one character at a
! time.
!
! A legal escape sequence can be best described as follows:
!	<ESC><;><32:47>...<48:126>
!	<ESC><?><32:47>...<48:126>
!	<ESC><O><32:47>...<64:126>
!	<ESC><Y><32:126><32:126>
!	<ESC><32:47>...<48:126>
!
! A legal control sequence conforms to the ANSI definition of a control
! sequence, which is "<csi> P;P;...;P F", where P;P;...;P is a series of
! parameters each of which consists of a string of decimal digits (range
! octal 60 to octal 71), separated by semicolons (octal 73),
! and F is a "final character" (range octal 100 to octal 176). As long as
! the incoming control sequence is legal, no action is taken until a final
! character is detected.
!
! <csi> means an escape character followed by a left bracket: <ESC> [
!
! FORMAL PARAMETERS:
!
	state,		!indicates where in the sequence we are
	character,	!next character in sequence to be processed
	done,		!contains 1 if we are done, 0 if still going
	status		!contains status code indicating done, bad syntax...
	)=
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!
! COMPLETION CODES:
!
!	"done" is 1 if the escape sequence is illegal, or if complete and legal
!	          0 if legal so far, but not complete
!
!	"status" is ss$_normal if the sequence is complete and legal
!	            ss$_badescape if sequence is illegal
!	            ss$_partescape if sequence is legal so far, but incomplete
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN
LITERAL
	k$_done = 1,
	k$_not_done = 0,
	k$_escape = 27,
	k$_ss3 = 143,
	k$_csi = 155;

!Say we are not done, until we know otherwise
.done = k$_not_done;
.status = ss$_partescape;

!Pick action according to current state
CASE ..state FROM vkb$k_first_state TO vkb$k_last_state OF
SET

[vkb$k_not_doing_escape]:
	!We aren't doing an escape sequence, so see if it's a new one
	SELECTONE .character OF
	  SET
	    [k$_escape] : 
		!It is, so indicate that we just got an escape
		.state = vkb$k_last_character_was_escape;
	    [k$_ss3] : 
		!It is, so indicate that we just got an ss3 (same as <ESC>O)
		BEGIN
		.done = k$_done;
		.status = ss$_normal;
		END;
	    [k$_csi] : 
		!It is, so indicate that we just got an csi (same as <ESC>[)
		.state = vkb$k_ctl_seq_prms;
	    [OTHERWISE] :
		!It's not, so indicate not doing anything
		BEGIN
		.done = k$_done;
		.status = ss$_normal;
		END;
	  TES;

[vkb$k_last_character_was_escape]:
	SELECTONE .character OF
	SET

	!State is now "doing control sequence parameters"
	[%C'[']: .state = vkb$k_ctl_seq_prms;

	!If starting with semi-colon or question mark, we know the rule
	[%C';',%C'?']: .state = vkb$k_esc_seq_int;

	!If starting with <ESC>O final character rules are different
	[%C'O']: .state = vkb$k_esco_seq_int;

	!If starting with <ESC>Y we need exactly 2 chars. in range
	[%C'Y']: .state = vkb$k_escy_seq_int;

	!If none of the above, must just be intermediate character
	[OTHERWISE]:
		BEGIN
		.state = vkb$k_esc_seq_int;
		vs$$escape_done (.state,.character,.done,.status);
		END;
	TES;

[vkb$k_esc_seq_int]:
	SELECTONE .character OF
	SET

	!If legal intermediate character, nothing changes
	[%O'40' TO %O'57']: RETURN ss$_normal;

	!Check the legal range for final character
	[%O'60' TO %O'176']:
		BEGIN
		.state = vkb$k_not_doing_escape;
		.done = k$_done;
		.status = ss$_normal;
		END;

	!Anything else is incorrect syntax
	[OTHERWISE]:
		BEGIN
		.state = vkb$k_not_doing_escape;
		.done = k$_done;
		.status = ss$_badescape;
		END;

	TES;

[vkb$k_esco_seq_int]:
	SELECTONE .character OF
	SET

	!If legal intermediate character, nothing changes
	[%O'40' TO %O'57']: RETURN ss$_normal;

	!Check the legal range for final character
	[%O'100' TO %O'176']:
		BEGIN
		.state = vkb$k_not_doing_escape;
		.done = k$_done;
		.status = ss$_normal;
		END;

	!Anything else is incorrect syntax
	[OTHERWISE]:
		BEGIN
		.state = vkb$k_not_doing_escape;
		.done = k$_done;
		.status = ss$_badescape;
		END;

	TES;

[vkb$k_escy_seq_int]:
	SELECTONE .character OF
	SET

	!If legal intermediate character, we need exactly 1 more
	[%O'40' TO %O'176']: .state = vkb$k_escy_seq_int_int;

	!Anything else is incorrect syntax
	[OTHERWISE]:
		BEGIN
		.state = vkb$k_not_doing_escape;
		.done = k$_done;
		.status = ss$_badescape;
		END;

	TES;

[vkb$k_escy_seq_int_int]:
	SELECTONE .character OF
	SET

	!Check the legal range for final character
	[%O'40' TO %O'176']:
		BEGIN
		.state = vkb$k_not_doing_escape;
		.done = k$_done;
		.status = ss$_normal;
		END;

	!Anything else is incorrect syntax
	[OTHERWISE]:
		BEGIN
		.state = vkb$k_not_doing_escape;
		.done = k$_done;
		.status = ss$_badescape;
		END;

	TES;

[vkb$k_ctl_seq_prms]:
	!We have received "<ESC>[", so check parameters for syntax
	SELECTONE .character OF
	SET

	!If legal parameter character, nothing changes
	[%O'60' TO %O'77']: RETURN ss$_normal;

	!If intermediate character, state becomes
	! "doing control sequence intermediate characters"
	[%O'40' TO %O'57']: .state = vkb$k_ctl_seq_int;

	!If legal final character, we are done, and sequence is legal
	[%O'100' TO %O'176']:
		BEGIN
		.state = vkb$k_not_doing_escape;
		.done = k$_done;
		.status = ss$_normal;
		END;

	!Anything else is incorrect syntax
	[OTHERWISE]:
		BEGIN
		.state = vkb$k_not_doing_escape;
		.done = k$_done;
		.status = ss$_badescape;
		END;

	TES;

[vkb$k_ctl_seq_int]:
	SELECTONE .character OF
	SET

	!If another intermediate character, nothing changes
	[%O'40' TO %O'57']: RETURN ss$_normal;

	!If legal final character, we are done, and sequence is legal
	[%O'100' TO %O'176']:
		BEGIN
		.state = vkb$k_not_doing_escape;
		.done = k$_done;
		.status = ss$_normal;
		END;

	!Anything else is incorrect syntax
	[OTHERWISE]:
		BEGIN
		.state = vkb$k_not_doing_escape;
		.done = k$_done;
		.status = ss$_badescape;
		END;

	TES;

TES;

RETURN ss$_normal;

END;


%SBTTL 'vs$$get_encoded_char -- Get an Encoded Character'
ROUTINE vs$$get_encoded_char(
			char,				!Character code read
			vkb_adr: REF vkb_block		!VKB address
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for reading a character from the virtual
! keyboard's "typeahead" buffer and storing the resulting encoded character
! in CHAR. This routine must run in kernel mode to read from the virtual
! keyboard's buffer (which is in system space).
!
! FORMAL PARAMETERS:
!
!	CHAR     : Address for encoded character
!			(output parameter)
!	VKB_ADR  : Address of virtual keyboard block
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	TRUE (= 1) : Ring buffer NOT empty - encoded character returned
!	FALSE (= 0): Ring buffer empty - NO encoded character returned
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	This routine runs in kernel mode (at IPL 0) and assumes that the first
! word of the ring buffer points before the next available character and that
! the VKB address is valid.
!
!--
BEGIN

LOCAL
	marked_for_delete,			!"Boolean" indicator
	encoded_word: REF BLOCK[0,BYTE],	!To single out bits in word
	rb_adr: REF VECTOR[0,WORD];		!Ring buffer address

	rb_adr = .vkb_adr[vs$vkb_a_ring_buffer];
	encoded_word = .char;
!
! Loop until either typeahead buffer has been emptied or character found
! which has not been marked for deletion
!
	marked_for_delete = true;
	WHILE .marked_for_delete DO
	  BEGIN
!
! If the ring buffer is empty, just return the indication
!
	    IF .rb_adr[0] EQL .rb_adr[1] THEN
	      RETURN false;
!
! Update the ring buffer head pointer to point to the next available
! character
!
	    IF ((.rb_adr[0] + 3) * 2) EQL .vkb_adr[vs$vkb_l_buffer_size] THEN
	      rb_adr[0] = 0
	    ELSE
	      rb_adr[0] = .rb_adr[0] + 1;
!
	    vkb_adr[vs$vkb_l_unsolicit_ptr] = .rb_adr[0];
!
! MOVW from address currently pointed to by head of ring buffer into
! address specified by calling routine
!
	    .char = .rb_adr[2 + .rb_adr[0]];
	    marked_for_delete = .encoded_word[vb$v_char_del];
	  END;			!While character marked for delete
!
	RETURN true;		!return success indication
END;				! of routine vs$$get_encoded_char


%SBTTL 'vs$$preview_typeahead -- Preview Next Typeahead Character'
ROUTINE vs$$preview_typeahead(
			char,				!Character code read
			vkb_adr: REF vkb_block		!VKB address
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for returning a copy of the last
! character put into the typeahead buffer for the specified VKB's ring buffer.
!
! FORMAL PARAMETERS:
!
!	CHAR     : Encoded character
!			(output parameter)
!	VKB_ADR  : Address of virtual keyboard block
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	TRUE (= 1) : Ring buffer NOT empty - encoded character returned
!	FALSE (= 0): Ring buffer empty - NO encoded character returned
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	This routine runs in kernel mode (at IPL 0) and assumes that the first
! word of the ring buffer points before the next available character to be
! read. This routine assumes that the VKB block is valid.
!
!--
BEGIN

LOCAL
	rb_adr: REF VECTOR[0,WORD];		!Ring buffer address

	rb_adr = .vkb_adr[vs$vkb_a_ring_buffer];
!
! If the ring buffer is empty, just return the indication
!
	IF .rb_adr[0] EQL .rb_adr[1] THEN
	  RETURN 0;
		
!
! Check to see if unsolicited pointer is caught up with the tail 
! pointer
!	
!
! If typeahead is full then pointers do not get changed but we must look
! at the current character, so return 3.  
!
	IF .vkb_adr[vs$vkb_l_unsolicit_ptr] EQL .rb_adr [1] THEN 

	  IF ((.rb_adr[1] + 3) * 2) GTR 
	       .vkb_adr[vs$vkb_l_buffer_size] THEN
	    IF .rb_adr[0] NEQ 0 THEN
	      RETURN 0

	    ELSE 	! Type ahead is full
	      BEGIN
!
! Don't go through native graphics queues at ast level.  Post request
! for later processing at non-ast level.
!
		vs$$post_ast_request (vsta$$kbrd_sound_bell,
		    .vkb_adr[vs$vkb_w_pkb_chan]);
		.char = .rb_adr[2 + .vkb_adr[vs$vkb_l_unsolicit_ptr]];
		RETURN 3;
	      END
	  ELSE
	    IF .rb_adr[1] + 1 NEQ .rb_adr[0] THEN
	      RETURN 0

	    ELSE	! Type ahead is full
	      BEGIN
!
! Don't go through native graphics queues at ast level.  Post request
! for later processing at non-ast level.
!
		vs$$post_ast_request (vsta$$kbrd_sound_bell,
		    .vkb_adr[vs$vkb_w_pkb_chan]);
		.char = .rb_adr[2 + .vkb_adr[vs$vkb_l_unsolicit_ptr]];
		RETURN 3;
	      END
	ELSE		! Advance the unsolicited pointer

	  IF ((.vkb_adr[vs$vkb_l_unsolicit_ptr] + 3) * 2) EQL
		.vkb_adr[vs$vkb_l_buffer_size] THEN
	    vkb_adr[vs$vkb_l_unsolicit_ptr] = 0
	  ELSE
	    vkb_adr[vs$vkb_l_unsolicit_ptr] =
		.vkb_adr[vs$vkb_l_unsolicit_ptr] + 1;
!
!
! MOVW from address currently pointed to by unsolicited input pointer into
! address specified by calling routine
!
	.char = .rb_adr[2 + .vkb_adr[vs$vkb_l_unsolicit_ptr]];
!
	RETURN 1;		!return success indication
END;				! of routine vs$$preview_typeahead


%SBTTL 'vs$$delete_typeahead -- Delete Last Typeahead Character'
ROUTINE vs$$delete_typeahead(
			vkb_adr: REF vkb_block	!VKB address
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for deleting the last
! character put into the typeahead buffer for the specified VKB's ring buffer.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR  : Address of virtual keyboard block
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	SS$_NORMAL:	Normal successful completion
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	This typeahead character is "marked" for deletion and will be ignored
! when processed during a subsequent read.
!
!--
BEGIN

LOCAL
	index,					!Index to "current" character
	encoded_word: REF BLOCK[0,BYTE],	!To refer to individual bits
	rb_adr: REF VECTOR[0,WORD];		!Ring buffer address

	rb_adr = .vkb_adr[vs$vkb_a_ring_buffer];
!
! If the head pointer and unsolicited input pointer are equal, then we are
! already caught up
!
	IF .rb_adr[0] EQL .vkb_adr[vs$vkb_l_unsolicit_ptr] THEN
	  RETURN SS$_NORMAL;
!
! Calculate the index into the ring buffer for the last unsolicited character
!
!	IF .vkb_adr[vs$vkb_l_unsolicit_ptr] EQL 0 THEN
!	  index = (.vkb_adr[vs$vkb_l_buffer_size] / 2) - 3
!	ELSE
!	  index = .vkb_adr[vs$vkb_l_unsolicit_ptr] - 1;
!
! Mark this unencoded character for deletion
!
!	encoded_word = rb_adr[2 + .index];
!
	encoded_word = rb_adr[2 + .vkb_adr[vs$vkb_l_unsolicit_ptr]];
	encoded_word[vb$v_char_del] = true;
!
	RETURN SS$_NORMAL;	!return success indication
END;				! of routine vs$$delete_typeahead


%SBTTL 'vs$$end_of_read -- Determine if Character Terminates Read'
ROUTINE vs$$end_of_read(
			vkb_adr: REF vkb_block,		!VKB address
			ascii_word: REF vkb_ascii_word,	!ASCII word
			term_flag			!Terminator indicator
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for determining if this character will
! terminate the read operation either because the maximum number of
! characters has already been read or because there is a match within the
! specified break table.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!				(input parameter)
!	ASCII_WORD    : Address of ascii word
!				(input parameter)
!	TERM_FLAG     : Address for terminator indicator (break table match)
!				(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	true (= 1)	=> Character satisfied read request
!	false (= 0)	=> Character DID NOT satisfy read request
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	rr_adr: REF vkb_read_request,		!Current read context
	break_table: REF BITVECTOR,		!Read request break table addr.
	status;					!To contain return status value

	rr_adr = .vkb_adr[vs$vkb_a_current_read];
!
! Use break table specified with read request and determine if character
! specified constitutes an end-of-read condition (if its not a "special"
! character or an unencoded keyboard)
!
	IF (.vkb_adr[vs$vkb_l_trans_table] NEQ vsta$k_tt_unencoded) AND
	   ( NOT .ascii_word[vs$aw_v_special]) THEN
	  BEGIN
	    break_table = .rr_adr[vs$rr_a_break_table];
!
	    IF (.term_flag = .break_table[.ascii_word[vs$aw_b_char_code]]) THEN
	      BEGIN
	        rr_adr[vs$rr_w_terminator] = .ascii_word[vs$aw_b_char_code];
	        rr_adr[vs$rr_w_terminator_size] = .rr_adr[vs$rr_b_buffer_inc];
		RETURN true;
	      END;
	  END;
!
! Compare the character count to the user's buffer size
!
	.term_flag = false;
	IF (.rr_adr[vs$rr_l_buffer_ptr] + .rr_adr[vs$rr_b_buffer_inc]) GTR
	    .rr_adr[vs$rr_l_buffer_size] THEN
	  RETURN true;
!
	RETURN false;		!Return read-not-done indication
!
END;				! of routine vs$$end_of_read


%SBTTL 'vs$$deactivate_current_vkb -- Deactivate Virtual Keyboard'
ROUTINE vs$$deactivate_current_vkb(
			pkb_chan,		!Channel to physical keyboard
			old_level		!Previous VKB level 1/2 state
					): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for finding the virtual keyboard
! which is active or current on the physical keyboard specified by channel
! (if any) and deactivating it.
!
! FORMAL PARAMETERS:
!
!	PKB_CHAN    : Word Physical Keyboard channel number
!			(input parameter)
!	OLD_LEVEL   : Address for previous VKB level 1/2 state
!			(output parameter)
!
!
! IMPLICIT INPUTS:
!
!	vs$vkb_list    : Queue head pointer to known virtual keyboards
!	last_vkb_level : "Boolean" last activated VKB level 1/2 indicator
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	vkb_ptr: REF vkb_block;			!Ptr to arbitrary VKB

!
! Search through the list of known virtual keyboards for the physical keyboard
! channel number passed as a parameter and clear the "current" bit in its
! state if current.
!
	vkb_ptr = .vs$vkb_list[0];
	WHILE (.vkb_ptr NEQ vs$vkb_list[0]) DO
	  BEGIN
	    IF .vkb_ptr[vs$vkb_w_pkb_chan] EQL .pkb_chan THEN
	      IF .vkb_ptr[vs$vkb_v_current] THEN
		BEGIN
		  vkb_ptr[vs$vkb_v_current] = false;
		  .old_level = .vkb_ptr[vs$vkb_v_level];
		  RETURN;
		END;
	    vkb_ptr = .vkb_ptr[vs$vkb_a_next_ptr];
	  END;
	.old_level = .last_vkb_level;
!
	RETURN;			!return
END;				! of routine vs$$deactivate_current_vkb


%SBTTL 'vs$$vkb_loadtt -- Load New Translation Table for Terminals'
ROUTINE vs$$vkb_loadtt(
			vkb_adr: REF vkb_block,		!VKB address
			trans_table			!Translation table ID
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for loading a new translation table
! for VKBs associated with emulated terminals. This translation will be
! used for all input interpreted by the terminal port driver until further
! notice.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR	      : Address of Virtual Keyboard Block
!				(input parameter)
!	TRANS_TABLE   : Longword translation table ID
!				(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	TRANSLATION_TABLE : Longword current translation table loaded
!
! IMPLICIT OUTPUTS:
!
!	TRANSLATION_TABLE : Longword current translation table loaded
!
! ROUTINE VALUE
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN
LOCAL
	tt_list: VECTOR[vs$k_max_mode_tables];

!
! Make the old symbol table the current symbol table.  This is to make
! setting NRC and loading translation tables order independent
!
	vtem$al_vkb_symbol_vecs[.trans_table] = 
		.vtem$al_vkb_symbol_vecs[.vkb_adr[vs$vkb_l_trans_table]];

!
! Set the translation table ID and if this isn't an emulated terminal,
! we're done
!
	vkb_adr[vs$vkb_l_trans_table] = .trans_table;
	IF .vkb_adr[vs$vkb_l_vd_id] EQL 0 THEN
	  RETURN SS$_NORMAL;
!
! If this is the currently loaded translation table, we're done
!
	IF .trans_table EQL .translation_table THEN
	  RETURN SS$_NORMAL;
!
! If the new translation table is for up/down unencoded, its simple
!
	translation_table = .trans_table;
	IF .trans_table EQL vsta$k_tt_unencoded THEN
	  BEGIN
	    $QIO(
		EFN  = .load_ef,
		CHAN = .vs$gw_vd_chan,
		FUNC = IO$_VSTAHI or IO$M_VD_TRANS_TABLE,
		P4   = .trans_table);
	    RETURN SS$_NORMAL;
	  END;
!
! Gotta load the new translation table for the terminal port driver
!
	INCR index FROM 0 TO (vs$k_max_mode_tables - 1) DO
	  tt_list[.index] = .vtem$al_vkb_trans_vecs[.trans_table,.index] -
			.vtem$al_vkb_trans_vecs[.trans_table,0];
	$QIO(
		EFN  = .load_ef,
		CHAN = .vs$gw_vd_chan,
		FUNC = IO$_VSTAHI or IO$M_VD_TRANS_TABLE,
		P1   = .vtem$al_vkb_trans_vecs[.trans_table,0],
		P2   = .vtem$al_vkb_trans_size[.trans_table],
		P3   = tt_list,
		P4   = .trans_table);
!
! And the new symbol table which goes along with this translation table
!
	INCR index FROM 0 TO (vs$k_max_mode_tables - 1) DO
	  tt_list[.index] = 0;
	$QIO(
		EFN  = .load_ef,
		CHAN = .vs$gw_vd_chan,
		FUNC = IO$_VSTAHI or IO$M_VD_SYMBOL_TABLE,
		P1   = .vtem$al_vkb_symbol_vecs[.trans_table],
		P2   = .vtem$al_vkb_symbol_size[.trans_table],
		P3   = tt_list);
!
	RETURN SS$_NORMAL;	! Return success
END;				! of routine vs$$vkb_loadtt


%SBTTL 'vs$$vkb_found -- Find a Virtual Keyboard by ID'
ROUTINE vs$$vkb_found(
			vkb_id,			!Virtual Keyboard ID
			vkb_adr			!Virtual Keyboard Address
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for finding the virtual keyboard data
! block by ID and returning its address if found.
!
! FORMAL PARAMETERS:
!
!	VKB_ID  : Longword virtual keyboard ID (same as a pasteboard ID)
!			(input parameter)
!	VKB_ADR : Address to contain address of vkb data block
!			(output parameter)
!
!
! IMPLICIT INPUTS:
!
!	vs$vkb_list : Queue head pointer to known virtual keyboards
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	vkb_ptr: REF vkb_block;			!Ptr to arbitrary VKB

!
! Search through the list of known virtual keyboards for the virtual keyboard
! (or pasteboard ID) passed as a parameter and return its address if found.
!
	vkb_ptr = .vs$vkb_list[0];
	WHILE (.vkb_ptr NEQ vs$vkb_list[0]) DO
	  IF .vkb_ptr[vs$vkb_l_id] EQL .vkb_id THEN
	    BEGIN
	      .vkb_adr = .vkb_ptr;
	      RETURN true;
	    END
	  ELSE
	    vkb_ptr = .vkb_ptr[vs$vkb_a_next_ptr];
!
	RETURN false;		!return whether or not vkb was found
END;				! of routine vs$$vkb_found


%SBTTL 'vs$$get_emulator_vkb -- Find a Virtual Keyboard by VD_ID'
GLOBAL ROUTINE vs$$get_emulator_vkb(
			vd_id,			!Virtual Display ID
			vkb_id			!Virtual Keyboard ID Address
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for finding the virtual keyboard ID
! by its attached VD_ID and returning it if found.
!
! FORMAL PARAMETERS:
!
!	VD_ID  : Longword virtual display ID
!			(input parameter)
!	VKB_ID : Address to contain virtual keyboard ID which is attached
!			(output parameter)
!
!
! IMPLICIT INPUTS:
!
!	vs$vkb_list : Queue head pointer to known virtual keyboards
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
! COMPLETION CODES:
!
!	SS$_NORMAL : Found a VKB which is attached to the specified VD_ID
!	SS$_NOSUCHDEV : Could not find a VKB which is attached to the VD_ID
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

EXTERNAL
	vsta$_nosuchvkb;			!No such virtual keyboard
LOCAL
	vkb_ptr: REF vkb_block;			!Ptr to arbitrary VKB

!
! Search through the list of known virtual keyboards for the virtual keyboard
! (or pasteboard ID) passed as a parameter and return its address if found.
!
	vkb_ptr = .vs$vkb_list[0];
	WHILE (.vkb_ptr NEQ vs$vkb_list[0]) DO
	  IF .vkb_ptr[vs$vkb_l_vd_id] EQL .vd_id THEN
	    BEGIN
	      .vkb_id = .vkb_ptr[vs$vkb_l_id];
	      RETURN SS$_NORMAL;
	    END
	  ELSE
	    vkb_ptr = .vkb_ptr[vs$vkb_a_next_ptr];
!
	RETURN vsta$_nosuchvkb;	!return VKB was not found
END;				! of routine vs$$get_emulator_vkb



%SBTTL 'vs$$get_ring_buffer -- Allocate a VKB Ring Buffer'
ROUTINE vs$$get_ring_buffer(
			ring_adr: REF vkb_ring_buffer,
						!Address for ring buffer
			ring_size		!Bytes allocated for ring
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for allocating a virtual keyboard ring
! buffer in non-paged pool for use by the virtual keyboard and physical
! keyboard drivers. The ring buffer looks as follows:
!			____________________
!			!      flink       !
!			--------------------
!			!      blink       !
!			--------------------
!			!   !type!  size   !
!			--------------------
!			!  tail  !  head   !
!			--------------------
!			!      buffer      !
!			!		   !
!			!		   !
!			--------------------
!	The first three longwords are used only for initialization and
! deallocation. Only the size and start address of the actual ring buffer are
! passed back to the caller (the word VECTOR beginning with head). Since each
! word generated by the keyboard driver will result in 1 8-bit ascii character,
! the buffer itself will have 2*TTY$GW_TYPAHDSZ bytes allocated to be
! consistent with the typeahead buffer size used by existing VMS terminal
! drivers.
!
! FORMAL PARAMETERS:
!
!	RING_ADR	: Address to contain ring buffer address
!				(output parameter)
!	RING_SIZE       : Address to contain ring buffer size
!				(output parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	This routine runs in kernel mode (IPL 0)
!
!--
BEGIN

LOCAL
	size,					!Bytes actually allocated
	rb_adr: REF vkb_ring_buffer,		!Ring buffer address
	ring: REF VECTOR[0,WORD],		!Actual ring (head,tail,buffer)
	status;					!Return status value

!
! Allocate a block out of non-paged pool for entire ring buffer
!
	IF (NOT (status = exe$alononpaged(
				(.TTY$GW_TYPAHDSZ * 2) + 16;
				size,
				rb_adr))) THEN
	  $return_error(vsta$_nopoolforrb);
!
	.ring_size = MAX(0,.size - 12);
!
! Initialize the pointers and size fields
!
	rb_adr[vs$rb_a_flink] = rb_adr[vs$rb_a_flink];
	rb_adr[vs$rb_a_blink] = rb_adr[vs$rb_a_flink];
	rb_adr[vs$rb_w_size] = .size;
	rb_adr[vs$rb_w_type] = 0;
!
	ring = rb_adr[vs$rb_a_ring_buffer];
	ring[0] = ring[1] = 0;
!
	.ring_adr = rb_adr[vs$rb_a_ring_buffer];
!
	RETURN SS$_NORMAL;	!return status value
END;				! of routine vs$$get_ring_buffer


%SBTTL 'vs$$release_ring_buffer -- Deallocate a VKB Ring Buffer'
GLOBAL ROUTINE vs$$release_ring_buffer(
			vkb_adr: REF vkb_block	!Address of VKB
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for deallocating a virtual keyboard ring
! buffer in non-paged pool for use by the virtual keyboard and physical
! keyboard drivers.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR : Address of virtual keyboard data base
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!	NONE
!
! COMPLETION CODES:
!
!	SS$_NORMAL (or you won't know about it)
!
! SIDE EFFECTS:
!
!	This routine runs in kernel mode (IPL 0)
!
!--
BEGIN

!
! If this ring buffer belongs to part of a UCB, don't
! deallocate it!
!
	IF .vkb_adr[vs$vkb_l_vd_id] NEQ 0 THEN
	  RETURN SS$_NORMAL;
!
! If there is a typeahead buffer there, let the system have the memory back
!
	IF .vkb_adr[vs$vkb_a_ring_buffer] NEQ 0 THEN
	  exe$deanonpaged (.vkb_adr[vs$vkb_a_ring_buffer] - 12);
!
	RETURN SS$_NORMAL;	!return
END;				! of routine vs$$release_ring_buffer


%SBTTL 'vs$$free_vkb -- Free Memory of a Virtual Keyboard'
GLOBAL ROUTINE vs$$free_vkb(
		vkb_adr: REF vkb_block	!Virtual Keyboard block address
					): NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for freeing all the memory (heap store and
! non-paged pool) occupied by a virtual keyboard block.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR : Address of a virtual keyboard block being deleted
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
BEGIN

LOCAL
	rr_adr: REF vkb_read_request,		!Read request context of VKB
	arg_list: VECTOR[2];			!$CMKRNL parameter block

!
! If there is a typeahead buffer allocated, free up the non-paged pool
!
	IF .vkb_adr[vs$vkb_a_ring_buffer] NEQ 0 THEN
	  BEGIN
	    arg_list[0] = 1;
	    arg_list[1] = .vkb_adr;
!
	    $CMKRNL(
		ROUTIN = vs$$release_ring_buffer,
		ARGLST = arg_list[0]);
	  END;
!
! Free up the heap store occupied by the virtual keyboard read context,
! translation table, and special character translation table, ignoring any
! bad return status values, and then the VKB itself.
!
	IF .vkb_adr[vs$vkb_a_break_table] NEQ 0 THEN
	  vs$$acp_free_vm (UPLIT (vs$k_break_table_size),
					vkb_adr[vs$vkb_a_break_table]);
!
	rr_adr = .vkb_adr[vs$vkb_a_current_read];
	IF .rr_adr NEQ 0 THEN
	  BEGIN
	    IF .rr_adr[vs$rr_a_break_table] NEQ 0 THEN
	      vs$$acp_free_vm (UPLIT (vs$k_break_table_size),
					rr_adr[vs$rr_a_break_table]);
!
	    vs$$acp_free_vm (UPLIT (vs$rr_k_block_size),
					vkb_adr[vs$vkb_a_current_read]);
	  END;
!
	vs$$acp_free_vm (UPLIT (vs$vkb_k_block_size),
					vkb_adr);
!
	RETURN;			!return success
END;				! of routine vs$$free_vkb


%SBTTL 'vs$$flush_asts -- Flush All VKB ASTs'
ROUTINE vs$$flush_asts(
		vkb_adr: REF vkb_block		!VKB block address
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for flushing all the attention and
! control AST's for a virtual keyboard. For now, only virtual keyboards which
! have output devices associated with them can be flushed.
!
! FORMAL PARAMETERS:
!
!	VKB_ADR   : Virtual Keyboard block address
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	This routine must be called from kernel mode.
!
!--
BEGIN

LOCAL
	pid,					!Temp. storage for PID
	pcb_adr,				!Process control block address
	irp_adr: REF irp_block,			!I/O request packet address
	ucb_adr: REF vd_ucb_block;		!Unit control block address
!
! If there is no output device, return
!
	IF (.vkb_adr[vs$vkb_l_vd_id] EQL 0) THEN
	  RETURN SS$_NORMAL;
!
	irp_adr = .vs$a_irp;
	ucb_adr = .irp_adr[IRP$L_UCB];
!
! Get the PCB address of the process issuing the request
!
	pid = .irp_adr[IRP$L_PID];
	IF NOT vs$$acp_find_pcb(
				pid,
				0,
				pcb_adr) then
	  RETURN SS$_NORMAL;
!
! Flush the control_c and control_y attention AST lists
!
	IF .ucb_adr[UCB$L_TL_CTRLC] NEQ 0 THEN
	  com$flushattns(
			.pcb_adr,
			.ucb_adr,
			.irp_adr[IRP$W_CHAN],
			ucb_adr[UCB$L_TL_CTRLC]);
!
	IF .ucb_adr[UCB$L_TL_CTRLY] NEQ 0 THEN
	  com$flushattns(
			.pcb_adr,
			.ucb_adr,
			.irp_adr[IRP$W_CHAN],
			ucb_adr[UCB$L_TL_CTRLY]);
!
! Flush the out-of-band control AST list
!
	IF .ucb_adr[UCB$L_TL_OUTBAND] NEQ 0 THEN
	  com$flushctrls(
			ucb_adr[UCB$L_TL_OUTBAND],
			.pcb_adr,
			.ucb_adr,
			.irp_adr[IRP$W_CHAN],
			ucb_adr[UCB$L_TL_BANDQUE]);
!
	RETURN SS$_NORMAL;	!return
END;				! of routine vs$$flush_asts


%SBTTL 'vs$$kmode_move -- Kernel Mode Byte Copy'
ROUTINE vs$$kmode_move(
			size,			!Number of bytes to copy
			source_adr,		!Source address
			dest_adr		!Destination address
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is responsible for transfering the specified number of
! bytes from the source address to the destination address. If either of the
! two buffers is in system space, then this routine must be called from kernel
! mode. The size specified can be no larger than the maximum allowed by
! the VAX MOVC3 instruction.
!
! FORMAL PARAMETERS:
!
!	SIZE	   : Number of bytes to copy
!			(input parameter)
!	SOURCE_ADR : Source address
!			(input parameter)
!	DEST_ADR   : Destination address
!			(input parameter)
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	If this routine is called from kernel mode and an access violation
! occurs during the copy, a system crash is inevitable.
!
!--
BEGIN

	CH$MOVE(
		.size,
		.source_adr,
		.dest_adr);
!
	RETURN SS$_NORMAL;	!return
END;				! of routine vs$$kmode_move


END
ELUDOM

MODULE VS$VTEM_100 (
		IDENT = 'VT100_EMULATOR',
		ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = GENERAL)) =
BEGIN
!++
! FACILITY: VAXstation software (VS)
!
! Virtual Terminal Emulator (VTEM) for VT100
!
! ABSTRACT:
!
! This module contains all the routines for emulating 
! the operation of a VT100 terminal in the context of a VAX workstation running
! the associated workstation display software; specifically, an
! implementation of the System Display Architecture.
!

! Data tables are maintained on a per-terminal basis. That is, each
! emulated VT100 has a region of storage devoted to it which contains all
! permanent and temorary states, modes, settings, and buffers. No data,
! except for local counters (which use registers) and literals, is kept in
! the body of the code. Therefore the code itself is re-entrant, and could
! reside in shared memory. Only individual VT100's are not re-enterable.
! ENVIRONMENT:
!
! VAXstation: 780, 750 or 730 running VMS with at least one ONYX or OPAL 
! graphics subsystem.
!
!--
!
! TABLE OF CONTENTS:
!

!
! INCLUDE FILES:
!
LIBRARY 'VSTA$LIBRARY:LIBMACROS';	!Symbols like $log_error_and_return
LIBRARY 'VSTA$LIBRARY:VSVTEM100';	!Defines data structure for vt100 data table
LIBRARY 'VSTA$LIBRARY:VSACPDEF';	!Defines data structures for ACP
LIBRARY 'VSTA$LIBRARY:TXTSYM';		!Defines text symbols such as rendition bits
LIBRARY 'VSTA$LIBRARY:VSTATERM';	!Get terminal symbols
LIBRARY 'VSTA$LIBRARY:VSTAGBL';		!Keyboard mode bits + constants
LIBRARY 'SYS$LIBRARY:STARLET';		!Need this for dynamic memory allocation
LIBRARY 'VSTA$LIBRARY:VSVDSVD';
LIBRARY 'VSTA$LIBRARY:VSTAMACS';
LIBRARY 'VSTA$LIBRARY:VSTADEF';
!
! PSECT Definitions
!
$vsta_psect;
!
! Set up some internal linkages for speed
!
LINKAGE
!	 VT_LINKAGE = JSB (REGISTER = 2, REGISTER = 3, STANDARD)
	 VT_LINKAGE = CALL (STANDARD)
	;

FORWARD ROUTINE
	 vsta$$vt100_settings_exist	!announcement of settings existence
	,vs$$vtem_vt100_create:		!GLOBAL routine to create a VT100
	,vs$$vtem_vt100_delete:		!GLOBAL routine to delete a VT100
	,vsta$$vtem_vt100_set_chars:	!GLOBAL routine to set vt100 chars
	,vsta$$vtem_vt100_get_chars:	!GLOBAL routine to get vt100 chars
	,vs$$vtem_vt100_write:		!GLOBAL routine to write to a VT100
	,vsta$$vt100_reset		!Global routine to reset a vt100

	,find_vt100			: VT_LINKAGE 		!Internal routine - locates data block of vt100
	,reset_vt100			: VT_LINKAGE NOVALUE	!Internal routine - resets all modes etc to "power-up" settings 
	,initialize_vt100		: VT_LINKAGE NOVALUE	!Internal routine - sets up initial table
	,process_write			: VT_LINKAGE NOVALUE	!Internal routine - loops through write characters and decides what to do
	,process_g_sets			: VT_LINKAGE NOVALUE
	,process_vt52_sequence		: VT_LINKAGE NOVALUE	!Internal routine - decodes vt52 escape sequences
	,process_vt102_del_char 	: VT_LINKAGE NOVALUE	!Internal routine - del n char from line
	,process_vt102_insert_line	: VT_LINKAGE NOVALUE	!Internal routine - insert n lines
	,process_vt102_del_line		: VT_LINKAGE NOVALUE	!Internal routine - del n lines
	,process_control_character	: VT_LINKAGE NOVALUE	!Internal routine - handles ascii control chars (octal 0 to 37)
	,flush_backlog			: VT_LINKAGE NOVALUE	!Internal routine - sends accumulated printable text to SDA write routine
	,process_line_feed		: VT_LINKAGE NOVALUE	!Internal routine - going down one line
	,process_line_feeds		: VT_LINKAGE NOVALUE	!Internal routine - going down one line 
	,process_up_line		: VT_LINKAGE NOVALUE	!Internal routine - reverse line feed
	,process_up_lines		: VT_LINKAGE NOVALUE	!Internal routine - reverse line feed
	,process_newline		: VT_LINKAGE NOVALUE	!Internal routine - goes down a line and to column one
	,process_printable_character	: VT_LINKAGE NOVALUE	!Internal routine - handles ordinary displayable text
	,process_escape_sequence	: VT_LINKAGE NOVALUE	!Internal routine - handles characters that are part of an escape sequence
	,process_control_sequence	: VT_LINKAGE NOVALUE	!Internal routine - handles control sequences (<ESC> [ P;P;P; ... F)
	,process_soft_reset		: VT_LINKAGE NOVALUE
	,erase_all_chars		: VT_LINKAGE		!Internal routine - clear screen
	,erase_characters		: VT_LINKAGE		!Internal routine - handles various erase situations
	,process_control_parameters	: VT_LINKAGE NOVALUE	!Internal routine - handles parameters (... P;P;P ...)
	,process_dec_private_sequence	: VT_LINKAGE NOVALUE	!Internal routine - handles dec sequences (<ESC> [ ? P;P;P; ... F)
	,vsta$$set_vt100_dark			! Set background to dark
	,vsta$$set_vt100_light			! Set background light
	,vsta$$set_vt100_ansi			! Set vt100 into ansi mode
	,vsta$$set_vt100_nrc			! Set nrc
	,vsta$$set_vt100_vt52			! Set vt100 into vt52 mode
	,vsta$$set_vt100_wrap			! Set vt100 into wrap mode
	,vsta$$set_vt100_nowrap			! Set vt100 to not wrap
	,vsta$$set_vt100_newline		! Set vt100 for auto-newline
	,vsta$$set_vt100_oldline		! No auto-newline
	,vsta$$set_vt100_answer			! Set answerback message
	,vsta$$set_vt100_tab			! Set tab at specified column
	,vsta$$clear_vt100_tab			! Clear tab at specified column
	,vsta$$set_vt100_level			! Set vt100 conformance level
	,vsta$$set_vt100_kbd_change		! Update nrc upon keyboard chnge
	,vsta$$get_vt100_backcolor		! Get Vt100 background color
! new
	,VT$$DT_CLEAR_VT100		! Clear vt100 data base
	,VT$$DT_CLEAR_SCREEN		! Clear vt100 virtual display
	,VT$$DT_CLEAR_SCREEN_RC		! Color VD rectangle
	,VT$$DT_REDISPLAY_SCREEN	! Replay vt100 data
	,vt$$dt_redisplay_vd		! GLOBAL redisplay screen
	,VT$$DT_COMPLETION_ROUTINE	! Clean up after graphics operation
	,VT$$DT_INIT_FONTS		! Initialize all vt100 fonts
	,VT$$DT_GET_FONT		! Initialize all vt100 fonts
	,VT$$DT_SCROLL_SCREEN		! Scrolls virtual display up or down
	,VT$$DT_SCROLL_VT100		! Scrolls database up or down
	,VT$$DT_DISPLAY_SCREEN_line	! Replay vt100 data
	,VT$$DT_display_VT100_line	! add a line of text to vt100 database
	,VT$$DT_erase_chars_VT100	! Clear vt100 data base for a specified range
	,VT$$DT_erase_chars_SCREEN	! Clear vt100 virtual display for specified range
	,VT$$DT_delete_chars_VT102	! does vt102 delete n chars
	,VT$$DT_delete_chars_screen	! does vt102 delete n chars
	,VT$$DT_DECALN_VT100		! Performs decaln test
	,VT$$DT_SET_VT100_LINE_ATT	! Set line attribute in database
	,VT$$DT_INSERT_CHARS_VT102	! do vt102 insert char
	;

EXTERNAL ROUTINE!S
	!
	!  ACP control and SDA control external references
	!
	 vs$$acp_get_vm
	,vs$$acp_free_vm
	,vs$$vds_create_pb
	,vs$$vds_set_pb_char
	,vs$$vds_create_window
	,vs$$vds_paste_vd_to_pb
	,vs$$vds_delete_pb
	,vs$$vds_create_vd
	,vs$$vds_delete_vd
	,vs$$vds_redisplay_vd
	,vs$$vds_get_vd_char
	,vs$$vds_set_vd_char
	,vs$$vds_invert
	,vs$$vds_vd_set_xon_xoff
	,vs$$vds_clear_text
	,vs$$vds_disable_vd
	,vs$$vds_enable_vd
	,vs$$vds_create_term_window
	,vs$$vkb_set_nrc
	,vsta$$emul_create_bezel
	,vsta$$srv_term_created
	,vs$$set_vkb_output
	,vs$$set_vkb_char
	,vsta$$error
	,vsta$$error_logger
	,vsta$$ts_update_settings
	,vsta$$kbrd_sound_bell
	,vsta$$kernel_call
	,vs$$acp_answerback
	,vs$$set_vkb_trans_table	!needed for vt100 reset
	,VSTA$$VDS_GET_VD_RC_LISTS
	,VSTA$$VDS_COPY_VD_RC_LISTS
	,VSTA$$VDS_save_VD_RC_LISTS
	,VSTA$$VDS_store_VD_RC_LISTS
	,VSTA$$RCS_INTER_LIST_WITH_LISTS
	,VS$$VDS_VD_POINTER
	,VS$$TXT_GET_FONT_ADDRESS
	,FINDFIB
	,FIBDEREFERENCE
	;


EXTERNAL ROUTINE!S  DEFINE EXTERNAL VT100 ROUTINES HERE
	 vt$$cur_start_cursor
	,vt$$cur_stop_cursor
	,vt$$cur_vkb_translator
	;


EXTERNAL
	 srv$gl_answerback_len
	,srv$gl_answerback_str : vector [,byte]
	,srv$gl_vt100_dark_bg
	,srv$gl_vt100_ansi
	,srv$gl_vt_margin_bell
	,srv$gl_vt_wrap
	,srv$gl_vt_newline
	,srv$gl_vt_level
	,vs$gl_pid		!Process id of creator.
	,vs$gl_acp_pid		!Pid of us.

	,srv$gl_kbd_set		! profile kbd value	       	
	,srv$gl_vt_legend	! profile legend value		
	,vsta$gl_keyboard	! --> selected kbd & legend type
	,VSTA$A_FRAME_BUFFER	: vector [,long]
	,VS$GW_VBCHAN
	;

EXTERNAL LITERAL
	 prof$k_vt_level1
	,prof$k_vt_level2
	,prof$k_7bit_nrc
	,prof$k_kbd_ca
	,prof$k_kbd_cb
	,prof$k_kbd_cc
	,prof$k_kbd_cd
	,prof$k_kbd_ce
	,prof$k_kbd_cf
	,prof$k_kbd_cg
	,prof$k_kbd_ch
	,prof$k_kbd_ci
	,prof$k_kbd_ck
	,prof$k_kbd_cl
	,prof$k_kbd_cm
	,prof$k_kbd_cn
	,prof$k_kbd_cp
	,prof$k_kbd_cs
	;

EXTERNAL
	 vs$gw_vbchan
	;



! Built-in MACRO instructions for queue operations:
BUILTIN
	 insque
	,remque
	;

!
! OWN STORAGE:
!
OWN	
	 vt100_q_head:	VECTOR [2,LONG]
			INITIAL (REP 2 OF (vt100_q_head [0]))
	,blanks:	
		VECTOR [vt$k_maximum_columns,BYTE]
		INITIAL (BYTE(REP vt$k_maximum_columns OF (' ')))
	;

! define some names for typefaces we use
BIND
	 single_width = %ASCID 'Kilter'
	,double_width = %ASCID 'Kilter_double_width'
	,top_half = %ASCID 'VT100_top_half'
	,bottom_half = %ASCID 'VT100_bottom_half'
	;

!
!			$LITERAL SECTION$
!
!
!  Define per-character-attribute bits
!
literal		VT$M_BLINK	= %X'01';
literal		VT$M_BOLD	= %X'02';
literal		VT$M_UNDERLINE	= %X'04';
literal		VT$M_REVERSE	= %X'08';
literal		VT$M_BLANK	= %X'10';
literal		VT$M_ERASE	= %X'20';

!
!  Define font indexes for character renditions
!
literal		VT$K_BOLD_FONT_INDEX = 1;
literal		VT$K_BLINK_FONT_INDEX = 2;
literal		VT$K_UNDER_FONT_INDEX = 0;
literal		VT$K_REVERSE_FONT_INDEX = 0;

literal		vt$k_graphics = 1;
!
!  Define font indexes for line renditions
!
literal		VT$K_SINGLE_FONT_INDEX = 0;
literal		VT$K_DWIDTH_FONT_INDEX = 4;
literal		VT$K_DHTOP_FONT_INDEX = 8;
literal		VT$K_DHBOT_FONT_INDEX = 12;

literal		VT$K_NUMBER_OF_FONTS = 16;

bind
	 VT$AV_FONT_NAMES = PLIT( 

		 %ASCID'KILTER'
		,%ASCID'KILTER'
		,%ASCID'KILTER'
		,%ASCID'KILTER'
		,%ASCID'KILTER_DOUBLE_WIDTH'
		,%ASCID'KILTER_DOUBLE_WIDTH'
		,%ASCID'KILTER_DOUBLE_WIDTH'
		,%ASCID'KILTER_DOUBLE_WIDTH'
		,%ASCID'VT100_TOP_HALF'
		,%ASCID'VT100_TOP_HALF'
		,%ASCID'VT100_TOP_HALF'
		,%ASCID'VT100_TOP_HALF'
		,%ASCID'VT100_BOTTOM_HALF'
		,%ASCID'VT100_BOTTOM_HALF'
		,%ASCID'VT100_BOTTOM_HALF'
		,%ASCID'VT100_BOTTOM_HALF'
				) : vector [VT$K_NUMBER_OF_FONTS, long]

	,VT$LV_FONT_RENDS = PLIT (
		 0
		,VSTA$M_REND_BOLD
		,vsta$m_rend_blink
		,VSTA$M_REND_BOLD + vsta$m_rend_blink
		,0
		,VSTA$M_REND_BOLD
		,vsta$m_rend_blink
		,VSTA$M_REND_BOLD + vsta$m_rend_blink
		,0
		,VSTA$M_REND_BOLD
		,vsta$m_rend_blink
		,VSTA$M_REND_BOLD + vsta$m_rend_blink
		,0
		,VSTA$M_REND_BOLD
		,vsta$m_rend_blink
		,VSTA$M_REND_BOLD + vsta$m_rend_blink
				) : vector [VT$K_NUMBER_OF_FONTS, long]
	;


LITERAL

	 vt$m_upd_none	= 0
	,vt$m_upd_gr	= 1
	,vt$m_upd_gl	= 2
	,vt$m_upd_all	= 3
	,vt$k_upd_none	= 0
	,vt$k_upd_gr	= 1
	,vt$k_upd_gl	= 2
	,vt$k_upd_all	= 3
	;

!
!  Define nation replacement sets
!
LITERAL  vt$k_nrc_bcnt = 12;


BIND
	  vt$bv_ascii_nrc = PLIT BYTE (
		  35,  64,  91,  92,  93,  94,  95,  96, 123, 124, 125, 126
				)	: VECTOR [,BYTE]
	 ,vt$bv_uk_nrc = PLIT BYTE (
		 163,  64,  91,  92,  93,  94,  95,  96, 123, 124, 125, 126
				)	: VECTOR [,BYTE]
	 ,vt$bv_french_nrc = PLIT BYTE (
		 163, 224, 176, 231, 167,  94,  95,  96, 233, 249, 232, 34
				)	: VECTOR [,BYTE]
	 ,vt$bv_frcan_nrc = PLIT BYTE (
		  35, 224, 226, 231, 234, 238,  95, 244, 233, 249, 232, 251
				)	: VECTOR [,BYTE]
	 ,vt$bv_nordan_nrc = PLIT BYTE (
		  35, 196, 198, 216, 197, 220,  95, 228, 230, 248, 229, 252
				)	: VECTOR [,BYTE]
	 ,vt$bv_finnish_nrc = PLIT BYTE (
		  35,  64, 196, 214, 197, 220,  95, 233, 228, 246, 229, 252
				)	: VECTOR [,BYTE]
	 ,vt$bv_german_nrc = PLIT BYTE (
		  35, 167, 196, 214, 220,  94,  95,  96, 228, 246, 252, 223
				)	: VECTOR [,BYTE]
	 ,vt$bv_dutch_nrc = PLIT BYTE (
		 163, 179, 253, 189, 124,  94,  95,  96,  34, 102, 188,  39
				)	: VECTOR [,BYTE]
	 ,vt$bv_italian_nrc = PLIT BYTE (
		 163, 167, 176, 231, 233,  94,  95, 249, 224, 242, 232, 236
				)	: VECTOR [,BYTE]
	 ,vt$bv_swiss_nrc = PLIT BYTE (
		 249, 224, 233, 231, 234, 238, 232, 244, 228, 246, 252, 251
				)	: VECTOR [,BYTE]
	 ,vt$bv_swedish_nrc = PLIT BYTE (
		  35, 201, 196, 214, 197, 220,  95, 233, 228, 246, 229, 252
				)	: VECTOR [,BYTE]
	 ,vt$bv_spanish_nrc = PLIT BYTE (
		 163, 167, 161, 209, 191,  94,  95,  96, 176, 241, 231, 126
				)	: VECTOR [,BYTE]
	;

BIND
	 vt$av_nrc_tables = PLIT (
		  vt$bv_ascii_nrc 
		 ,vt$bv_uk_nrc 
		 ,vt$bv_french_nrc 
		 ,vt$bv_frcan_nrc 
		 ,vt$bv_nordan_nrc 
		 ,vt$bv_finnish_nrc 
		 ,vt$bv_german_nrc 
		 ,vt$bv_dutch_nrc 
		 ,vt$bv_italian_nrc 
		 ,vt$bv_swiss_nrc 
		 ,vt$bv_swedish_nrc 
		 ,vt$bv_spanish_nrc )
				: VECTOR [,LONG]
	;

LITERAL vt$k_ascii_g			= 0;
LITERAL vt$k_uk_ascii_g			= 1;
LITERAL vt$k_french_g			= 2;
LITERAL vt$k_frcan_g			= 3;
LITERAL vt$k_nordan_g			= 4;
LITERAL vt$k_finnish_g			= 5;
LITERAL vt$k_german_g			= 6;
LITERAL vt$k_dutch_g			= 7;
LITERAL vt$k_italian_g			= 8;
LITERAL vt$k_swiss_g			= 9;
LITERAL vt$k_swedish_g			= 10;
LITERAL vt$k_spanish_g			= 11;
LITERAL vt$k_supplemental_g		= 12;
LITERAL vt$k_line_drawing		= 13;
LITERAL vt$k_ascii_c			= 14;
LITERAL vt$k_supplemental_c		= 15;

BIND
	 vt$l_nrc_vkb_table = UPLIT LONG (
			vsta$k_nrc_ascii,
			vsta$k_nrc_uk,
			vsta$k_nrc_french,
			vsta$k_nrc_frcan,
			vsta$k_nrc_nordan,
			vsta$k_nrc_finnish,
			vsta$k_nrc_german,
			vsta$k_nrc_dutch,
			vsta$k_nrc_italian,
			vsta$k_nrc_swiss,
			vsta$k_nrc_swedish,
			vsta$k_nrc_spanish,
			vsta$k_nrc_ascii,
			vsta$k_nrc_ascii,
			vsta$k_nrc_ascii,
			vsta$k_nrc_ascii )
				: VECTOR [,LONG]
	;
! Define profile to charset translation table.
! (Be sure to check that prof$k_kbd_c* symbols do not change.)
!
BIND
	vt$l_kbd_gset_table = UPLIT LONG (
		vt$k_ascii_g,	! prof$k_kbd_ca=0  LK201CA : American
		vt$k_french_g, 	! prof$k_kbd_cb=1  LK201CB : Flemish
		vt$k_frcan_g,	! prof$k_kbd_cc=2  LK201CC : Canadian (French)
		vt$k_nordan_g,	! prof$k_kbd_cd=3  LK201CD : Danish
		vt$k_uk_ascii_g,! prof$k_kbd_ce=4  LK201CE : British
		vt$k_finnish_g,	! prof$k_kbd_cf=5  LK201CF : Finnish
		vt$k_german_g,	! prof$k_kbd_cg=6  LK201CG : German/Austrian
		vt$k_dutch_g,	! prof$k_kbd_ch=7  LK201CH : Dutch
		vt$k_italian_g,	! prof$k_kbd_ci=8  LK201CI : Italian
		vt$k_swiss_g,	! prof$k_kbd_ck=9  LK201CK : French/Swiss
		vt$k_swiss_g,	! prof$k_kbd_cl=10 LK201CL : German/Swiss
		vt$k_swedish_g,	! prof$k_kbd_cm=11 LK201CM : Swedish
		vt$k_nordan_g,	! prof$k_kbd_cn=12 LK201CN : Norwegian
		vt$k_french_g, 	! prof$k_kbd_cp=13 LK201CP : French/Belgian
		vt$k_spanish_g	! prof$k_kbd_cs=14 LK201CS : Spanish
		): VECTOR [,LONG];

!



!
!  Define string processing variables next
!
OWN
	 vt$b_spanc_mask	: BYTE INITIAL (%B'01100000')
	;

BIND
	 vt$b_ascii_table = UPLIT BYTE(
		 0,1,2,3,4,5,6,7,8,9
		,10,11,12,13,14,15,16,17,18,19
		,20,21,22,23,24,25,26,27,28,29
		,30,31,32,33,34,35,36,37,38,39
		,40,41,42,43,44,45,46,47,48,49
		,50,51,52,53,54,55,56,57,58,59
		,60,61,62,63,64,65,66,67,68,69
		,70,71,72,73,74,75,76,77,78,79
		,80,81,82,83,84,85,86,87,88,89
		,90,91,92,93,94,95,96,97,98,99
		,100,101,102,103,104,105,106,107,108,109
		,110,111,112,113,114,115,116,117,118,119
		,120,121,122,123,124,125,126,0,128,129
		,130,131,132,133,134,135,136,137,138,139
		,140,141,142,143,144,145,146,147,148,149
		,150,151,152,153,154,155,156,157,158,159
		,160,161,162,163,164,165,166,167,168,169
		,170,171,172,173,174,175,176,177,178,179
		,180,181,182,183,184,185,186,187,188,189
		,190,191,192,193,194,195,196,197,198,199
		,200,201,202,203,204,205,206,207,208,209
		,210,211,212,213,214,215,216,217,218,219
		,220,221,222,223,224,225,226,227,228,229
		,230,231,232,233,234,235,236,237,238,239
		,240,241,242,243,244,245,246,247,248,249
		,250,251,252,253,254,255) : VECTOR [255,BYTE]
	;

own
	 VT$B_FONTS_DEFINED		: byte initial (0)
	,VT$LV_FONT_DESCRS		: vector [2*VT$K_NUMBER_OF_FONTS,long]
	,VT$L_FONT_SIZE			: initial (14)
	,VT$L_FONT_HEIGHT		: initial (15)
	,VT$L_FONT_WIDTH		: initial (8)
	;




!------------------------------------------------
!  define the error return and record macros
!------------------------------------------------
MACRO
	$LOG_ERROR(status) = 
		(EXTERNAL LITERAL status;
		 (vsta$$error_logger(status)))%
	;	
!
! The following macro checks (in one instruction hopefully !) to see if
! the terminal settings form exists, and does NOTHING if not.  If the settings
! exist, a routine is called to update the form to reflect some change
! initiated by a user program's escape sequence.  Note that the macro
! should NOT be called in paths that change initiated by the human interface,
! since the settings form is already updated in such cases.  Pass -1 to cause
! all items to be updated.
!
macro $update_settings (item) =
	if .id[vt$v_settings_exist]
	then vsta$$ts_update_settings (
	    .id [vt$l_virtual_display_id],
	    item
	    )
	% ;

!
! The following macros give the x & y positions for a given column & row
!
macro $get_x (column_num) = ((COLUMN_num - 1) * .VT$L_FONT_WIDTH + 1) % ;

macro $get_y (row_num) = ((ROW_num - 1) * .VT$L_FONT_HEIGHT) % ;

!
! The following macro gives the current rendition
!
macro $set_cur_rendition (id) =
	 ( (IF .id [vt$v_bold] THEN vt$m_bold ELSE 0)
	 + (IF .id [vt$v_underscore] THEN vt$m_underline ELSE 0)
	 + (IF .id [vt$v_blink] THEN vt$m_blink ELSE 0)
	 + (IF .id [vt$v_reverse] THEN vt$m_reverse ELSE 0 ))
	% ;


global routine vsta$$vt100_settings_exist
!++
! Functional description:
!
!	Human interface calls this routine to announce to us that this
!	terminal does or does not have a settings form inexistence.  When
!	programs change settings via escape sequences, we use the bit
!	to decide whether we need to call the human interface back to
!	update the settings form.
!
! Formal parameters:
 (
	vd_id,				! which terminal is involved
	exists_flag			! 1 if settings exist
 ) =
!
!--
	begin

	local
	    id : ref device_data_table,
	    s;
!
! Find vt100 database associated with this terminal.
! For now, we quietly return if we can't find it.  Such would be the
! case during logout, during which we get called after terminal has
! gone away.
!
	if not (s = find_vt100 (.vd_id, id))
	then return ss$_normal;
!
! Set the existence bit accordingly.
!
	id[vt$v_settings_exist] = .exists_flag;

	ss$_normal

	end;

GLOBAL ROUTINE vsta$$vt100_reset(
			 vd_id
				) =
!++
!  Functional Description
!
!   This routine is called to reset the vt100 instance to the profile
!   settings.
!
!  Formal Parameters
!
!   vd_id	: The vt100 id (same as virtual display id)
!
!--
BEGIN

LOCAL
	 id	: REF device_data_table
	;

!
!  Locate the vt100 to reset.
!
IF NOT find_vt100 (
		 .vd_id
		,id
		  )
THEN $RETURN_ERROR(vsta$_nosuchvt);

!
!  Before we do anything, turn off the blinking cursor 
!  If this fails then don't let the output fail just  log the error
!
IF NOT vt$$cur_stop_cursor(.id)
THEN $LOG_ERROR(vsta$_cntstopvtcur);


!
!  Call the internal reset routine
!
reset_vt100( .id);

flush_backlog (.id);	!Write any printable text which we have accumulated

!
!  Turn the cursor on again if the cursor enable flag is set
!
IF .id [vt$v_text_cursor_enabled] 
THEN IF NOT vt$$cur_start_cursor(.id)
THEN $LOG_ERROR(vsta$_cntstartvtcur);

RETURN ss$_normal;
END;




ROUTINE process_g_sets(
			 id		: REF device_data_table
			,g_set_index	: signed
			,character_set	: signed
			,update_flags
			): VT_LINKAGE NOVALUE = 
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine first designates character_set into the specified g set
!
! Then it checks to see if the g set specified is an invoked set and
! if it is then it adjusts the translation table accordingly
!
!--
BEGIN

bind
	 g_set = id [vt$w_g0_set]: VECTOR [,WORD]
	;

!
!  Put the character set into the g set
!
g_set [ .g_set_index] = .character_set;

!
!  Check to see if we need to update the in_use_table
!
IF (.id [vt$w_gl_active_set] EQL .g_set_index) AND
   ((.update_flags AND vt$m_upd_gl) NEQ 0)
THEN 
    SELECTONE .g_set [ .g_set_index]
    OF SET
    !
    !  We now must determine which character set is
    !  in the g1 set. and move that portion of the
    !  the table into our translation table
    !
	[vt$k_ascii_g]:	CH$MOVE( 
				 6*16
				,vt$b_ascii_table + 32
				,id [vt$b_trans_table] + 32
				);

	[vt$k_uk_ascii_g]: BEGIN
	    BIND tab = id [vt$b_trans_table]: VECTOR [,BYTE];

	    CH$MOVE( 
			 6*16
			,vt$b_ascii_table + 32
			,id [vt$b_trans_table] + 32
			);

	    !
	    !  Move the UK pound character into the
	    !  # position
	    !
	    tab [ 35] = 163; 
			
	    END;

	[vt$k_supplemental_g]: CH$MOVE( 
				 6*16
				,vt$b_ascii_table + 160
				,id [vt$b_trans_table] + 32
				);

	[vt$k_line_drawing]: BEGIN
	    CH$MOVE(
			 63
			,vt$b_ascii_table + 32
			,id [vt$b_trans_table] + 32
			);

	    CH$MOVE( 
			 32
			,vt$b_ascii_table
			,id [vt$b_trans_table] + 95
			);
	    END;

	[OTHERWISE]: BEGIN
	    LOCAL	nrc_table: ref vector [,byte];
	    BIND	tab = id [vt$b_trans_table]: VECTOR [,BYTE];

	    CH$MOVE( 
			 6*16
			,vt$b_ascii_table + 32
			,id [vt$b_trans_table] + 32
			);

	    nrc_table = .vt$av_nrc_tables [ .g_set [ .g_set_index]];

	    INCR i FROM 0 to vt$k_nrc_bcnt - 1
	    DO BEGIN
		tab [ .vt$bv_ascii_nrc [ .i]] =	.nrc_table [ .i];
		END;

	    END;
	TES;

!
!  If we are in seven bit mode then we must ensure that GR and GL tables are
!  the same.
!
IF .id [vt$w_conformance_level] EQL vt$k_level_1
THEN BEGIN
    id [vt$w_gr_active_set] = .id [vt$w_gl_active_set];
    update_flags = vt$k_upd_gr;
    END;

IF (.id [vt$w_gr_active_set] EQL .g_set_index) AND
   ((.update_flags AND vt$m_upd_gr) NEQ 0)
THEN

    SELECTONE .g_set [ .g_set_index] 
    OF SET
    !
    !  We now must determine which character set is
    !  in the g1 set. and move that portion of the
    !  the table into our translation table
    !
	[vt$k_ascii_g]:	CH$MOVE( 
				 6*16
				,vt$b_ascii_table + 32
				,id [vt$b_trans_table] + 160
				);

	[vt$k_uk_ascii_g]: BEGIN
	    BIND	tab = id [vt$b_trans_table]: VECTOR [,BYTE];

	    CH$MOVE( 
			 6*16
			,vt$b_ascii_table + 32
			,id [vt$b_trans_table] + 160
			);

	    !
	    !  Move the UK pound character into the
	    !  # position
	    !
	    tab [163] = 163; 
			
	    END;

	[vt$k_supplemental_g]: 	CH$MOVE( 
				 6*16
				,vt$b_ascii_table + 160
				,id [vt$b_trans_table] + 160
				);

	[vt$k_line_drawing]: BEGIN

	    CH$MOVE(
			 63
			,vt$b_ascii_table + 32
			,id [vt$b_trans_table] + 160
			);

	    CH$MOVE( 
			 32
			,vt$b_ascii_table
			,id [vt$b_trans_table] + 223
			);
	    END;

	[OTHERWISE]:  BEGIN
	    LOCAL	nrc_table: ref vector [,byte];
	    BIND	tab = id [vt$b_trans_table]: VECTOR [,BYTE];
	    CH$MOVE( 
			 6*16
			,vt$b_ascii_table + 32
			,id [vt$b_trans_table] + 160
			);

	    nrc_table = .vt$av_nrc_tables [ .g_set [ .g_set_index]];

	    INCR i FROM 0 to vt$k_nrc_bcnt - 1
	    DO BEGIN
		tab [ .vt$bv_ascii_nrc [ .i] + 128] = .nrc_table [ .i];
		END;

	    END;


	TES;


END;







ROUTINE process_write
!++
! FUNCTIONAL DESCRIPTION:
!
! A string of ascii characters is processed by the emulated VT100 whose data block (id) is specified.
!
! Each character in the buffer is examined, and a specific action decided upon.
! The action is determined by two things: (1) the type of character which is coming through, and (2) the
! current state of the device.
! 
! Any character in the range 0 to octal 37 is a control character, and is handed to the routine that
! processes control characters. Embedded control characters are allowed by the VT100, so the state
! is not changed. However, the "process_control_character" routine may change the state of the VT100
! depending on which character it gets: see that routine for more information.
!
! If the character is not a control character, then it is treated as either a printable character, or as part of
! an escape, control, or DEC private sequence depending on the state as determined by previous characters.
!
! FORMAL PARAMETERS:
!
	(
		 id	: REF device_data_table	!Address of vt100 data
		,text	: REF VECTOR [,BYTE]	!Address of string to be sent
		,byte_count			!byte count
	): VT_LINKAGE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
! Device data table is updated as necessary to reflect state of device, new modes, etc...
!
! ROUTINE VALUE:
!
	NOVALUE = 		!No value returned
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN

BUILTIN
	 SPANC
	,MOVTC
	;

LOCAL 
	 
	 right_edge
	,input_inx		: INITIAL (0)
	,available_text
	,num_chars_to_trans
	,num_chars_needed
	,remaining_input_size
	,special_char_addr
	,fill			: INITIAL (0)
	,char_pos
	,new_lines
	,starting
	,next_newline
	;

BIND
 	 parameter = id [vt$w_parameters]: VECTOR [vt$k_maximum_parameter,WORD]
	,counter = id [vt$b_current_parameter]: BYTE
	,line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	;

!
!  Before we do anything, turn off the blinking cursor 
!  If this fails then don't let the output fail just  log the error
!
IF NOT vt$$cur_stop_cursor(.id)
THEN $LOG_ERROR(vsta$_cntstopvtcur);


!
!  While the index is less than the number of characters in the buffer
!  then process them
!
WHILE .input_inx LSS .byte_count
DO BEGIN

    !
    !  Get the next character
    !
    id [vt$b_char] = .text [ .input_inx];
	
    !
    !  Update input index
    !
    input_inx = .input_inx + 1;

    !
    ! Get next byte of output.  If an escape sequence is in progress or
    ! the device is in level 1 conformance mode then strip off 8th bit
    !
    IF  (.id [vt$w_state] NEQ vt$k_straight_text) OR
	(.id [vt$w_conformance_level] EQL vt$k_level_1)
    THEN id [vt$b_char] = .id [vt$b_char] AND 127;

    !
    !  Determine what state we are in
    !  Check for CRM mode if it is set then let thru only certain seq's
    ! and control characters.
    !
    IF .id [vt$v_crm]
    THEN BEGIN
	SELECTONE .id [vt$b_char] OF
	SET
	    [lf,ff,vt]: 	process_newline(.id);

	    [xoff,xon]:
		BEGIN
		    process_printable_character(.id);
		    process_control_character(.id);
		    END;

	    [OTHERWISE]: 
		CASE .id [vt$w_crm_state] FROM 0 TO 3 OF
		SET
		    [0]: SELECTONE .id [vt$b_char] OF
			 SET 
			     [27]: BEGIN
				parameter [0] = 27;
				counter = 1;
				id [vt$w_crm_state] = 1;
				END;
			     [155]: BEGIN
				parameter [0] = 155;
				counter = 1;
				id [vt$w_crm_state] = 2;
				END;
			     [OTHERWISE]: process_printable_character(.id);
			     TES;
		    [1]: IF .id [vt$b_char] NEQ 91
			THEN BEGIN
			    local tmp;
			    tmp = .id [vt$b_char];
			    id [vt$b_char] = 27;
			    process_printable_character(.id);
			    id [vt$b_char] = .tmp;
			    process_printable_character(.id);
			    id [vt$w_crm_state] = 0;
			    END
			ELSE BEGIN
			    parameter [1] = 91;
			    counter = 2;
			    id [vt$w_crm_state] = 2;
			    END;
		    [2]: IF .id [vt$b_char] NEQ %C'3'
			THEN BEGIN
			    local tmp;
			    tmp = .id [vt$b_char];
			    INCR i FROM 0 TO .counter - 1
			    DO BEGIN
				id [vt$b_char]=.parameter [.i];
				process_printable_character(.id);
				END;
			    id [vt$b_char] = .tmp;
			    process_printable_character(.id);
			    id [vt$w_crm_state] = 0;
			    END
			ELSE BEGIN
			    parameter [2] = %C'3';
			    counter = .counter + 1;
			    id [vt$w_crm_state] = 3;
			    END;

		    [3]: IF .id [vt$b_char] NEQ %C'l'
			THEN BEGIN
			    local tmp;
			    tmp = .id [vt$b_char];
			    INCR i FROM 0 TO .counter - 1
			    DO BEGIN
				id [vt$b_char]=.parameter [.i];
				process_printable_character(.id);
				END;
			    id [vt$b_char] = .tmp;
			    process_printable_character(.id);
			    id [vt$w_crm_state] = 0;
			    END
			ELSE id [vt$v_crm] = false;

		    [INRANGE]:;
		    [OUTRANGE]:;

		    TES;
	    TES;

	END	! End of control  represention mode

    ELSE BEGIN	! Start of Normal byte by byte processing

	!
	!  If this next character is a control character then process it
	!
	IF ((.id [vt$b_char] AND 127) LSS 32) OR (.id [vt$b_char] EQL 127)
	THEN process_control_character (.id)
	ELSE CASE .id [vt$w_state] FROM vt$k_first_state TO vt$k_last_state 
	OF SET

	    [vt$k_last_character_was_escape]:
		IF NOT .id [vt$v_ansi_vt52]
		THEN process_vt52_sequence(.id)
		ELSE BEGIN
		    id [vt$w_state] = vt$k_escape_sequence;	
		    !
		    ! special code for many newlines from emacs
		    !
		    if ( .text [.input_inx] EQL 27 ) 
		    THEN CASE .id [vt$b_char] FROM 48 TO 127 
		    OF SET

			[%C'E']: begin
			    char_pos = .input_inx;
			    new_lines = 0;
			    while (.char_pos LSS .byte_count) do BEGIN
				next_newline = ch$find_sub ( 
							2, text [.char_pos],
							2, 
					    ch$ptr (UPLIT BYTE( esc, %C'E') ) );
				if not ch$fail ( .next_newline)
				then begin
				    char_pos = .char_pos + 2;
				    new_lines = .new_lines + 1;
				    end
				else char_pos = .byte_count;
				end;
			    flush_backlog( .id);
			    id [vt$l_cursor_column] = 1;	!Cursor is going to left edge, no matter what else happens
			    id [vt$w_single_shift] = vt$k_ssn;	! turn off single shift
			    input_inx = .input_inx + .new_lines * 2 - 1;
			    if ( .new_lines GTR 0) 
			    then process_line_feeds (.id, .new_lines);	!The rest is same as line feed
			    END;

			[%C'M']: BEGIN
			    char_pos = .input_inx;
			    new_lines = 0;
			    while (.char_pos LSS .byte_count) do BEGIN
				next_newline = ch$find_sub ( 
							2, text [.char_pos],
							2, 
					    ch$ptr (UPLIT BYTE( esc, %C'M') ) );
				if not ch$fail ( .next_newline)
				then begin
				    char_pos = .char_pos + 2;
				    new_lines = .new_lines + 1;
				    end
				else char_pos = .byte_count;
				end;
			    flush_backlog( .id);
			    id [vt$l_cursor_column] = 1;	!Cursor is going to left edge, no matter what else happens
			    id [vt$w_single_shift] = vt$k_ssn;	! turn off single shift
			    input_inx = .input_inx + .new_lines * 2 - 1;
			    if ( .new_lines GTR 0) 
			    then process_UP_lines (.id, .new_lines);	!The rest is same as line feed
			    END;

			[INRANGE]: process_escape_sequence (.id);

			[OUTRANGE]: process_escape_sequence (.id);

			TES

		    ELSE process_escape_sequence (.id);
		    END;

	    [vt$k_escape_sequence]: process_escape_sequence (.id);

	    [vt$k_control_sequence]: process_control_sequence (.id);

	    [vt$k_straight_text] :


	    !
	    !  Use special scan to check for special character
	    !  Use special move tranlated to get output
	    !
	    BEGIN	

	    !
	    !  Check for single shift conditions
	    !
	    IF .id [vt$w_single_shift] NEQ vt$k_ssn 
	    THEN BEGIN
		process_printable_character ( .id);
		input_inx = .input_inx + 1;
		END;

	    !
	    !  At this point the input index is pointing at the
	    !  next character so point it to the current one
	    !  for the scan to start there
	    !
	    input_inx = .input_inx - 1;

	    remaining_input_size = .byte_count - .input_inx;

	    !
	    !  Scan the input stream from input_inx to the next special character
	    !  Get the address of the special character or 0 if none remaining
	    !
	    special_char_addr = SPANC( 
				 remaining_input_size
				,text [.input_inx]
				,vt$b_ascii_table [0]
				,vt$b_spanc_mask
				);

	    !
	    !  If no special characters were found (address = 0) then all the
	    !  rest of the buffer is available printable text
	    !
	    IF .special_char_addr GTR 0
	    THEN available_text = .special_char_addr - text [ .input_inx]
	    ELSE available_text = .remaining_input_size;

	    !
	    !  While the available text is not exausted then put the text on
	    !  the line
	    !
	    WHILE .available_text GTR 0
	    DO BEGIN
		!
		!  If the last column flag 
		!  then if
		!    1) if autowrap then newline
		!    2) if no autowrap then overwrite last character in backlog
		!
		IF .id [vt$v_last_col_flag]
		THEN IF .id [vt$v_auto_wrap]
		     THEN process_newline( .id)
		     ELSE id [vt$l_backlog_count] = 
					MAX( .id [vt$l_backlog_count] - 1, 0);

		!
		!  Determine where the right edge of the row is
		! 
		IF .line_state [.id [vt$l_cursor_row]-1] EQL vt$k_single
		THEN right_edge = .id [vt$l_extreme_right]
		ELSE right_edge = .id [vt$l_extreme_right] / 2;

		!
		!  If we are in the last column and there is available
		!  text then we must take one character out of the
		!  backlog (if there is one that is)
		!
!		IF .id [vt$l_cursor_column] GEQ .right_edge
!		THEN id [vt$l_backlog_count] = 
!				MAX( .id [vt$l_backlog_count] - 1, 0);
							
		!
		!  Initialize string processing data
		!
		num_chars_needed = .right_edge - .id [vt$l_cursor_column] + 1;

		!
		!  Determine the number of characters to translate
		!
		num_chars_to_trans = MIN( 
					 .available_text
					,.num_chars_needed
					);

		!
		!  Translate these characters according to this
		!  vt100's translation table
		!
		MOVTC (
			 num_chars_to_trans
			,text [.input_inx]
			,fill
			,id [vt$b_trans_table]
			,num_chars_to_trans
			,id [vt$b_backlog] + .id [vt$l_backlog_count]
			);

		!
		!  Update the  backlog index
		!
		id [vt$l_backlog_count] = .id [vt$l_backlog_count] +
						.num_chars_to_trans;
		!
		!  Update the cursor position
		!
		id [vt$l_cursor_column] = .id [vt$l_cursor_column] +
							.num_chars_to_trans;

		!
		!  Update the available character count
		!
		available_text = .available_text - .num_chars_to_trans;

		!
		!  Update the input index
		!
		input_inx = .input_inx + .num_chars_to_trans;

		!
		!  If we are at the end of the line then figure out what to do
		!
		IF .id [vt$l_cursor_column] GTR .right_edge
		THEN BEGIN
		    !
		    !  Set the last column flag
		    !
		    id [vt$v_last_col_flag] = true;
		    id [vt$l_cursor_column] =.right_edge;
		    END;   	! If at end of line

		END;  	! While available text 

	    END;		! Processing of text with special scan

	    [INRANGE]:;
	    [OUTRANGE]:;

	    TES;		! End of case parsing state of

	END;		! Processing all characters byte by byte

     END;			! Main loop



flush_backlog (.id);	!Write any printable text which we have accumulated

!
!  Turn the cursor on again if the cursor enable flag is set
!
IF .id [vt$v_text_cursor_enabled] 
THEN IF NOT vt$$cur_start_cursor(.id)
THEN $LOG_ERROR(vsta$_cntstartvtcur);


END;


GLOBAL ROUTINE vs$$vtem_vt100_create
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine allocates dynamic memory and creates the data base for a vt100 in that memory. The data base
! is double-size, the first half being the operating state of the vt100, the second half being its state
! when reset.
!
! FORMAL PARAMETERS:
!
	(virtual_display_id	!Virtual Display id from "create_virtual_display" routine 
	,rows			!Number of rows for this vt100
	,columns_normal		!Number of columns in normal mode
	,columns_wide		!Number of columns in wide mode
	,uic			!uic to keep for user protection
	,chars			!characteristics, incl Permanent, Shareable
	,protection 		!UIC protection code
	,nam_desc ): =		!Terminal name for window
!
! IMPLICIT INPUTS:
!
! NONE
!
! IMPLICIT OUTPUTS:
!
! NONE
!
! ROUTINE VALUE
! Returns "ss$_normal" if successful, or error status returned by 
! VS$$ACP_GET_VM, create_vd,  or other routine.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! Dynamic memory is allocated and initialized for VT100 reset state.
!
!--

BEGIN
LOCAL
	 permanence	: initial (0)
	,id		: REF device_data_table
	,bcnt
	,status
	;


!
!  Get memory for vt100 data state table; if this fails then just return
!  error
!
IF NOT VS$$ACP_GET_VM (
		 %REF (vt$s_device_data_table)
		,id
		,0
			)
THEN $RETURN_ERROR(vsta$_cntallovtdt);

!
!  Allocate memory for text and rendition tables, first set pointers to 
!  those tables to 0
!
id [vt$a_text_table] = 0;
id [vt$a_rend_table] = 0;

!
!  Calculate the number of bytes to allocate for text and rendition tables
!
bcnt = .rows * .columns_normal * 2;

IF NOT VS$$ACP_GET_VM (
		 bcnt
		,id [vt$a_text_table]
		,0
		      )

THEN BEGIN
	VS$$ACP_FREE_VM	(
		 bcnt
		,id
		,0
			);	

	$RETURN_ERROR(vsta$_cntallovtdt);
     END;

!
!  If successful then calculate the address of the rendition table
!
id [vt$a_rend_table] = .id [vt$a_text_table] + (.rows * .columns_normal);

!
!  Initialize vt100 state tables
!
initialize_vt100 !Set up the reset condition for the VT100
			(.id
			,.rows
			,.columns_normal
			,.columns_wide);

!
!  Create the virtual display
!
IF NOT vs$$vds_create_vd (.id [vt$l_body_height],	!create virtual display with
				.id [vt$l_body_width],	!height and width determined by font used
				1,			!Single bitplane for now
				vt$k_background,
				vt$k_foreground,	!initial foreground color
				vt$k_text_mode,		!indicate it's a vt100
				vt$k_graphics, ! vt$k_nographics, !indicate text only
				.uic,			!pass along our uic
				.chars,			!Permanent,Shareable
				.protection,		!UIC protection code
				.virtual_display_id,	!get back id of virtual display
				%ascid 'DEC terminal',	! keyword for finding correct page
				.rows,			!Number of rows
				.columns_normal)	!Number of columns
THEN BEGIN

	VS$$ACP_FREE_VM (
			 bcnt
			,id [vt$a_text_table]
			,0
		       );

	VS$$ACP_FREE_VM (
			 %REF (vt$s_device_data_table)
			,id
			,0
		        );

	$RETURN_ERROR(vsta$_vtcntcrebdyvd);

     END;

!
!  Store virtual display id in state table
!
id [vt$l_virtual_display_id] = ..virtual_display_id;	!enter virtual display id in data base

!
!  Insert data state table at end of vt100 instance queue
!
insque ( .id, vt100_q_head [0]);


!
! Call routine to create bezel boarder
!
IF NOT vsta$$emul_create_bezel(
				 .id [vt$l_body_width]
				,.id [vt$l_body_height]
				,id [vt$l_bezel_vd_id]
				,id [vt$l_bezel_width]
				,id [vt$l_bezel_height]
				,id [vt$l_black_line_height]
				,%ascid 'DEC terminal'
				)
THEN 
	BEGIN
	vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]);
	$RETURN_ERROR(vsta$_vtcntcrebzl)
	END;

!
! We used to define all the fonts here. But now they
! are all defined to be system-wide fonts and are actually
! defined when the ACP starts up, from the file VSTA$FONT:FONTSDEF.TXT
!  (see TXTINIT.B32).
!
! The fonts defined for the VT100 are:
! filename                typeface           typesize   rendition
! --------                --------           --------   ---------
! VSTA$FONT:KILTER.FNT    Kilter                14       -----
! VSTA$FONT:KILTERBLD.FNT Kilter                14       BOLD
! VSTA$FONT:KILTERDW.FNT  Kilter_double_width   14       -----
! VSTA$FONT:KILTERDWB.FNT Kilter_double_width   14       BOLD
! VSTA$FONT:VTDHTOP.FNT   VT100_top_half        14       -----
! VSTA$FONT:VTDHTOPB.FNT  VT100_top_half        14       BOLD
! VSTA$FONT:VTDHBOT.FNT   VT100_bottom_half     14       -----
! VSTA$FONT:VTDHBOTB.FNT  VT100_bottom_half     14       BOLD
! VSTA$FONT:KILTERCND.FNT Kilter_condensed	14       -----
! VSTA$FONT:KILTERCB.FNT  Kilter_condensed      14       BOLD

vt$$dt_init_fonts ( .id );


id [vt$l_pb_width] = .id [vt$l_body_width] + 2*.id [vt$l_bezel_width];
id [vt$l_pb_height] = .id [vt$l_body_height] + 2*.id [vt$l_bezel_height];
IF (.chars AND vs$m_perm_vd) NEQ 0 then	permanence = vs$m_perm_pb;
!
! create pasteboard
!
IF NOT vs$$vds_create_pb
		(id [vt$l_pasteboard_id]
		,0			
		,vt$k_pasteboard_color
		,.id [vt$l_pb_width]
		,.id [vt$l_pb_height]	!Allow room for borders
		,.uic
		,.permanence + vs$m_vkb + vs$m_term
					!Don't let pb go away until terminal
					!is deleted
		,$protection (owner='R')
				!Let owner read pasteboard but let only us
				!do other things.
		)
  THEN 
    BEGIN
    vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]); !clean up
    $RETURN_ERROR(vsta$_cntcrevtpb);
    END;


!Disable VD output while doing slow stuff
vs$$vds_disable_vd (.id [vt$l_virtual_display_id]);

IF NOT vs$$vds_paste_vd_to_pb
		(.id [vt$l_pasteboard_id],
		.id [vt$l_bezel_vd_id],
		0,
		0,
		0,
		.vs$gl_acp_pid)
  THEN 
    BEGIN
    vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]); !clean up
    $RETURN_ERROR(vsta$_cntpstvtbzlvd)
    END;

!paste virtual display to pasteboard
IF NOT vs$$vds_paste_vd_to_pb
		(.id [vt$l_pasteboard_id],
		.id [vt$l_virtual_display_id],
		.id [vt$l_bezel_width],
		.id [vt$l_bezel_height],
		0,
		.vs$gl_acp_pid)
  THEN 
    BEGIN
    vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]); !clean up
    $RETURN_ERROR(vsta$_cntpstvtbdyvd)
    END;


!Enable VD for doing fast erase
vs$$vds_enable_vd (.id [vt$l_virtual_display_id]);

!Initialize the output stream (for echo) of the virtual keyboard for this VT100
IF NOT vs$$set_vkb_output
		(.id [vt$l_pasteboard_id],		!Input device
		 .id [vt$l_virtual_display_id],		!Output device
		 .id,					!pointer to vt100 data
		 vs$$vtem_vt100_write,			!Echo routine address
		 vt$$cur_vkb_translator,		!routine for special char
		 .vsta$gl_keyboard,			!Translation table
		 .vs$gl_acp_pid				!Say it's us
		)
							!translations
	THEN
		BEGIN
		!clean up before returning
		vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]);
		$RETURN_ERROR(vsta$_cntsetvtvkb)
		END;

!Set virtual keyboard to be level 1 conformance with C1 transmission of
!sevenbit to start
SELECTONE .srv$gl_vt_level OF
 SET
    [prof$k_vt_level1]:
	BEGIN
	IF NOT vs$$set_vkb_char(
		.id [vt$l_pasteboard_id],
		vsta$m_level OR vsta$m_eightbit,
		vsta$k_vkb_level_1,
		.vs$gl_acp_pid)
	THEN
		BEGIN
		!clean up before returning
		vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]);
		$RETURN_ERROR(vsta$_cntsetvtvkb)
		END;
	END;
    [prof$k_vt_level2]:
	BEGIN
	IF NOT vs$$set_vkb_char(
		.id [vt$l_pasteboard_id],
		vsta$m_level OR vsta$m_eightbit OR vsta$m_vt52,
		vsta$k_vkb_level_2 OR vsta$m_eightbit,
		.vs$gl_acp_pid)
	THEN 	BEGIN
		!clean up before returning
		vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]);
		$RETURN_ERROR(vsta$_cntsetvtvkb)
		END;
	END;
    [prof$k_7bit_nrc]:
	BEGIN
	IF NOT vs$$set_vkb_char(
		.id [vt$l_pasteboard_id],
		vsta$m_level OR vsta$m_eightbit OR vsta$m_vt52,
		vsta$k_vkb_level_1,
		.vs$gl_acp_pid)
	THEN 	BEGIN
		!clean up before returning
		vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]);
		$RETURN_ERROR(vsta$_cntsetvtvkb)
		END;
	END;
  TES;

!
!  Reset the vt100 to initial states
!
id [vt$a_answerback_message_adr] = id [vt$b_answerback_message];
reset_vt100( .id);
id [vt$v_settings_exist]	= false;	!Settings form doesn't exist yet

!Erase entire screen
IF NOT VT$$DT_CLEAR_VT100 (.id)
THEN
    BEGIN
    !clean up before returning
    vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]);
    $RETURN_ERROR(vsta$_cnterasevt)
    END;

IF NOT VT$$DT_CLEAR_SCREEN (.id)
THEN
    BEGIN
    !clean up before returning
    vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]);
    $RETURN_ERROR(vsta$_cnterasevt)
    END;

!-----------------------------------
!  start cursor
!-----------------------------------
IF NOT vt$$cur_start_cursor(.id)
THEN BEGIN
	!clean up before returning
	vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]);
	$RETURN_ERROR(vsta$_cntstartvtcur)
     END;

!create window
IF NOT vs$$vds_create_term_window
		(.id [vt$l_pasteboard_id]
		,id [vt$l_window_id]
		,.nam_desc	!Terminal name descriptor
		,0		!x = 0
		,0		!y = 0
		,.id [vt$l_pb_width]
		,.id [vt$l_pb_height]
		)
  THEN 
    BEGIN
    vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]); !clean up
    $RETURN_ERROR(vsta$_cntcrevtw)
    END;

IF NOT (status = vsta$$srv_term_created
		(.id [vt$l_window_id]		!Window id
		,.id [vt$l_pb_width]		!Allow room for borders
		,.id [vt$l_pb_height]		!Allow room for borders
		,.id [vt$l_virtual_display_id]	!Vd-id
		,.id [vt$l_pasteboard_id]	!Pasteboard id
		,vsta$k_termtype_vt100		!ttype
		,.vs$gl_pid			!Process id of creator
		,.id [vt$l_bezel_vd_id]		!Bezel id
		)
	)
  THEN
    BEGIN
    vs$$vtem_vt100_delete (.id [vt$l_virtual_display_id]); !clean up
  !
  ! It is possible that there was an error from the human interface because
  ! the system resources weren't adequate to create a job on the terminal.
  ! In this case, SS$_NOSLOT will have been returned, and the NOTICES document
  ! will show the error. We should not call vsta$$error in this case.
  !
    IF (.status EQL SS$_NOSLOT)			!This environment error will
      THEN RETURN .status;			! have been reported in notices
    $RETURN_ERROR(vsta$_cntcrevtterm)
    END;

RETURN ss$_normal;	!return success
END;


GLOBAL ROUTINE vs$$vtem_vt100_delete
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine deallocates dynamic memory and all entities associated with
! a virtual VT100.  Note that the order which objects are deleted does make
! a difference.  Since the keyboard is associated with the paste board and
! uses the UCB it makes it necessary to delete the keyboard before the
! UCB.
!
! FORMAL PARAMETERS:
!
	(
	 virtual_display_id
	): =	

!
! IMPLICIT INPUTS:
!
! NONE
!
! IMPLICIT OUTPUTS:
!
! NONE
!
! ROUTINE VALUE
! Returns "ss$_normal" if successfully deleted, or ss$_nosuchdev if not found
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! VT100 evaporates
!--

BEGIN
LOCAL
	id: REF device_data_table,
				!pointer to vt100 data base
	status;			!status to return

!
!  Locate the vt100 to delete.
!
IF NOT find_vt100 (
		 .virtual_display_id
		,id
		  )
THEN $RETURN_ERROR(vsta$_nosuchvt);

!
!  stop blinking cursor
!
vt$$cur_stop_cursor(.id);

!
!  Remove the data table from the device list
!
remque (.id, id);
!
! delete pasteboard, which will automatically delete window
!
IF NOT vs$$vds_delete_pb (
		 .id [vt$l_pasteboard_id]
		 ,.vs$gl_acp_pid
			 )
THEN $LOG_ERROR(vsta$_cntdelvtpb);

!
! delete the body virtual display
!
IF NOT vs$$vds_delete_vd (
		 .id [vt$l_virtual_display_id]
		,0
		,.vs$gl_acp_pid
			 )
THEN $LOG_ERROR(vsta$_cntdelvtbdyvd);
	
!
! delete the bezel virtual display
!
IF NOT vs$$vds_delete_vd (
		 .id [vt$l_bezel_vd_id]
		,0
		,.vs$gl_acp_pid
			 )
THEN $LOG_ERROR(vsta$_cntdelvtbzlvd);

!
!  Clean up text and rendition table if they have been allocated
!
IF .id [vt$a_text_table] NEQ 0
THEN IF NOT VS$$ACP_FREE_VM	(
		 %REF ( .id [vt$l_extreme_right] * 
			.id [vt$l_screen_absolute_bottom] *
			2)
		,id [vt$a_text_table]
		,0
			)
     THEN $LOG_ERROR(vsta$_cntdeallvtdt);
!
!
!  Clean up the device data table
!
IF NOT VS$$ACP_FREE_VM	(
		 %REF (vt$s_device_data_table)
		,id
		,0
			)
THEN $LOG_ERROR(vsta$_cntdeallvtdt);

RETURN ss$_normal;	!return success


END;


GLOBAL ROUTINE vsta$$vtem_vt100_set_chars
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine receives a packed buffer of characteristics and
! characterististics mask and sets the states of the terminal accordingly. If
! a characteristic requires a particular action at the time it is set the
! action is performed. In this case there is usually an escape sequence which
! performs the same task to a call to the process_write routine is made.
!
! FORMAL PARAMETERS:
!
	(
	 vd_id				! virtual display id
	,char_bits: WORD
	,char_mask: WORD
	,answr_back_siz
	,answr_back_a: REF VECTOR [,BYTE]
	):=
!
! IMPLICIT INPUTS: NONE
!
! IMPLICIT OUTPUTS: NONE
!
! RETURN VALUE: NONE
!
! COMPLETION CODES:
!
!---failure code is returned if the packed block in not in the correct form
!---or if vt100 terminal with this vd_id is not found.
!
! SIDE EFFECTS:
!
!---This routine changes the data base of the vt100 and may also change the
!---display.
!
!--
BEGIN

LOCAL
	 id: REF device_data_table
	,on_bits
	,off_bits
	;

!---------------------------------------------
!  find the vt100 with this virtual display id
!---------------------------------------------
IF NOT find_vt100 (
			 .vd_id			! send the virtual display id
			,id			! get back the pointer to DB
		  )
THEN $RETURN_ERROR(vsta$_nosuchvt);

!---------------------------------------------
!  break down the bits and mask into on_bits and off_bits
!  then adjust the appropriate fields in the DB
!---------------------------------------------
on_bits = .char_bits AND .char_mask;
off_bits = NOT (.on_bits XOR .char_mask);

id [vt$w_char_status_word] = .id [vt$w_char_status_word] OR .on_bits;
id [vt$w_char_status_word] = .id [vt$w_char_status_word] AND .off_bits;

!---------------------------------------------
!  if an answer back message is specified then move the new AB message into
!  the vt100 DB
!---------------------------------------------
IF .answr_back_siz GTR 0
THEN
	begin
	vsta$$set_vt100_answer (id[$base], .answr_back_siz, answr_back_a[0]);
	$update_settings (s100$k_answer)
	end;

RETURN ss$_normal;

END; !>>> vsta$$vtem_vt100_set_chars <<<!


GLOBAL ROUTINE vsta$$vtem_vt100_get_chars
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine finds the specified vt100 and queries the characteristics status
! word and answer back message and returns it to the callers buffer.
!
! FORMAL PARAMETERS:
!
	(
	 vd_id				! virtual display id
	,char_bits: WORD
	,answr_back_a: REF VECTOR [,BYTE]
	):=
!
! IMPLICIT INPUTS: NONE
!
! IMPLICIT OUTPUTS: NONE
!
! RETURN VALUE: NONE
!
! COMPLETION CODES: 
!
!---This routine will return failure only if the vd_id specified is not an
!---emulated vt100
!
! SIDE EFFECTS:
!
!---The find_vt100 routine is called and the VT100 DB is queried.
!
!--
BEGIN

LOCAL
	 id: REF device_data_table
	;

!---------------------------------------------
!  find the vt100 with this virtual display id
!---------------------------------------------
IF NOT find_vt100 (
			 .vd_id			! send the virtual display id
			,id			! get back the pointer to DB
		  )
THEN $RETURN_ERROR(vsta$_nosuchvt);

!------------------------------------------
! send back the status word
!------------------------------------------
.char_bits = .id [vt$w_char_status_word];

!------------------------------------------
! send back the answer back message
!------------------------------------------
CH$COPY(
	 vt$s_answerback_message	! move 20 characters 
	,id [vt$b_answerback_message]	! from AB field in vt100 DB
	,%C' '				! fill with blanks
	,vt$s_answerback_message	! into the AB field
	,answr_back_a[0]		! to address given by caller
       );

RETURN ss$_normal;

END;


ROUTINE initialize_vt100
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine sets the values of the reset state of the vt100.
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table	!Address of table for current device
	,rows				!Number of rows (lines) in this vt100
	,columns_normal			!Number of columns in "normal" mode
	,columns_wide):			!Number of columns in "wide" mode
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
! The data base is set to values reflecting the default reset state of the 
! vt100.
!
! ROUTINE VALUE:
!
	VT_LINKAGE NOVALUE =
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
! Redefine tabs as a bitvector so we can access it in loop
! Also redefine line_state as a vector
! Also define a vector corresponding to the whole data block for easy copying
BIND
	line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE],
	row_table = id [vt$b_row_table]: VECTOR [,BYTE],
	tabs = id [vt$v_tabs]: BITVECTOR [vt$k_maximum_columns];
!
!  Set size (width and height) of VT100 body based on character size
!
id [vt$l_body_width] = (vt$k_character_width * .columns_normal) + 1 ;  !Text routines want an extra pixel...
id [vt$l_body_height] = vt$k_character_height * .rows ;


id [vt$l_wide_right] = .columns_wide;		!Set number of columns in "wide" mode (typically 132)
id [vt$l_normal_right] = .columns_normal;	!Set number of columns in normal mode (typically 80)
id [vt$l_extreme_right] = .columns_normal;	!Start out with number of columns in normal mode
id [vt$l_screen_absolute_bottom] = .rows;	!Set number of rows as requested by caller
id [vt$l_top_margin] = 1;			!Top of scrolling region is top of screen
id [vt$l_bottom_margin] = .rows;		!Bottom of scrolling region is bottom of screen

!
!  Initialize backlog count
!
id [vt$l_backlog_count] = 0;
id [vt$l_current_typeface] = vt$k_no_typeface;

!
!  Set dark background mode.
!
id [vt$v_screen_background] = false;

!
!  Initialize the row table
!
INCR i from 0 to .id [vt$l_screen_absolute_bottom] - 1
DO row_table [ .i] = .i;

VT$B_FONTS_DEFINED = 0;

RETURN;

END;


ROUTINE reset_vt100
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine copies the second half of the device table into the first half
! (except for the first longword, which contains the virtual display ID).
! This has the effect of performing a "reset" which returns the VT100 to its
! initial settings.  The virtual display which corresponds to the VT100 is
! erased, and the text position is set to the upper left.
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table):
		!Address of table containing state, modes,... of this VT100
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
! NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! VT100 virtual display is erased.
!
!--

BEGIN
LOCAL
   s,		! status		
   trans_table;	! translation table index
!
! Redefine tabs as a bitvector so we can access it in loop
! Also redefine line_state as a vector
!
BIND
	line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE],
	tabs = id [vt$v_tabs]: BITVECTOR [vt$k_maximum_columns];

flush_backlog( .id);

!
! Init the g0-g1 sets as well as the active gr and gl tables
!

SELECTONE .srv$gl_vt_level OF
  SET
    [prof$k_vt_level1]:
	BEGIN
	id [vt$w_c1_transmission] = vt$k_c1_7bit;
	id [vt$w_conformance_level] = vt$k_level_1;
	END;

    [prof$k_vt_level2]:
	BEGIN
	id [vt$w_c1_transmission] = vt$k_c1_8bit;
	id [vt$w_conformance_level] = vt$k_level_2;
	END;

    [prof$k_7bit_nrc]:
	BEGIN
	id [vt$w_c1_transmission] = vt$k_bit7_nrc;
	id [vt$w_conformance_level] = vt$k_level_1;
	END;
  TES;

process_soft_reset(.id);
id [vt$w_single_shift] = vt$k_ssn;

!
!  Set default states, modes, etc., etc., for VT100 until further notice
!
id [vt$w_state] = vt$k_straight_text;			!Start out in text mode
!
id [vt$v_scroll] 		= false;		!Jump scroll
!
!  Set screen color back to what is specified by the profile
!
IF .srv$gl_vt100_dark_bg
THEN vsta$$set_vt100_dark( .id)
ELSE vsta$$set_vt100_light( .id);

id [vt$v_cursor_type] 		= true;		!Block cursor
id [vt$v_ansi_vt52] 		= .srv$gl_vt100_ansi;
id [vt$v_bell] 			= .srv$gl_vt_margin_bell;
id [vt$v_auto_wrap] 		= .srv$gl_vt_wrap;
id [vt$v_linefeed_newline] 	= .srv$gl_vt_newline;
id [vt$v_wide] 			= false;	!80 columns
id [vt$v_keyboard_blocked] 	= false;	!keyboard unblocked
id [vt$v_margin_origin] 	= false;	!Origin at top left of screen
id [vt$v_crm] 			= false;
id [vt$v_invalid_sequence] 	= false;	!No invalid escape sequence
id [vt$v_vt102_insert_mode] 	= false;

id [vt$l_top_margin] = 1;
id [vt$l_bottom_margin] = .id [vt$l_screen_absolute_bottom];

!
! Set or Reset LNM mode
!
if .srv$gl_vt_newline 
then vsta$$set_vt100_newline (id[$base])
else vsta$$set_vt100_oldline (id[$base]);
!
!
! initialize vt52 state
!
id [vt$l_vt52_random_move_state] = 0;
id [vt$b_vt52_char_set] = vt$k_ascii_g;

!
! init the emulator's global areas 4th long word in data base
!
id [vt$l_cursor_column] = 1;		!Start cursor in upper left
id [vt$l_cursor_row] = 1;		!Start cursor in upper left
id [vt$b_attributes] = 0;		!Attributes off
!
!init the generation buffer to be empty
!
id [vt$l_generation_buffer_index] = -1;
id [vt$l_generation_buffer_ptr] = 0;
!
! Initialize descriptor pointing at answerback message such that message
! is whatever profile says it should be.
!
id [vt$l_answerback_message_length] = .srv$gl_answerback_len;
ch$move (
	.srv$gl_answerback_len,
	srv$gl_answerback_str[0],
	.id [vt$a_answerback_message_adr]
	);

!
!  Clear the tab bit table
!
INCR counter FROM 1 TO .id [vt$l_wide_right]
DO tabs [.counter] = 0;

!
!  Initialize the tab bit table to tab every 8 spaces
!
INCR counter FROM 9 TO .id [vt$l_wide_right] BY 8
DO tabs [.counter] = 1;

SELECTONE .srv$gl_vt_level OF
 SET
    [prof$k_vt_level1]:
	BEGIN
	IF NOT vs$$set_vkb_char(
		.id [vt$l_pasteboard_id],
		vsta$m_level OR vsta$m_eightbit,
		vsta$k_vkb_level_1,
		.vs$gl_acp_pid)
	THEN 	$LOG_ERROR(vsta$_cntsetvtvkb);
	IF NOT vs$$vkb_set_nrc(
		.id [vt$l_pasteboard_id],
		vsta$k_nrc_ascii)
	  THEN 	$LOG_ERROR(vsta$_cntsetvtvkb);
	END;
    [prof$k_7bit_nrc]:
	BEGIN
	IF NOT vs$$set_vkb_char(
		.id [vt$l_pasteboard_id],
		vsta$m_level OR vsta$m_eightbit,
		vsta$k_vkb_level_1,
		.vs$gl_acp_pid)
	THEN 	$LOG_ERROR(vsta$_cntsetvtvkb);
	IF NOT vs$$vkb_set_nrc(
		.id [vt$l_pasteboard_id],
		.vt$l_nrc_vkb_table[.vt$l_kbd_gset_table[.srv$gl_kbd_set]])
	  THEN 	$LOG_ERROR(vsta$_cntsetvtvkb);
	END;
    [prof$k_vt_level2]:
	BEGIN
	IF NOT vs$$set_vkb_char(
		.id [vt$l_pasteboard_id],
		vsta$m_level OR vsta$m_eightbit OR vsta$m_vt52,
		vsta$k_vkb_level_2 OR vsta$m_eightbit,
		.vs$gl_acp_pid)
	THEN 	$LOG_ERROR(vsta$_cntsetvtvkb);
	IF NOT vs$$vkb_set_nrc(
		.id [vt$l_pasteboard_id],
		vsta$k_nrc_multinational)
	  THEN 	$LOG_ERROR(vsta$_cntsetvtvkb);
	END;
  TES;
	
! initialize to the new keyboard and LEGEND values of profile	
IF NOT (s = vs$$set_vkb_trans_table(.id [vt$l_pasteboard_id],	! vkb_id
				    .vsta$gl_keyboard,	! new translation table
				    .vs$gl_acp_pid	! its us
				    ))
  THEN $log_error_and_return (.s);

! copy the LEGEND setting into vt100's database/a MUST/	
id [vt$l_legend] = .srv$gl_vt_legend;		! Foreign Kbd

!
! Reset keypad to numeric mode.
!
IF NOT vs$$set_vkb_char(
	.id [vt$l_pasteboard_id],
	vsta$m_keypad,
	0,
	.vs$gl_acp_pid)
   THEN $LOG_ERROR(vsta$_cntsetvtvkb);

!
!  Reset the typeface 
!
id [vt$l_current_typeface] = vt$k_no_typeface;

!
!  Disable VD output while doing slow stuff
!
!IF NOT vs$$vds_disable_vd (.id [vt$l_virtual_display_id])
!THEN $LOG_ERROR(vsta$_cntdisvtvd);

!
!  Erase entire screen
!
vt$$dt_clear_vt100 (.id);
vt$$dt_clear_screen( .id );

!
!  Enable VD 
!
!IF NOT vs$$vds_enable_vd (.id [vt$l_virtual_display_id])
!	THEN $LOG_ERROR(vsta$_cntenavtvd);

END;




GLOBAL ROUTINE vs$$vtem_vt100_write
!++
! FUNCTIONAL DESCRIPTION:
!
! The dynamic memory block allocated to the VT100 is searched for, and if it is found, the buffer
! specified is output.
!
! FORMAL PARAMETERS:
!
	(virtual_display_id	!ID of virtual display which corresponds to this VT100
	,text			!Address of string to be sent
	,byte_count): =		!Address of byte count
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! Value is 1 (success) or "ss$_nosuchdev" due to non-existent virtual display
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
LOCAL
	id: REF device_data_table,
	status;

IF NOT find_vt100	(.virtual_display_id, id)
	THEN $RETURN_ERROR(vsta$_nosuchvt)
	ELSE process_write	(.id,
				.text,
				.byte_count);
RETURN ss$_normal;
END;



global ROUTINE find_vt100
!++
! FUNCTIONAL DESCRIPTION:
!
! The dynamic memory block allocated to the VT100 is searched for.
!
! FORMAL PARAMETERS:
!
	(virtual_display_id,	!ID of virtual display which corresponds to this VT100
	return_id): VT_LINKAGE =	!address of data block
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! Value is 1 (success) or "ss$_nosuchdev" due to non-existent virtual display
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
LOCAL
	id: REF device_data_table;

id = .vt100_q_head [0];		!Start out at queue entry pointed to by header

UNTIL id [vt$a_forward_link] EQL vt100_q_head [0] DO	!Test for having gone all the way around, and if not, do the following
	IF .id [vt$l_virtual_display_id] EQL .virtual_display_id	!See if this queue entry has the requested virtual display
		THEN
			BEGIN
			.return_id = id [vt$a_forward_link];
			RETURN ss$_normal;	!If so, we have found the one asked for
			END
		ELSE id = .id [vt$a_forward_link];			!Pick up the link to the next queue entry

!If we drop through the loop, the requested terminal has never been created
RETURN ss$_nosuchdev;	!return no such device
END;




ROUTINE process_vt52_sequence
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine looks at the incoming character and if it is a valid character
! in a vt52 escape sequence then it performs the appropriate vt52 action
! If it is not valid then the terminal is set back into normal text mode
!
! FORMAL PARAMETERS:
!
	(
	 id: REF device_data_table
	): 
!
! IMPLICIT INPUTS: NONE
!
! IMPLICIT OUTPUTS: NONE
!
! RETURN VALUE: NONE
!
! COMPLETION CODES: NONE
!
	VT_LINKAGE NOVALUE =
!
! SIDE EFFECTS:
!
!--
BEGIN

LOCAL
	 right_edge
	;

BIND
	 generation_buffer =  id [vt$b_generation_buffer]: 
				VECTOR [vt$k_generation_max_index,BYTE]
	,line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	;
!
!  If this is an escape sequence <esc>Y line,column look at the state field
!
CASE .id [vt$l_vt52_random_move_state] FROM 1 TO 2 
OF SET
    [1]: BEGIN
	!
	! check range of row
	!
	IF .id [vt$b_char] LEQ 31
	THEN id [vt$l_saved_cursor_row] = .id [vt$l_cursor_row]
	ELSE IF .id [vt$b_char] GTR .id [vt$l_screen_absolute_bottom] + 31
	    THEN id [vt$l_saved_cursor_row] = .id [vt$l_cursor_row]
	    ELSE id [vt$l_saved_cursor_row] = .id [vt$b_char] - 31;
	id [vt$l_vt52_random_move_state] = 2;
	RETURN
	END;
    [2]: BEGIN
	!
	! check range of column
	!
	IF .line_state [.id [vt$l_saved_cursor_row]-1] EQL vt$k_single
	THEN right_edge = .id [vt$l_extreme_right]
	ELSE right_edge = .id [vt$l_extreme_right] / 2;
	IF (.id [vt$b_char] GTR 31) AND (.id [vt$b_char] LEQ .right_edge + 31)
	THEN id [vt$l_cursor_column] = .id [vt$b_char] - 31
	ELSE id [vt$l_cursor_column] = .right_edge;
	id [vt$l_cursor_row] = .id [vt$l_saved_cursor_row];
	!
	! set state back to start
	!
	id [vt$l_vt52_random_move_state] = 0;
	id [vt$w_state] = vt$k_straight_text;
	id [vt$v_last_col_flag] = 0;
	RETURN
	END;

    [OUTRANGE]: ;

    TES;

CASE .id [vt$b_char] FROM %C'A' TO %C'K'
OF SET
    !
    ! Up line
    !
    [%C'A']: 
	BEGIN
	IF .id [vt$l_cursor_row] GTR .id [vt$l_top_margin]
	THEN id [vt$l_cursor_row] = .id [vt$l_cursor_row] - 1;
	!
	! check range of column
	!
	IF .line_state [.id [vt$l_cursor_row]-1] EQL vt$k_single
	THEN right_edge = .id [vt$l_extreme_right]
	ELSE right_edge = .id [vt$l_extreme_right] / 2;
	!
	! If column to right of right_edge then set it to right edge
	!
	IF .id [vt$l_cursor_column] GTR .right_edge
	THEN id [vt$l_cursor_column] = .right_edge;
	id [vt$v_last_col_flag] = 0;
	END;			! End of cursor up

    !
    ! Line feed
    !
    [%C'B']: 
	BEGIN
	IF .id [vt$l_cursor_row] LSS .id [vt$l_bottom_margin]
	THEN id [vt$l_cursor_row] = .id [vt$l_cursor_row] + 1;
	!
	! check range of column
	!
	IF .line_state [.id [vt$l_cursor_row]-1] EQL vt$k_single
	THEN right_edge = .id [vt$l_extreme_right]
	ELSE right_edge = .id [vt$l_extreme_right] / 2;
	!
	! If column to right of right_edge then set it to right edge
	!
	IF .id [vt$l_cursor_column] GTR .right_edge
	THEN id [vt$l_cursor_column] = .right_edge;
	id [vt$v_last_col_flag] = 0;
	END;			! End of cursor down

    !
    ! Right Space
    !
    [%C'C']: 
	BEGIN
	IF .line_state [.id [vt$l_cursor_row]-1] EQL vt$k_single
	THEN right_edge = .id [vt$l_extreme_right]
	ELSE right_edge = .id [vt$l_extreme_right] / 2;
	IF .id [vt$l_cursor_column] LSS .right_edge
	THEN id [vt$l_cursor_column] = .id [vt$l_cursor_column] + 1
	ELSE id [vt$l_cursor_column] = .right_edge;
	id [vt$v_last_col_flag] = 0;
	END;

    ! 
    ! Left space
    !
    [%C'D']: IF .id [vt$l_cursor_column] GTR 1
	 THEN id [vt$l_cursor_column] = .id [vt$l_cursor_column] - 1;

    ! 
    ! No-op
    !	
    [%C'E']: ;

    !
    ! causes special graphics characters to be used
    !
    [%C'F']: BEGIN
	!
	!  Setup the IN_USE_TABLE for the line drawing character set
	!
	CH$MOVE( 32, vt$b_ascii_table, id [vt$b_trans_table] + 95);
	id [vt$b_vt52_char_set] = vt$k_line_drawing;
	END;

    !
    ! Causes the US/UK character set to be used
    !
    [%C'G']: BEGIN
	!
	!  Setup the IN_USE_TABLE for the normal character set
	!
	CH$MOVE( 128, vt$b_ascii_table, id [vt$b_trans_table]);
	id [vt$b_vt52_char_set] = vt$k_ascii_g;
	END;

    [%C'H']: BEGIN
	id [vt$v_last_col_flag] = 0;
	id [vt$l_cursor_row] = 1;
	id [vt$l_cursor_column] = 1;
	END;

    [%C'I']: process_up_line(.id); 

    [%C'J']: erase_characters(
				 .id 
				,.id [vt$l_cursor_row]
				,.id [vt$l_cursor_column]
				,.id [vt$l_bottom_margin]
				,.id [vt$l_extreme_right]
				 );

    [%C'K']: erase_characters(
				 .id
				,.id [vt$l_cursor_row]
				,.id [vt$l_cursor_column]
				,.id [vt$l_cursor_row]
				,.id [vt$l_extreme_right]
				 );

    [OUTRANGE]:
	CASE .id [vt$b_char] FROM %C'Y' TO %C'Z'
	OF SET
	    !
	    ! Start a random address move
	    !
	    [%C'Y']:BEGIN 
		id [vt$l_vt52_random_move_state] = 1;
		RETURN
		END;
	
	    !
	    ! Identify
	    !
	    [%C'Z']:
		BEGIN
		vsta$$kernel_call(
				vs$$acp_answerback,
				.id [vt$l_virtual_display_id],
				3,
				UPLIT BYTE(
					esc,
					%C'/',
					%C'Z'));
		END;

	    ! Outrange see if CHAR =<>
	    [OUTRANGE]: CASE .id [vt$b_char] FROM %C'<' to %C'>'
		OF SET
		    [%C'<']:
			begin
			vsta$$set_vt100_ansi (id[$base]);
			$update_settings (s100$k_ansi)
			end;
		    [%C'>']: vs$$set_vkb_char(
					    .id [vt$l_pasteboard_id],
					    vsta$m_keypad,
					    0,
					    .vs$gl_acp_pid);
		    [%C'=']: vs$$set_vkb_char(
					    .id [vt$l_pasteboard_id],
					    vsta$m_keypad,
					    vsta$m_keypad,
					    .vs$gl_acp_pid);
		    [OUTRANGE]: ;
		    TES;
	    TES;
	TES;

id [vt$w_state] = vt$k_straight_text;

RETURN

END;


ROUTINE process_vt102_del_char
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine will delete n characters from a line starting at current position
! As a character is deleted the characters to the right are move left and
! the right most character is replaced by a space.
!
! FORMAL PARAMETERS:
!
	(
	 id: REF device_data_table
	,n			! the number of characters to del from line
	):
!
! IMPLICIT INPUTS: NONE
!
! IMPLICIT OUTPUTS: NONE
!
! RETURN VALUE: NONE
!	
	VT_LINKAGE NOVALUE=
!
! COMPLETION CODES: NONE
!
! SIDE EFFECTS: 
!
!
!--
BEGIN

LOCAL
	 blanks_desc: VECTOR [2,LONG]
	,right_edge
	,nchars
	;

BIND
	 line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	;


flush_backlog(.id);

!-----------------------------------
! are we inside scrolling region
!-----------------------------------
IF (.id [vt$l_cursor_row] GTR .id [vt$l_bottom_margin]) OR
   (.id [vt$l_cursor_row] LSS .id [vt$l_top_margin])
THEN RETURN;

!
!  If double-width line, be careful not to go off edge
!
IF .line_state [.id [vt$l_cursor_row]-1] NEQ vt$k_single
THEN right_edge = .id [vt$l_extreme_right] / 2
ELSE right_edge = .id [vt$l_extreme_right];

!
!  Check the range of n.  Can't be more lines than in scrolling region
!  and can't be less than 1.
!
nchars = MIN( .right_edge - .id [vt$l_cursor_column] + 1,
	 MAX ( .n, 1));

vt$$dt_delete_chars_vt102 (
			 .id
			,.id [vt$l_cursor_row]
			,.id [vt$l_cursor_column]
			,.nchars
			);

vt$$dt_delete_chars_screen (
			 .id
			,.id [vt$l_cursor_row]
			,.id [vt$l_cursor_column]
			,.right_edge - .id [vt$l_cursor_column] + 1
			);

RETURN
END;


ROUTINE process_vt102_insert_line
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine inserts n lines at the line with the current cursor position.
! lines below current line move down and lines at the bottom are lost.
!
! FORMAL PARAMETERS:
!
	(
	 id: REF device_data_table
	,n
	):
!
! IMPLICIT INPUTS: NONE
!
! IMPLICIT OUTPUTS: NONE
!
! RETURN VALUE:
!
	VT_LINKAGE NOVALUE =
!
! COMPLETION CODES: NONE
!
! SIDE EFFECTS: 
!
!
!--
BEGIN

local	nrows;

BIND
	 line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	;

flush_backlog(.id);

id [vt$v_last_col_flag] = false;

!-----------------------------------
! are we inside scrolling region
!-----------------------------------
IF (.id [vt$l_cursor_row] GTR .id [vt$l_bottom_margin]) OR
   (.id [vt$l_cursor_row] LSS .id [vt$l_top_margin])
THEN RETURN;

!
!  Check the range of n.  Can't be more lines than in scrolling region
!  and can't be less than 1.
!
nrows = MIN( .id [vt$l_bottom_margin] - .id [vt$l_cursor_row] + 1,
	 MAX ( .n, 1));

!
!  Call routines to scroll down 
!
IF NOT vt$$dt_scroll_vt100(
			 .id
			,0
			,.id [vt$l_cursor_row]
			,.nrows
			)
  THEN $LOG_ERROR(vsta$_cntscruvt);

IF NOT vt$$dt_scroll_screen(
			 .id
			,0
			,.id [vt$l_cursor_row]
			,.nrows
			)
  THEN $LOG_ERROR(vsta$_cntscruvt);

!
!  Reset the cursor column to column one
!
id [vt$l_cursor_column] = 1;


RETURN

END;



ROUTINE process_vt102_del_line
!++
! FUNCIONAL DESCRIPTION:
!
! This routine deletes n lines starting from the current cursor position 
! lines created at the bottom of display have spaces with same character
! attributes as line above.
!
! FORMAL PARAMETERS:
!
	(
	 id: REF device_data_table
	,n
	):
!
! IMPLICIT INPUTS: NONE
!
! IMPLICIT OUTPUTS: NONE
!
! RETURN VALUE: NONE
!
	VT_LINKAGE	NOVALUE =
!
! COMPLETION CODES: NONE
!
! SIDE EFFECTS:
!
!
!--
BEGIN

local	nrows;

flush_backlog(.id);

id [vt$v_last_col_flag] = false;

!-----------------------------------
! are we inside scrolling region
!-----------------------------------
IF (.id [vt$l_cursor_row] GTR .id [vt$l_bottom_margin]) OR
   (.id [vt$l_cursor_row] LSS .id [vt$l_top_margin])
THEN RETURN;

!
!  Check the range of n.  Can't be more lines than in scrolling region
!  and can't be less than 1.
!
nrows = MIN( .id [vt$l_bottom_margin] - .id [vt$l_cursor_row] + 1,
	 MAX ( .n, 1));

!
!  Call routines to scroll up region
!
IF NOT vt$$dt_scroll_vt100(
			 .id
			,1
			,.id [vt$l_cursor_row]
			,.nrows
			)
  THEN $LOG_ERROR(vsta$_cntscruvt);

IF NOT vt$$dt_scroll_screen(
			 .id
			,1
			,.id [vt$l_cursor_row]
			,.nrows
			)
  THEN $LOG_ERROR(vsta$_cntscruvt);

!
!  Reset the cursor column to column one
!
id [vt$l_cursor_column] = 1;


RETURN
END;


ROUTINE process_control_character
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine handles ascii characters with a value less than octal 40.
! These fall into three categories: values which change the VT100 data base
! and/or screen, values which are ignored, and values which cause a change in
! the variable called "state". The last category consists of the characters
! escape (33), can (30) and sub (32). If an escape character is detected, the
! current state is set to "last character was escape" regardless of the
! previous state. If an escape or control sequence was in progress, it is
! aborted. If can or sub is detected, the state is set to "straight_text" and
! any escape or control sequence in progress is aborted.
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table):
		!Address of table containing state, modes,... of this VT100
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! The data table may be modified.
! The screen may be modified. 
! A character string may be inserted into the "read Vt100 queue" (answerback 
! message).
!
!--

BEGIN

LOCAL
	 right_edge
	;

!
! Redefine tabs,parameters,generation_buffer,and line_state
! as vectors for easy reference
! 
BIND
	 tabs = id [vt$v_tabs]: BITVECTOR [vt$k_maximum_columns]
 	,parameter = id [vt$w_parameters]: VECTOR [vt$k_maximum_parameter,WORD]
	,generation_buffer = id [vt$b_generation_buffer]: 
				VECTOR [vt$k_generation_max_index,BYTE]
	,line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	;

!
! Is this a C1 control character
!
IF .id [vt$b_char] GEQ 127
THEN BEGIN
    CASE .id [vt$b_char] FROM 127 TO 159 
    OF SET
	[132]:	! IND  Index 
	    process_line_feed(.id);

	[133]:	! NEL  Next Line
	    process_newline(.id);

	[136]:	! HTS  Set horizontal tabs
		! Disallow tab set in column 1
		!
	    IF .id [vt$l_cursor_column] GTR 1		
	    THEN begin
		vsta$$set_vt100_tab (
				id[$base],
				.id [vt$l_cursor_column]
				);
		$update_settings (s100$k_settab)
		end;

	[141]:	! RI  REverse Index
	    BEGIN
	    id [vt$v_last_col_flag] = false;
	    process_up_line(.id);	
	    END;

	[142]:	! SS2  Single shift two
	    BEGIN
	    id [vt$w_single_shift] = vt$k_ss2;

	    !
	    !  Return here since all other control codes clear
	    !  single shifts.
	    !
	    RETURN;
	    END;		! Single shift two

	[143]:	! SS3  Single shift three
	    BEGIN
	    id [vt$w_single_shift] = vt$k_ss3;

	    !
	    !  Return here since all other control codes clear
	    !  single shifts.
	    !
	    RETURN;
	    END;		! Single shift three

	[154]:	! DECID  request device identification
	    BEGIN
	    !
	    !  If we are in 8 bit transmittion then put a CSI into the buffer 
	    ! instead of esc[
	    !
	    IF (.id [vt$w_c1_transmission] EQL vt$k_c1_7bit)
	    OR (.id [vt$w_c1_transmission] EQL vt$k_bit7_nrc)
	    THEN BEGIN
		vsta$$kernel_call(
				vs$$acp_answerback,
				.id [vt$l_virtual_display_id],
				8,
				UPLIT BYTE(
					esc,
					%C'[',
					%C'?',
					%C'6',
					%C'2',
					%C';',
					%C'9',
					%C'c'));
		END
	    ELSE BEGIN
		vsta$$kernel_call(
				vs$$acp_answerback,
				.id [vt$l_virtual_display_id],
				7,
				UPLIT BYTE(
					155,
					%C'?',
					%C'6',
					%C'2',
					%C';',
					%C'9',
					%C'c'));
		END;
	    END;

	[155,144]:	! Start of <esc>[ sequence DCS string
	    BEGIN
	    !
	    !  Lets get rid of any gathered text
	    !
	    flush_backlog( .id);
	    ! Say "so far we have <ESC>["
	    id [vt$w_state] = vt$k_control_sequence;
	    !
	    ! Initialize parameters to default
	    !
	    INCR counter FROM 0 TO vt$k_maximum_parameter - 1 DO
		parameter [.counter] = 0;	
	    id [vt$b_current_parameter] = 0;
	    id [vt$w_private_parameter] = 0;
	    id [vt$w_intermediate_count] = 0;
	    END;

	[157]:;	! Now in Operating system command string
	[158]:;	! Now in Privacy Message
	[159]:;	! Application Program command
	[INRANGE]:;
	[OUTRANGE]:;
	TES;

    !
    !  All control codes turn off single shift except si or so and
    !  ss2 and ss3.
    !
    id [vt$w_single_shift] = vt$k_ssn;

    RETURN;

END;

!
!  Or is it a C0 control.
!
CASE .id [vt$b_char] FROM 0 to 31 OF
SET

    [enq]:
	BEGIN
	vsta$$kernel_call(
			vs$$acp_answerback,
			.id [vt$l_virtual_display_id],
			.id [vt$l_answerback_message_length],
			id [vt$b_answerback_message]);
	END;

    [bel]:	! BEL
	BEGIN
	VSTA$$KBRD_SOUND_BELL( .VS$GW_VBCHAN);
	END;

    [bs]:	! BS  Backspace
	BEGIN
	flush_backlog( .id);
	id [vt$v_last_col_flag] = false;
	IF .id [vt$l_cursor_column] GTR 1		!Check for cursor in column 2 or more
	THEN				!If so, back up one space
	    id [vt$l_cursor_column] = .id [vt$l_cursor_column] - 1;	!Decrement column pointer
	!No else - If cursor was in column 1, leave it there
	END;

    [ht]:	! HT  Horizontal TAB
	BEGIN
	!
	!  Determine where the right edge of the row is
	! 
	IF .line_state [.id [vt$l_cursor_row]-1] EQL vt$k_single
	THEN right_edge = .id [vt$l_extreme_right]
	ELSE right_edge = .id [vt$l_extreme_right] / 2;

	flush_backlog( .id);
	id [vt$v_last_col_flag] = false;
	IF .id [vt$l_cursor_column] LSS .right_edge	!Check for cursor up against right edge
	THEN    !
		! Increment cursor column until right edge or tab stop found
		!
	    DO id [vt$l_cursor_column] = .id [vt$l_cursor_column] + 1
	    UNTIL (.tabs [.id [vt$l_cursor_column]]) OR 
		  (.id [vt$l_cursor_column] GEQ .right_edge);
		!No "else"... If cursor at extreme right, it stays put.
	END;

    [lf,vt,ff]: ! LF , VT , FF
	BEGIN
	flush_backlog( .id);
	IF .id [vt$v_linefeed_newline]	!Check for "linefeed-newline" mode
	THEN id [vt$l_cursor_column] = 1;	!If so, go to next line, column 1
	process_line_feed (.id);	!Test things like bottom-margin, bottom-screen, etc...
	END;

    [cr]:	! CR  Carriage return
	BEGIN
	flush_backlog( .id);
	id [vt$v_last_col_flag] = false;
	id [vt$l_cursor_column] = 1;		!Cursor goes to extreme left

!	IF .id [vt$v_linefeed_newline]	!Check for "linefeed-newline" mode
!	THEN process_line_feed (.id);	!Test things like bottom-margin, bottom-screen, etc...

	END;

    [so]:	! SO  Locking shift one
	BEGIN			! Shift out
	IF .id [vt$w_single_shift] EQL vt$k_ssn
	THEN BEGIN
	    id [vt$w_gl_active_set] = vt$k_g1_set;
	    process_g_sets( .id, vt$k_g1_set, .id [vt$w_g1_set] ,vt$k_upd_gl);
	    END;

	!
	!  Return here since all other control codes turn off
	!  single shift.
	!
	RETURN;
	END;			! End of shift out

    [si]:	! SI  Locking shift zero
	BEGIN
	IF .id [vt$w_single_shift] EQL vt$k_ssn
	THEN BEGIN
	    id [vt$w_gl_active_set] = vt$k_g0_set;
	    process_g_sets( .id, vt$k_g0_set, .id [vt$w_g0_set] ,vt$k_upd_gl);
	    END;

	!
	!  Return here since all other control codes turn off
	!  single shift.
	!
	RETURN;
	END;		! End of shift in		

    [xon]:; !  BEGIN
	!
	!  Call the vd serice to set xon.  
	!  Disabled as not supported by VS100.
	!
	!  VS$$VDS_VD_SET_XON_XOFF( .id [vt$l_virtual_display_id],1);
	!
	!  END;

    [xoff]:;!  BEGIN
	!
	!  Call the vd serice to set xon
	!  Disabled as not supported by VS100.
	!
	!  VS$$VDS_VD_SET_XON_XOFF( .id [vt$l_virtual_display_id],0);
	!
	!  END;
    [can]:
	BEGIN
	id [vt$v_last_col_flag] = false;
	!Cancel escape or control sequence, if any in progress
	id [vt$w_state] = vt$k_straight_text;
	!put an error character in the buffer
	id [vt$b_char] = 2;
	!print error character
	process_printable_character (.id);
	END;

    [sub]:	! SUB
	BEGIN
	id [vt$v_last_col_flag] = false;
	id [vt$w_state] = vt$k_straight_text;	!Cancel escape or control sequence, if any in progress
	id [vt$b_char] = 160;			!Print backwards ?
	process_printable_character (.id);	!print error character
	END;

    [esc]:	!Escape character - start sequence
	BEGIN
	!
	!  Lets get rid of any gathered text
	!
	flush_backlog( .id);
	id [vt$w_state] = vt$k_last_character_was_escape;	!Next character will go to escape processor
	id [vt$w_intermediate_count] = 0;
	id [vt$b_intermediate_character] = 0;	!Say "no intermediate characters so far"
	id [vt$v_invalid_sequence] = false;	!Say "valid escape or control sequence so far"
	END;

    [INRANGE]:;	!Ignore anything not provided for above

    [OUTRANGE]:;

    TES;

!
!  All control codes except si and so turn off single shift
!
id [vt$w_single_shift] = vt$k_ssn;

END;

ROUTINE flush_backlog
!++
! FUNCTIONAL DESCRIPTION:
!
!  This  routine is called when circumstances require writing whatever text
!  has been accumulated so far.
! Those circumstances include;
! * Hit the right hand edge of the screen
! * Got a control character
! * Finished processing the caller's buffer
!  i.e. anything which might cause the cursor to go anywhere other than one
!  position to the right
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table):
		!Address of table containing state, modes,... of this VT100
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =	!No error possible
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! Text is written to the screen
!
!--

BEGIN
LOCAL
	 status
	,right_edge
	,column
	;

BIND
	line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE];

IF .id [vt$l_backlog_count] EQL 0 THEN RETURN;	! nothing to write

!
!   set typeface to the current line state
!
id [vt$l_current_typeface] = .line_state [.id [vt$l_cursor_row] - 1];

!
! Set address of backlog buffer for text routine
! 
id [vt$a_backlog] = id [vt$b_backlog];
!
! Send characters ahead to VDS text routine
! If in insert mode then perform insert text
!
IF .line_state [.id [vt$l_cursor_row]-1] EQL vt$k_single
THEN right_edge = .id [vt$l_extreme_right]
ELSE right_edge = .id [vt$l_extreme_right] / 2;

column = ( IF .id [vt$v_last_col_flag] 
	   THEN (.id [vt$l_cursor_column] - .id [vt$l_backlog_count] + 1)
	   ELSE (.id [vt$l_cursor_column] - .id [vt$l_backlog_count]) );

IF NOT .id [vt$v_vt102_insert_mode] 
THEN BEGIN
    IF NOT VT$$DT_DISPLAY_VT100_line (
				 .id
				,.id [vt$l_cursor_row]
				,.column
				)
    THEN $LOG_ERROR(vsta$_cntwrivttx);

    IF NOT VT$$DT_DISPLAY_SCREEN_line (
				 .id
				,.id [vt$l_cursor_row]
				,.column
				,.id [vt$l_backlog_count]
				)
    THEN $LOG_ERROR(vsta$_cntwrivttx);
    END
ELSE BEGIN
    IF NOT VT$$DT_INSERT_CHARS_VT102 (
				 .id
				,.id [vt$l_cursor_row]
				,.column
				)
    THEN $LOG_ERROR(vsta$_cntwrivttx);

    IF NOT VT$$DT_DISPLAY_SCREEN_line (
				 .id
				,.id [vt$l_cursor_row]
				,.column
				,.right_edge - .column + 1
				)
    THEN $LOG_ERROR(vsta$_cntwrivttx);
    END;

id [vt$l_backlog_count] = 0;

END;


ROUTINE process_line_feed
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine handles anything that causes the VT100 to perform a 
! "line feed", including the ascii characters lf, ff, vt, and the escape
! sequence "<ESC> D". The routine checks for cursor at bottom screen, cursor
! at  bottom  of  scrolling  area,  and  "linefeed-newline"  mode. In
! "linefeed-newline" mode, a line feed implies return to column one, as well
! as go to the next line. If the cursor is at the bottom of the scrolling
! area, scrolling occurs, and the cursor stays on the same line. If the
! cursor is at the bottom of the screen (assuming it's not also the bottom of
!the scrolling region), the cursor stays on the same line.
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table):
		!Address of table containing state, modes,... of this VT100
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =	!No error possible
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! The screen contents, or a portion thereof, may be scrolled upwards.
!
!--

BEGIN
BIND
	line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE];

!
!  Lets get rid of any gathered text
!
flush_backlog( .id);

!Check for cursor at bottom of scrolling region
IF .id [vt$l_cursor_row] EQL .id [vt$l_bottom_margin]
THEN BEGIN	!If so, scroll up contents of screen
    !
    !  Call routine to scroll up region
    !
    IF NOT vt$$dt_scroll_vt100(
				 .id
				,1
				,.id [vt$l_top_margin]
				,1
				)
    THEN $LOG_ERROR(vsta$_cntscruvt);

    IF NOT vt$$dt_scroll_screen(
				 .id
				,1
				,.id [vt$l_top_margin]
				,1
				)
    THEN $LOG_ERROR(vsta$_cntscruvt);
    END
ELSE BEGIN	!If not at bottom of scrolling region, go down one row
    IF .id [vt$l_cursor_row] LSS .id [vt$l_screen_absolute_bottom]	!Check for bottom of screen
    THEN BEGIN				!If not, go down one row
	id [vt$l_cursor_row] = .id [vt$l_cursor_row] + 1;	!Increment cursor row
	!
	!  If double-width line, be careful not to go off edge
	!
	IF .line_state [.id [vt$l_cursor_row]-1] NEQ vt$k_single
	THEN id [vt$l_cursor_column] = MIN
					(.id [vt$l_cursor_column],
					.id [vt$l_extreme_right] / 2);
	END;
     !No "else"... if bottom of screen, cursor stays put, no scroll, nothing.
     END;

!
!  Clear the last column flag
!
id [vt$v_last_col_flag] = false;
END;


ROUTINE process_line_feeds
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine handles anything that causes the VT100 to perform a bunch of
! "line feeds", including the ascii characters lf, ff, vt, and the escape
! sequence "<ESC> D". The routine checks for cursor at bottom screen, cursor
! at  bottom  of  scrolling  area,  and  "linefeed-newline"  mode. In
! "linefeed-newline" mode, a line feed implies return to column one, as well
! as go to the next line. If the cursor is at the bottom of the scrolling
! area, scrolling occurs, and the cursor stays on the same line. If the
! cursor is at the bottom of the screen (assuming it's not also the bottom of
!the scrolling region), the cursor stays on the same line.
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table	!Address of table containing state, modes,... of this VT100
	,nlines
	):

!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =	!No error possible
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! The screen contents, or a portion thereof, may be scrolled upwards.
!
!--

BEGIN

local	 dlines
	,slines
	,i
	;

BIND
	line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE];

!
!  Lets get rid of any gathered text
!
!flush_backlog( .id);

!Check for cursor at bottom of scrolling region
dlines = MIN ( (.id [vt$l_bottom_margin] - .id [vt$l_cursor_row]), .nlines );
slines = .nlines - .dlines;

WHILE ( .dlines GTR 0 )  DO BEGIN
    dlines = .dlines - 1;
    !If not at bottom of scrolling region, go down one row
    IF .id [vt$l_cursor_row] LSS .id [vt$l_screen_absolute_bottom]
					!Check for bottom of screen
    THEN BEGIN				!If not, go down one row
	id [vt$l_cursor_row] = .id [vt$l_cursor_row] + 1;  !Increment cursor row
	!
	!  If double-width line, be careful not to go off edge
	!
	IF .line_state [.id [vt$l_cursor_row]-1] NEQ vt$k_single
	THEN id [vt$l_cursor_column] = MIN
					(.id [vt$l_cursor_column],
					.id [vt$l_extreme_right] / 2);
	END;
    !No "else"... if bottom of screen, cursor stays put, no scroll, nothing.
    END;

IF ( .slines GTR 0 )
THEN BEGIN
    !
    !  Call routine to scroll up region
    !
    IF NOT vt$$dt_scroll_vt100(
				 .id
				,1
				,.id [vt$l_top_margin]
				,.slines
				)
    THEN $LOG_ERROR(vsta$_cntscruvt);

    IF NOT vt$$dt_scroll_screen(
				 .id
				,1
				,.id [vt$l_top_margin]
				,.slines
				)
    THEN $LOG_ERROR(vsta$_cntscruvt);
    END;

!
!  Clear the last column flag
!
id [vt$v_last_col_flag] = false;
END;


ROUTINE process_newline
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine performs the equivalent of return plus line feed. It checks
! for cursor at bottom of screen or bottom of scrolling region.
! If the cursor is at the bottom of the scrolling area, scrolling occurs,
! and the cursor stays on the same line.
! If the cursor is at the bottom of the screen (assuming it's not also the
! bottom of the scrolling region), the cursor stays on the same line.
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table):
		!Address of table containing state, modes,... of this VT100
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =	!No error possible
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! The contents of the screen, or some portion, may be scrolled upwards.
!
!--

BEGIN

!
!  Lets get rid of any gathered text
!
flush_backlog( .id);

id [vt$l_cursor_column] = 1;		!Cursor is going to left edge, no matter what else happens
process_line_feed (.id);		!The rest is same as line feed

END;

ROUTINE process_printable_character
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine handles characters in the range octal 40 to octal 176
! (printable characters), when they are not part of an escape or control
! sequence. 
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table):
		!Address of table containing state, modes,... of this VT100
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =	!No error possible
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN
BIND
	line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE],
	backlog = id [vt$b_backlog]: VECTOR [vt$k_maximum_columns,BYTE],
	g_set = id [vt$w_g0_set]: VECTOR [,WORD];

BIND	
	 tab = id [vt$b_trans_table]: VECTOR [,BYTE]
	;

LOCAL
	right_edge,
	character_set;

!
! Determine what part of the character set table this character is from
!
SELECTONE .id [vt$b_char] OF
SET
    [0 TO 31]: character_set = vt$k_ascii_c;
    [31 TO 126]: 
    !
    !  Check for single shift flags
    !
	SELECTONE .id [vt$w_single_shift] 
	OF SET
	    [vt$k_ssn]: character_set = .g_set [.id [vt$w_gl_active_set]];
	    [vt$k_ss2]: BEGIN
		character_set = .id [vt$w_g2_set];
		id [vt$w_single_shift] = vt$k_ssn;
		END;
	    [vt$k_ss3]: BEGIN
		character_set = .id [vt$w_g3_set];
		id [vt$w_single_shift] = vt$k_ssn;
		END;
	    TES;
			
    [127 TO 160]: character_set = vt$k_supplemental_c;
    [161 TO 254]: 
	SELECTONE .id [vt$w_single_shift] 
	OF SET
	    [vt$k_ssn]: character_set = .g_set [.id [vt$w_gr_active_set]];
	    [vt$k_ss2]: BEGIN
		character_set = .id [vt$w_g2_set];
		id [vt$w_single_shift] = vt$k_ssn;
		END;
	    [vt$k_ss3]: BEGIN
		character_set = .id [vt$w_g3_set];
		id [vt$w_single_shift] = vt$k_ssn;
		END;
	    TES;
    [OTHERWISE]: character_set = vt$k_supplemental_c;
    TES;

!
!  if backlog is full then flush it
!
IF .id [vt$l_backlog_count] GEQ vt$k_maximum_columns	
THEN flush_backlog (.id);

!
!  If we are in vt52 mode then get its character set
!
IF NOT .id [vt$v_ansi_vt52]
THEN character_set = .id [vt$b_vt52_char_set];

!
!  Determine the part of the font table in which to find the character
!  depends on which character set it is from
!
SELECTONE .character_set OF
SET 
    [vt$k_ascii_g]:
	backlog [.id [vt$l_backlog_count]] = .id [vt$b_char] AND 127; 
    [vt$k_supplemental_g]: 
	backlog [.id [vt$l_backlog_count]] = .id [vt$b_char] OR 128; 
    [vt$k_line_drawing]: 
	BEGIN
	local char: BYTE UNSIGNED;
	char = .id [vt$b_char] AND 127;
	IF .char LSS 95 
	THEN backlog [.id [vt$l_backlog_count]] = .char
	ELSE backlog [.id [vt$l_backlog_count]] = .char - 95;
	END;
    [vt$k_ascii_c,vt$k_supplemental_c]:
	backlog [.id [vt$l_backlog_count]] = .id [vt$b_char];
    [vt$k_uk_ascii_g]:
	IF .id [vt$b_char] EQL 35
	THEN backlog [.id [vt$l_backlog_count]] = 163
	ELSE backlog [.id [vt$l_backlog_count]] = .id [vt$b_char] AND 127; 
    [OTHERWISE]:
	backlog [.id [vt$l_backlog_count]] = .tab [.id [vt$b_char]];

    TES;	

id [vt$l_backlog_count] = .id [vt$l_backlog_count] + 1;		!Increment count of characters to go
id [vt$l_cursor_column] = .id [vt$l_cursor_column] + 1;

IF (.id [vt$v_auto_wrap] AND .id [vt$v_last_col_flag])
THEN process_newline(.id);

IF .line_state [.id [vt$l_cursor_row]-1] EQL vt$k_single
THEN right_edge = .id [vt$l_extreme_right]
ELSE right_edge = .id [vt$l_extreme_right] / 2;

!
!  Check for right edge of screen
!
IF .id [vt$l_cursor_column] GTR .right_edge	
THEN BEGIN
    flush_backlog (.id);	!Empty out characters stored up so far
    id [vt$l_cursor_column] = .right_edge;  
    id [vt$v_last_col_flag] = true;
    END;
END;



ROUTINE process_up_line
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine handles anything that causes the VT100 to perform a "virt tab",
! including the ascii characters vt and the escape sequence "<ESC> I"
! in vt52 mode. The routine checks for cursor at bottom screen, cursor at top
! of scrolling area. If the cursor is at the top of the scrolling area,
! scrolling occurs, and the cursor stays on the same line. If the cursor is
! at the top of the screen (assuming it's not also the top of the scrolling
! region), the cursor stays on the same line.
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table):
		!Address of table containing state, modes,... of this VT100
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =	!No error possible
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! The screen contents, or a portion thereof, may be scrolled downwards
!
!--

BEGIN
BIND
	line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE];

!
!  Lets get rid of any gathered text
!
flush_backlog( .id);

IF .id [vt$l_cursor_row] EQL .id [vt$l_top_margin]	!Check for top of scrolling region
THEN BEGIN			!If so, scroll down text
    IF NOT vt$$dt_scroll_vt100(
				 .id
				,0
				,.id [vt$l_top_margin]
				,1
				)
    THEN $LOG_ERROR(vsta$_cntscruvt);

    IF NOT vt$$dt_scroll_screen(
				 .id
				,0
				,.id [vt$l_top_margin]
				,1
			)
    THEN $LOG_ERROR(vsta$_cntscruvt);
    END
ELSE				!If not at top of scrolling region,
    IF .id [vt$l_cursor_row] GTR 1		! check for top of screen
    THEN					!If not, go up one row
	BEGIN
	id [vt$l_cursor_row] = .id [vt$l_cursor_row] - 1; !Decrement cursor row
	!
	!  If double-width line, be careful not to go off edge
	!
	IF .line_state [.id [vt$l_cursor_row]-1] NEQ vt$k_single
	THEN id [vt$l_cursor_column] = MIN
					(.id [vt$l_cursor_column],
					.id [vt$l_extreme_right] / 2);
	END;
!No "else"... if at top of non-scrolling region, cursor stays put
END;


ROUTINE process_up_lines
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine handles anything that causes the VT100 to perform a "virt tab",
! including the ascii characters vt and the escape sequence "<ESC> I"
! in vt52 mode. The routine checks for cursor at bottom screen, cursor at top
! of scrolling area. If the cursor is at the top of the scrolling area,
! scrolling occurs, and the cursor stays on the same line. If the cursor is
! at the top of the screen (assuming it's not also the top of the scrolling
! region), the cursor stays on the same line.
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table	!Address of table containing state, modes,... of this VT100
	,nlines
	):
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =	!No error possible
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! The screen contents, or a portion thereof, may be scrolled downwards
!
!--

BEGIN

local	 dlines
	,slines
	;
BIND
	line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE];

!
!  Lets get rid of any gathered text
!
flush_backlog( .id);

!Check for top of scrolling region
dlines = MIN ( (.id [vt$l_top_margin] - .id [vt$l_cursor_row]), .nlines) ;
slines = .nlines - .dlines;

WHILE (.dlines GTR 0 ) DO BEGIN
    dlines = .dlines - 1;
    !If not at top of scrolling region,
    IF .id [vt$l_cursor_row] GTR 1		! check for top of screen
    THEN					!If not, go up one row
	BEGIN
	id [vt$l_cursor_row] = .id [vt$l_cursor_row] - 1; !Decrement cursor row
	!
	!  If double-width line, be careful not to go off edge
	!
	IF .line_state [.id [vt$l_cursor_row]-1] NEQ vt$k_single
	THEN id [vt$l_cursor_column] = MIN
					(.id [vt$l_cursor_column],
					.id [vt$l_extreme_right] / 2);
	END;
!No "else"... if at top of non-scrolling region, cursor stays put
    end;

if ( .slines GTR 0 )
THEN BEGIN			!If so, scroll down text
    IF NOT vt$$dt_scroll_vt100(
				 .id
				,0
				,.id [vt$l_top_margin]
				,.SLINES
				)
    THEN $LOG_ERROR(vsta$_cntscruvt);

    IF NOT vt$$dt_scroll_screen(
				 .id
				,0
				,.id [vt$l_top_margin]
				,.SLINES
			)
    THEN $LOG_ERROR(vsta$_cntscruvt);
    END;

END;


ROUTINE process_escape_sequence
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine handles characters that come in after the start of an escape
! sequence has been identified, and keeps track of escape sequences that are
! "legal ANSI" and those that are "valid" for VT100 operation.
!
! "Legal" means that the sequence conforms to the ANSI definition of an
! escape sequence, which is "<ESC> I...I F", where I...I is a series of
! "intermediate characters" (range octal 40 to octal 57), and F is a "final
! character" (range octal 60 to octal 176). As long as the incoming escape
! sequence is legal, no action is taken until a final character is detected.
! If a character comes in which deviates from the legal definition, the
! sequence is aborted, and the state reverts to simple text processing.
!
! If a "final character" is detected, a complete, legal escape sequence has
! been received, and the routine checks for "validity". "Valid" means the
! escape sequence is recognized as a command which the VT100 understands. If
! the  sequence is valid, the action is determined by examining the
! intermediate and final characters. If not valid, the sequence is ignored.
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table):
		!Address of table containing state, modes,... of this VT100
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =	!No error possible
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! The data table for this VT100 may be updated.
! The contents of the screen may change.
!
!--

BEGIN

LOCAL
	 es_desc: VECTOR [2,LONG]
	;

! Redefine tabs and line state as vectors for easy reference
BIND
	intermediates = id [vt$b_intermediate_character]: 
			VECTOR [vt$k_max_num_intermediates,BYTE],
	line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE],
	tabs = id [vt$v_tabs]: BITVECTOR [vt$k_maximum_columns];

!
!  If this is a delete character then ignore it
!
IF .id [vt$b_char] EQL 127
THEN RETURN;


SELECTONE .id [vt$b_char] OF
SET

[32 TO 47]:	!This case is the legal range for intermediate characters
    IF .id [vt$w_intermediate_count] GEQ vt$k_max_num_intermediates
    THEN id [vt$v_invalid_sequence] = true
    ELSE BEGIN
	intermediates [.id [vt$w_intermediate_count]] = .id [vt$b_char];
	id [vt$w_intermediate_count] = .id [vt$w_intermediate_count] + 1;
    END;

[48 TO 126]:	!This case is the legal range for final character
    BEGIN
    !
    !  Convert <esc>(@ to _) to C1 control and call control character 
    !  process and reset state to straight text
    !
    IF ((.id [vt$w_intermediate_count] EQL 0) AND
	    (.id [vt$b_char] GEQ 64) AND
	    (.id [vt$b_char] LEQ 95))
    THEN BEGIN
	id [vt$b_char] = .id [vt$b_char] + 64;
	id [vt$w_state] = vt$k_straight_text;
	process_control_character(.id);
	return;
     END;
		
    IF .id [vt$v_invalid_sequence]	! Check for invalid sequence, i.e. more
    THEN BEGIN				! than one intermediate character
	id [vt$w_state] = vt$k_straight_text;
	RETURN;
    END;

    CASE .id [vt$w_intermediate_count] FROM 0 TO vt$k_max_num_intermediates OF
    SET
	[0]:	!The value zero means no intermediate character
	    !Select action based on final character
	    SELECTONE .id [vt$b_char] OF 
	    SET			!This set has no intermediate character

		[%C'7']:	! DECSC  Save cursor, attributes, character set
		    BEGIN	! (font)
		    !Save column
		    id [vt$l_saved_cursor_column] = .id [vt$l_cursor_column];
		    !Save row
		    id [vt$l_saved_cursor_row] = .id [vt$l_cursor_row];
		    !Save attributes
		    id [vt$b_saved_attributes] = .id [vt$b_attributes];
		    CH$MOVE(
			    8
			   ,id [vt$w_g0_set]
			   ,id [vt$w_saved_character_sets]);
		    id [vt$v_saved_last_col_flag] = .id [vt$v_last_col_flag];
		    id [vt$v_saved_origin_mode] = .id [vt$v_margin_origin];
		    END;

		[%C'8']:	! DECRC  Restore cursor, attributes, character 
		    BEGIN	!	 sets (fonts)
		    !If restoring to a double-width line, careful not to go
		    ! off edge
		    IF .line_state [.id [vt$l_saved_cursor_row]-1] EQL 
			   vt$k_single
			THEN id [vt$l_cursor_column] = 
						.id [vt$l_saved_cursor_column]
			ELSE id [vt$l_cursor_column] = 
					MIN (.id [vt$l_saved_cursor_column],
					     .id [vt$l_extreme_right] / 2);
		    !Restore row
		    id [vt$l_cursor_row] = .id [vt$l_saved_cursor_row];
		    !Restore attributes
		    id [vt$b_attributes] = .id [vt$b_saved_attributes];
		    CH$MOVE(
			 8
			,id [vt$w_saved_character_sets]
			,id [vt$w_g0_set]);
		    !
		    !  Update the in use table
		    !
		    process_g_sets( .id, vt$k_g0_set, .id [vt$w_g0_set]
						,vt$k_upd_all);
		    process_g_sets( .id, vt$k_g1_set, .id [vt$w_g1_set]
						,vt$k_upd_all);
		    process_g_sets( .id, vt$k_g2_set, .id [vt$w_g2_set]
						,vt$k_upd_all);
		    process_g_sets( .id, vt$k_g3_set, .id [vt$w_g3_set]
						,vt$k_upd_all);
		    id [vt$v_last_col_flag] = .id [vt$v_saved_last_col_flag];
		    id [vt$v_margin_origin] = .id [vt$v_saved_origin_mode];
		    IF .id [vt$v_margin_origin]
		    THEN BEGIN
			IF .id [vt$l_cursor_row] LSS .id [vt$l_top_margin]
			THEN .id [vt$l_cursor_row] = .id [vt$l_top_margin];
			IF .id [vt$l_cursor_row] GTR .id [vt$l_bottom_margin]
			THEN .id [vt$l_cursor_row] = .id [vt$l_bottom_margin]
		    END;

		END;

		[%C'=']:	! DECKPAM
		     vs$$set_vkb_char(
				.id [vt$l_pasteboard_id],
				vsta$m_keypad,
				vsta$m_keypad,
				.vs$gl_acp_pid);

		[%C'>']:	! DECKPNM
		     vs$$set_vkb_char(
				.id [vt$l_pasteboard_id],
				vsta$m_keypad,
				0,
				.vs$gl_acp_pid);

		[%C'c']:	! RIS  Perform a reset call routine to do this
		    begin
		    reset_vt100 (.id); 
		    $update_settings (-1)
		    end;

		[%C'n']:	! LS2  Locking shift two
		    IF .id [vt$w_conformance_level] EQL vt$k_level_2
		    THEN BEGIN
			id [vt$w_gl_active_set] = vt$k_g2_set;
			process_g_sets( .id, vt$k_g2_set, 
					.id [vt$w_g2_set], vt$k_upd_gl);
			END;
							
		[%C'o']:	! LS3  Locking shift three
		    IF .id [vt$w_conformance_level] EQL vt$k_level_2
		    THEN BEGIN
			id [vt$w_gl_active_set] = vt$k_g3_set;
			process_g_sets( .id, vt$k_g3_set, 
					.id [vt$w_g3_set], vt$k_upd_gl);
			END;

		[%C'|']:	! LS3R  Locking shift three right
		    IF .id [vt$w_conformance_level] EQL vt$k_level_2
		    THEN BEGIN
			id [vt$w_gr_active_set] = vt$k_g3_set;
			process_g_sets( .id, vt$k_g3_set, 
					.id [vt$w_g3_set], vt$k_upd_gr);
			END;	

		[%C'}']:	! LS2R  Locking shift two right
		    IF .id [vt$w_conformance_level] EQL vt$k_level_2
		    THEN BEGIN
			id [vt$w_gr_active_set] = vt$k_g2_set;
			process_g_sets( .id, vt$k_g2_set, 
					.id [vt$w_g2_set], vt$k_upd_gr);
			END;

		[%C'~']:	! LS1R  Locking Shift one right
		    IF .id [vt$w_conformance_level] EQL vt$k_level_2
		    THEN BEGIN
			id [vt$w_gr_active_set] = vt$k_g1_set;
			process_g_sets( .id, vt$k_g1_set, 
					.id [vt$w_g1_set], vt$k_upd_gr);
			END;

		TES;

	[1]: ! One intermediate value
	    SELECTONE .intermediates [0] OF
	    SET

		[%C'(']:	!This is the set of escape sequences of the 
				! form   <ESC> ( F  
		    SELECTONE .id [vt$b_char] OF
		    SET	
			[%C'A']: ! allow uk for any keyboard
			    process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_uk_ascii_g
						,vt$k_upd_all
						);
			[%C'B']: ! allow ascii for any keyboard
			    process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_ascii_g
						,vt$k_upd_all
						);
			[%C'0']: 
			    process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_line_drawing
						,vt$k_upd_all
						);
			[%C'<']: 
			    IF .id [vt$w_conformance_level] EQL vt$k_level_2
			    THEN 
				process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_supplemental_g
						,vt$k_upd_all
						);
			[%C'R']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_french_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_french_g
						,vt$k_upd_all
						);
			[%C'Q']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_frcan_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_frcan_g
						,vt$k_upd_all
						);
			[%C'E',%C'6']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_nordan_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_nordan_g
						,vt$k_upd_all
						);
			[%C'C',%C'5']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_finnish_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_finnish_g
						,vt$k_upd_all
						);
			[%C'K']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_german_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_german_g
						,vt$k_upd_all
						);
			[%C'4']:
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_dutch_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_dutch_g
						,vt$k_upd_all
						);
			[%C'Y']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_italian_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_italian_g
						,vt$k_upd_all
						);

			[%C'=']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_swiss_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_swiss_g
						,vt$k_upd_all
						);
			[%C'H',%C'7']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_swedish_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_swedish_g
						,vt$k_upd_all
						);
			[%C'Z']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_spanish_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g0_set
						,vt$k_spanish_g
						,vt$k_upd_all
						);

			TES;

		[%C')']:	! This is the set of escape sequences with the 
				! form   <ESC> ) F
		    SELECTONE .id [vt$b_char] OF
		    SET
			[%C'A']: ! allow uk for any keyboard
			     process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_uk_ascii_g
						,vt$k_upd_all
						);
			[%C'B']: ! allow ascii for any keyboard
			    process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_ascii_g
						,vt$k_upd_all
						);
			[%C'0']: 
			    process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_line_drawing
						,vt$k_upd_all
						);
			[%C'<']: 
			    IF .id [vt$w_conformance_level] EQL vt$k_level_2
			    THEN 
				process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_supplemental_g
						,vt$k_upd_all
						);
			[%C'R']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_french_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_french_g
						,vt$k_upd_all
						);
			[%C'Q']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_frcan_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_frcan_g
						,vt$k_upd_all
						);
			[%C'E',%C'6']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_nordan_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_nordan_g
						,vt$k_upd_all
						);
			[%C'C',%C'5']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_finnish_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_finnish_g
						,vt$k_upd_all
						);
			[%C'K']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_german_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_german_g
						,vt$k_upd_all
						);
			[%C'4']: 
			   IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_dutch_g
			   THEN process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_dutch_g
						,vt$k_upd_all
						);
			[%C'Y']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_italian_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_italian_g
						,vt$k_upd_all
						);
			[%C'=']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_swiss_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_swiss_g
						,vt$k_upd_all
						);
			[%C'H',%C'7']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_swedish_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_swedish_g
						,vt$k_upd_all
						);
			[%C'Z']: 
			    IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_spanish_g
			    THEN process_g_sets( 
						 .id
						,vt$k_g1_set
						,vt$k_spanish_g
						,vt$k_upd_all
						);

			TES;
		[%C'*']:	!This is the set of escape sequences
				!with the form   <ESC> * F
		    !
		    !  We can only designate character sets into g2 or
		    !  g3 if we are in level 2
		    !
		    IF .id [vt$w_conformance_level] EQL vt$k_level_2
		    THEN
			SELECTONE .id [vt$b_char] OF
			SET
			    [%C'A']: ! allow uk for any keyboard
				process_g_sets( 
						 .id
						,vt$k_g2_set
						,vt$k_uk_ascii_g
						,vt$k_upd_all
						);
			    [%C'B']: ! allow ascii for any keyboard 
				process_g_sets( 
						 .id
						,vt$k_g2_set
						,vt$k_ascii_g
						,vt$k_upd_all
						);
			    [%C'0']: 
				process_g_sets( 
						 .id
						,vt$k_g2_set
						,vt$k_line_drawing
						,vt$k_upd_all
						);
			    [%C'<']: 
				process_g_sets( 
						 .id
						,vt$k_g2_set
						,vt$k_supplemental_g
						,vt$k_upd_all
						);
			    [%C'R']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_french_g
				THEN process_g_sets( 
							 .id
							,vt$k_g2_set
							,vt$k_french_g
							,vt$k_upd_all
							);

			    [%C'Q']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_frcan_g
				THEN process_g_sets( 
							 .id
							,vt$k_g2_set
							,vt$k_frcan_g
							,vt$k_upd_all
							);

			    [%C'E',%C'6']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_nordan_g
				THEN process_g_sets( 
							 .id
							,vt$k_g2_set
							,vt$k_nordan_g
							,vt$k_upd_all
							);

			    [%C'C',%C'5']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_finnish_g
				THEN process_g_sets( 
							 .id
							,vt$k_g2_set
							,vt$k_finnish_g
							,vt$k_upd_all
							);
			    [%C'K']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_german_g
				THEN process_g_sets( 
							 .id
							,vt$k_g2_set
							,vt$k_german_g
							,vt$k_upd_all
							);
			    [%C'4']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_dutch_g
				THEN process_g_sets( 
							 .id
							,vt$k_g2_set
							,vt$k_dutch_g
							,vt$k_upd_all
							);
			    [%C'Y']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_italian_g
				THEN process_g_sets( 
							 .id
							,vt$k_g2_set
							,vt$k_italian_g
							,vt$k_upd_all
							);

			    [%C'=']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_swiss_g
				THEN process_g_sets( 
							 .id
							,vt$k_g2_set
							,vt$k_swiss_g
							,vt$k_upd_all
							);
			    [%C'H',%C'7']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_swedish_g
				THEN process_g_sets( 
							 .id
							,vt$k_g2_set
							,vt$k_swedish_g
							,vt$k_upd_all
							);
			    [%C'Z']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_spanish_g
				THEN process_g_sets( 
							 .id
							,vt$k_g2_set
							,vt$k_spanish_g
							,vt$k_upd_all
							);
			TES;

		[%C'+']:	!This is the set of escape sequences
				!with the form   <ESC> ) F
		    !
		    !  We can only designate character sets into g2 or
		    !  g3 if we are in level 2
		    !
		    IF .id [vt$w_conformance_level] EQL vt$k_level_2
		    THEN
			SELECTONE .id [vt$b_char] OF
			SET
			    [%C'A']: ! allow uk for any keyboard
				process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_uk_ascii_g
						,vt$k_upd_all
						);
			    [%C'B']: ! allow ascii for any keyboard
				process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_ascii_g
						,vt$k_upd_all
						);
			    [%C'0']: 
				process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_line_drawing
						,vt$k_upd_all
						);
			    [%C'<']: 
				process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_supplemental_g
						,vt$k_upd_all
						);
			    [%C'R']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_french_g
				THEN process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_french_g
						,vt$k_upd_all
						);

			    [%C'Q']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_frcan_g
				THEN process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_frcan_g
						,vt$k_upd_all
						);

			    [%C'E',%C'6']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_nordan_g
				THEN process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_nordan_g
						,vt$k_upd_all
						);

			    [%C'C',%C'5']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_finnish_g
				THEN process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_finnish_g
						,vt$k_upd_all
						);
			    [%C'K']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_german_g
				THEN process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_german_g
						,vt$k_upd_all
						);
			    [%C'4']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_dutch_g
				THEN process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_dutch_g
						,vt$k_upd_all
							);
			    [%C'Y']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_italian_g
				THEN process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_italian_g
						,vt$k_upd_all
						);
			    [%C'=']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_swiss_g
				THEN process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_swiss_g
						,vt$k_upd_all
						);
			    [%C'H',%C'7']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_swedish_g
				THEN process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_swedish_g
						,vt$k_upd_all
						);
			    [%C'Z']: 
				IF .vt$l_kbd_gset_table [.srv$gl_kbd_set]
					 EQL vt$k_spanish_g
				THEN process_g_sets( 
						 .id
						,vt$k_g3_set
						,vt$k_spanish_g
						,vt$k_upd_all
						);

			TES;

		[%C' ']:	! Set transmission either 8bit or 7bit...
		    SELECTONE .id [vt$b_char] OF
		    SET
			[%C'F']:	! S7C1T
			    IF .id [vt$w_conformance_level] EQL vt$k_level_2
			    THEN BEGIN
				id [vt$w_c1_transmission] = vt$k_c1_7bit;
				vs$$set_vkb_char(
					      .id [vt$l_pasteboard_id],
					      vsta$m_eightbit,
					      0,
					      .vs$gl_acp_pid);
				$update_settings(-1);
			    END;
			[%C'G']:	! S8C1T
			    IF .id [vt$w_conformance_level] EQL vt$k_level_2
			    THEN BEGIN
				id [vt$w_c1_transmission] = vt$k_c1_8bit;
				vs$$set_vkb_char(
					      .id [vt$l_pasteboard_id],
					      vsta$m_eightbit OR vsta$m_vt52,
					      vsta$m_eightbit,
					      .vs$gl_acp_pid);
				$update_settings(-1);
				END;
		    TES;
				
		[%C'#']:	!This is the set of escape sequences
				!with the form   <ESC> # F
		    BEGIN
		    CASE .id [vt$b_char] FROM %C'3' TO %C'8' OF
		    SET
			[%C'3']:	! DECDHLT
			    BEGIN
			    id [vt$v_last_col_flag] = false;
			    IF .line_state [.id [vt$l_cursor_row]-1] NEQ 
					vt$k_dhtop
			    THEN BEGIN
				VT$$DT_SET_VT100_LINE_ATT (
							 .id
							,.id[vt$l_cursor_row]
							,vt$k_dhtop
							);
				id [vt$l_cursor_column] = 
					    MIN( .id [vt$l_cursor_column], 
						 .id [vt$l_extreme_right]/2);
				vt$$dt_display_screen_line (
						 .id
						,.id [vt$l_cursor_row]
						,1
						,.id[vt$l_cursor_column]
						);
				end;
			    END;

			[%C'4']:	! DECDHLB
			    BEGIN
			    id [vt$v_last_col_flag] = false;
			    IF .line_state [.id [vt$l_cursor_row]-1] NEQ 
					vt$k_dhbot
			    THEN BEGIN
				VT$$DT_SET_VT100_LINE_ATT (
							 .id
							,.id[vt$l_cursor_row]
							,vt$k_dhbot
							);
				id [vt$l_cursor_column] = 
					    MIN( .id [vt$l_cursor_column], 
						 .id [vt$l_extreme_right]/2);
				vt$$dt_display_screen_line (
						 .id
						,.id [vt$l_cursor_row]
						,1
						,.id [vt$l_cursor_column]
						);
				end;
			    END;

			[%C'5']:	! DECSWL
			    BEGIN
			    id [vt$v_last_col_flag] = false;
			    IF .line_state [.id [vt$l_cursor_row]-1] NEQ 
					vt$k_single 
			    THEN BEGIN
				VT$$DT_SET_VT100_LINE_ATT (
							 .id
							,.id[vt$l_cursor_row]
							,vt$k_single
							);
				vt$$dt_display_screen_line (
						 .id
						,.id [vt$l_cursor_row]
						,1
						,.id [vt$l_extreme_right]
						);
				END;
			    END;

			[%C'6']:	! DECDWL
			    BEGIN
			    id [vt$v_last_col_flag] = false;
			    IF .line_state [.id [vt$l_cursor_row]-1] NEQ 
					vt$k_dwidth 
			    THEN BEGIN
				VT$$DT_SET_VT100_LINE_ATT (
							 .id
							,.id[vt$l_cursor_row]
							,vt$k_dwidth
							);
				id [vt$l_cursor_column] = 
					    MIN( .id [vt$l_cursor_column], 
						 .id [vt$l_extreme_right]/2);
				vt$$dt_display_screen_line (
						 .id
						,.id [vt$l_cursor_row]
						,1
						,.id [vt$l_cursor_column]
						);
				end;
			    END;

			[%C'8']:	! DECALN
			    BEGIN
			    !
			    ! Reset default font for all lines.  Write E's 
			    ! all over screen
			    !
			    ! Turn off all attributes
			    !
			    id [vt$b_attributes] = 0;	
			    vt$$dt_decaln_vt100 (.id);
			    vt$$dt_redisplay_screen (.id);
			    id [vt$l_top_margin] = 1;
			    id [vt$l_bottom_margin] = 
					.id [vt$l_screen_absolute_bottom];
			    id [vt$v_last_col_flag] = false;
			    id [vt$l_cursor_row] = 1;
			    id [vt$l_cursor_column] = 1;
			    END;
			[INRANGE]:;
			[OUTRANGE]:;
		    TES;
		    END;
		TES;

	[2]:;	! Level two conformance to desinate character sets
		
	[3]:;	! Here for future use

	[INRANGE]:;
	[OUTRANGE]:;
    TES;

    !
    !No ELSE here - If sequence invalid, but legal and complete, drop back to 
    !text mode.
    !
    id [vt$w_state] = vt$k_straight_text;  !Also if sequence is legal, valid, 
					   !and processed - go to text mode.

    END;

[OTHERWISE]: !Illegal escape sequence - drop back to text mode
	 id [vt$w_state] = vt$k_straight_text;

TES;
END;

ROUTINE process_control_sequence
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine handles characters that come in after the start of a control
! sequence has been identified, and keeps track of control sequences that are
! "legal ANSI" and those that are "valid" for VT100 operation.
!
! "Legal" means that the sequence conforms to the ANSI definition of a
! control sequence, which is "<CSI> P;P;...;P F", where P;P;...;P is a series
! of parameters each of which consists of a string of decimal digits (range
! octal 60 to octal 71), separated by semicolons (octal 73), and F is a
! "final character" (range octal 100 to octal 176). As long as the incoming
! control sequence is legal, no action is taken until a final character is
! detected. If a character comes in which deviates from the legal definition,
! the sequence is aborted, and the state reverts to simple text processing.
!
! <CSI> means an escape character followed by a left bracket: <ESC> [
!
!
! If a "final character" is detected, a complete, legal control sequence
! has been received, and the routine checks for "validity". "Valid" means the
! control sequence is recognized as a command which the VT100 understands. If
! the sequence is valid, the action is determined by examining the parameters
! and final character. If not valid, the sequence is ignored.
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table):
		!Address of table containing state, modes,... of this VT100
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =	!No error possible
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! The data table mey be modified.
! The contents of the virtual display screen may change.
!
!--

BEGIN

LOCAL
	 blanks_desc: VECTOR [2,LONG]
	,right_edge
	,num
	,digit
	;

LABEL
	eras1,	!Screen erase CASE expression
	eras2,	!Line erase CASE expression
	rend;	!Graphics rendition CASE expression

!
! Redefine parameters as a vector for easy reference
! Also redefine tabs as bitvector for easy reference
!
BIND
	line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE],
	tabs = id [vt$v_tabs]: BITVECTOR [vt$k_maximum_columns],
	parameter = id [vt$w_parameters]: VECTOR [vt$k_maximum_parameter,WORD],
	intermediates = id [vt$b_intermediate_character]: 
			VECTOR [vt$k_max_num_intermediates,BYTE],
	generation_buffer = id [vt$b_generation_buffer]: 
			    VECTOR [vt$k_generation_max_index,BYTE];


!
!  Ignore delete characters
!
IF .id [vt$b_char] EQL 127 
THEN RETURN;


!  Check for private parameter If it is a ? then set state to vt$k_dec_private
!
IF (.id [vt$w_intermediate_count] EQL 0) AND 
   (.id [vt$b_current_parameter] EQL 0) AND
   (.id [vt$b_char] GEQ 60) AND 
   (.id [vt$b_char] LEQ 63)
THEN BEGIN
	id [vt$w_private_parameter] = 64 - .id [vt$b_char];
	RETURN;
     END;
	

!
!  Now get all control parameters
!
IF (.id [vt$b_char] GEQ 48) AND (.id [vt$b_char] LEQ 63)
THEN BEGIN
    IF .id [vt$w_intermediate_count] EQL 0
    THEN BEGIN
	process_control_parameters (.id);
	RETURN
	END;
    !
    !  Parameters are not allowed after the existance of intermediate
    !  values go back to straight text
    !
    id [vt$v_invalid_sequence] = true;
    RETURN;
    END;

!
!  Are there any intermediate values
!
IF (.id [vt$b_char] GEQ 32) AND (.id [vt$b_char] LEQ 47)
THEN BEGIN
    IF .id [vt$w_intermediate_count] GEQ vt$k_max_num_intermediates
    THEN BEGIN
	!
	!  If invalid number of intermediates then go back to text mode
	!
	id [vt$v_invalid_sequence] = true;
	RETURN
	END;
    intermediates [.id [vt$w_intermediate_count]] = .id [vt$b_char];
    id [vt$w_intermediate_count] = .id [vt$w_intermediate_count] + 1;
    RETURN;
    END;

!
!Check for past indication that sequence is invalid
!If we already know it's invalid, drop back to text mode and do nothing
!
IF .id [vt$v_invalid_sequence]	
THEN
    BEGIN
    id [vt$w_state] = vt$k_straight_text;	!Set state to text mode
    id [vt$v_invalid_sequence] = false;
    RETURN			! and quit
    END;

IF .id [vt$w_private_parameter] EQL 1
THEN BEGIN
    process_dec_private_sequence(.id);
    RETURN;
    END;

!
!  If there are intermediates and this is not a change of conformance then
!  the sequence is invalid.
!
IF (.id [vt$b_char] NEQ %C'p') AND
   (.id [vt$w_intermediate_count] GTR 0)

THEN BEGIN			! Don't do anything
    id [vt$w_state] = vt$k_straight_text;
    id [vt$v_invalid_sequence] = false;
    RETURN		
    END;			! End of don't do anything

SELECTONE .id [vt$b_char] OF
SET

    [%C'@']:	! ICH
	!
	!  If not in level 2 then don't do this function
	!
	IF .id [vt$w_conformance_level] EQL vt$k_level_2
	THEN INCR counter FROM 0 TO .id [vt$b_current_parameter]
	     DO BEGIN

		local n;

		flush_backlog ( .id);

		IF .line_state [.id [vt$l_cursor_row]-1] EQL vt$k_single
		THEN right_edge = .id [vt$l_extreme_right]
		ELSE right_edge = .id [vt$l_extreme_right] / 2;

		n = MAX ( .parameter [.counter], 1);
		IF (.id [vt$l_cursor_column] + .n) GTR .right_edge
		THEN n = .right_edge - .id [vt$l_cursor_column] + 1;

		id [vt$l_current_typeface] = .line_state [.id [vt$l_cursor_row] - 1];

		IF NOT VT$$DT_erase_CHARS_VT100 (
						 .id
						,.id [vt$l_cursor_row]
						,.id [vt$l_cursor_column]
						,.n
						)
		THEN $LOG_ERROR(vsta$_cntwrivttx);

		IF NOT VT$$DT_DISPLAY_SCREEN_line (
						 .id
						,.id [vt$l_cursor_row]
						,.id [vt$l_cursor_column]
						,.n
						)
		THEN $LOG_ERROR(vsta$_cntwrivttx);

		END;		! End of insert character

    [%C'A']:	! CUU
		! Move cursor up by <first parameter> rows.
	BEGIN
	id [vt$v_last_col_flag] = 0;
	!
	!Check whether below top of scrolling region
	!If below top margin, go up but only as far as top of scrolling region
	!If above top margin, go up but only as far as top of screen
	!
	IF .id [vt$l_cursor_row] GEQ .id [vt$l_top_margin]
	    THEN id [vt$l_cursor_row] = MAX
				(.id [vt$l_top_margin]
				,.id [vt$l_cursor_row] 
				  - MAX (1,.parameter [0]))
					 ! zero or missing defaults to one
	    ELSE id [vt$l_cursor_row] = MAX
				(1
				,.id [vt$l_cursor_row] 
				  - MAX (1,.parameter [0]));
					 ! zero or missing defaults to one

	!
	!if double-width line, be careful not to go off edge
	!
	IF .line_state [.id [vt$l_cursor_row]-1] NEQ vt$k_single
	THEN id [vt$l_cursor_column] = MIN (.id [vt$l_cursor_column],
						.id [vt$l_extreme_right] / 2);
	END;

    [%C'B']:	! CUD
		!Move cursor down by <first parameter> rows.
	BEGIN
	id [vt$v_last_col_flag] = 0;
	!
	!Check whether above bottom of scrolling region
	!If above, go down but only as far as bottom of region
	!If below scrolling region, go down only as far as bottom of screen
	!
	IF .id [vt$l_cursor_row] LEQ .id [vt$l_bottom_margin]
	    THEN id [vt$l_cursor_row] = MIN	
				(.id [vt$l_bottom_margin]
				,.id [vt$l_cursor_row] 
				+ MAX (1,.parameter [0]))
					 ! zero or missing defaults to one
	    ELSE id [vt$l_cursor_row] = MIN
				(.id [vt$l_screen_absolute_bottom]
				,.id [vt$l_cursor_row] 
				+ MAX (1,.parameter [0]));
					 ! zero or missing defaults to one

	!
	!if double-width line, be careful not to go off edge
	!
	IF .line_state [.id [vt$l_cursor_row]-1] NEQ vt$k_single
		THEN id [vt$l_cursor_column] = MIN
						(.id [vt$l_cursor_column],
						.id [vt$l_extreme_right] / 2);
	END;

    [%C'C']:	! CUF
		!Move cursor right by <first parameter> columns
	BEGIN
	IF .line_state [.id [vt$l_cursor_row]-1] NEQ vt$k_single
	THEN right_edge = .id [vt$l_extreme_right] / 2
	ELSE right_edge = .id [vt$l_extreme_right];

	id [vt$l_cursor_column] = MIN (.right_edge ,.id [vt$l_cursor_column] + 
				  MAX (1,.parameter [0]));
	END;

    [%C'D']:	! CUB
		!Move cursor left by <first parameter> columns.
	BEGIN
	id [vt$v_last_col_flag] = 0;
	id [vt$l_cursor_column] = MAX	!Go left
			(1	! only as far edge of screen
			,.id [vt$l_cursor_column] - MAX (1,.parameter [0]));
					 ! zero or missing defaults to one
	!
	!if double-width line, be careful not to go off edge
	!
	IF .line_state [.id [vt$l_cursor_row]-1] NEQ vt$k_single
	    THEN id [vt$l_cursor_column] = MIN (.id [vt$l_cursor_column],
						.id [vt$l_extreme_right] / 2);
	END;

    [%C'H',%C'f']:	! CUP, HVP
			!Random cursor positioning
	BEGIN
	id [vt$v_last_col_flag] = false;
	!
	!Set column to smaller of right edge of screen or parameter value
	!
	id [vt$l_cursor_column] = MIN
			(.id [vt$l_extreme_right]
			,MAX (1,.parameter [1]));
				! zero or missing defaults to one
	!
	!Check for origin within scrolling region (margins)
	!If origin in margins, stay within them
	!Column not allowed to go above top or below bottom
	!If origin top left of whole screen, stay within screen top and bottom
	!
	IF .id [vt$v_margin_origin]
	    THEN id [vt$l_cursor_row] = MIN
				(.id [vt$l_bottom_margin]
				,MAX (.id [vt$l_top_margin], 
				  .parameter [0] + .id [vt$l_top_margin] - 1))
			! zero or missing defaults to top of scrolling region
	    ELSE id [vt$l_cursor_row] = MIN
				(.id [vt$l_screen_absolute_bottom]
				,MAX (1,.parameter [0]));
					! zero or missing defaults to one
	!
	!if double-width line, be careful not to go off edge
	!
	IF .line_state [.id [vt$l_cursor_row]-1] NEQ vt$k_single
		THEN id [vt$l_cursor_column] = MIN
						(.id [vt$l_cursor_column],
						.id [vt$l_extreme_right] / 2);
	END;

    [%C'J']:	! ED or DECSED?
		!Erase within screen
	INCR counter FROM 0 TO .id [vt$b_current_parameter] DO	
	!Go through all parameters
	eras1:	BEGIN
	    CASE .parameter [.counter] FROM 0 TO 2 OF
	    !Select action based on parameter
	    SET
		[0]:
		    BEGIN
		    !set any lines erased to single width!!!
		    INCR count FROM (IF .id [vt$l_cursor_column] EQL 1
					THEN .id [vt$l_cursor_row]
					ELSE .id [vt$l_cursor_row] + 1)
				TO .id [vt$l_screen_absolute_bottom]
		    DO (line_state [.count - 1] = vt$k_single);
		    erase_characters	!Erase from cursor to end of screen
				(.id
				,.id [vt$l_cursor_row]
				,.id [vt$l_cursor_column]
				,.id [vt$l_screen_absolute_bottom]
				,.id [vt$l_extreme_right]);
		    END;
		[1]:
		    BEGIN
		    !set any lines erased to single width!!!
		    IF .line_state [.id [vt$l_cursor_row]-1] NEQ vt$k_single
		    THEN right_edge = .id [vt$l_extreme_right] / 2
		    ELSE right_edge = .id [vt$l_extreme_right];
		    INCR count FROM 1
				TO (IF .id [vt$l_cursor_column] EQL .right_edge
					THEN .id [vt$l_cursor_row]
					ELSE .id [vt$l_cursor_row] - 1)
		    DO (line_state [.count - 1] = vt$k_single);
		    !Erase from beginning of screen to cursor
		    erase_characters
				(.id
				,1
				,1
				,.id [vt$l_cursor_row]
				,.id [vt$l_cursor_column]);
		    END;

		!erase entire screen
		[2]:
		    BEGIN
		    !set lines erased to single width!!!
		    VT$$DT_CLEAR_VT100 (.id);
		    VT$$DT_CLEAR_SCREEN (.id);
		    END;

		[OUTRANGE]: LEAVE eras1;

	    TES;
	END;

    [%C'K']:	! EL or DECSEL?
		!Erase within line
	INCR counter FROM 0 TO .id [vt$b_current_parameter] DO
	!Go through all parameters
	eras2:	BEGIN
	    CASE .parameter [.counter] FROM 0 TO 2 OF
	    !Select action based on parameter
	    SET
		[0]: erase_characters 	!Erase from cursor to end of line
			(.id
			,.id [vt$l_cursor_row]
			,.id [vt$l_cursor_column]
			,.id [vt$l_cursor_row]
			,.id [vt$l_extreme_right]);
		[1]: erase_characters 	!Erase from beginning of line to cursor
			(.id
			,.id [vt$l_cursor_row]
			,1
			,.id [vt$l_cursor_row]
			,.id [vt$l_cursor_column]);
		[2]: erase_characters
			(.id,
			.id [vt$l_cursor_row],
			1,
			.id [vt$l_cursor_row],
			.id [vt$l_extreme_right]);
			
		[OUTRANGE]: LEAVE eras2;
	    TES;
	END;
    [%C'P']:	! DCH
	INCR counter FROM 0 TO .id [vt$b_current_parameter] DO
	process_vt102_del_char(.id,.parameter [.counter]);

    [%C'L']: 	! IL
	INCR counter FROM 0 TO .id [vt$b_current_parameter] DO
	process_vt102_insert_line(.id,.parameter [.counter]);

    [%C'M']:	! DL
	INCR counter FROM 0 TO .id [vt$b_current_parameter] DO
	process_vt102_del_line(.id,.parameter [.counter]);

    !
    !  Erase characters
    !
    [%C'X']:	! ECH
	IF .id [vt$w_conformance_level] EQL vt$k_level_2
	THEN INCR counter FROM 0 TO .id [vt$b_current_parameter]
	DO BEGIN			! Erase characters
	    local n;
	    !
	    ! If n is 0 then make it one
	    !
	    n = MAX(1,.parameter [.counter]);
	    IF .line_state [.id [vt$l_cursor_row]-1] NEQ vt$k_single
	    THEN right_edge = .id [vt$l_extreme_right] / 2
	    ELSE right_edge = .id [vt$l_extreme_right];
	    IF (.id [vt$l_cursor_column] + .n) GTR .right_edge
	    THEN n = .right_edge - .id [vt$l_cursor_column] + 1;
	    erase_characters (
				 .id
				,.id [vt$l_cursor_row]
				,.id [vt$l_cursor_column]
				,.id [vt$l_cursor_row]
				,.id [vt$l_cursor_column] + .n - 1
				);
	    END;			! End of erase characters

    [%C'c']:	!Report device attributes
	! DA(1)
	!Insert device attributes in KB stream
	BEGIN
	SELECTONE .id [vt$w_private_parameter]
	OF SET
	    [0]: BEGIN
		IF (.id [vt$w_c1_transmission] EQL vt$k_c1_7bit)
		OR (.id [vt$w_c1_transmission] EQL vt$k_bit7_nrc)
		THEN BEGIN
		    vsta$$kernel_call(
					vs$$acp_answerback,
					.id [vt$l_virtual_display_id],
					8,
					UPLIT BYTE(
						esc,
						%C'[',
						%C'?',
						%C'6',
						%C'2',
						%C';',
						%C'9',
						%C'c'));
		     END
		ELSE BEGIN
		    vsta$$kernel_call(
					vs$$acp_answerback,
					.id [vt$l_virtual_display_id],
					7,
					UPLIT BYTE(
						155,
						%C'?',
						%C'6',
						%C'2',
						%C';',
						%C'9',
						%C'c'));
		     END;
		END;
	    [2]:	! DA(2)
		BEGIN ! Secondary device attributes
		IF (.id [vt$w_c1_transmission] EQL vt$k_c1_7bit)
		OR (.id [vt$w_c1_transmission] EQL vt$k_bit7_nrc)
		THEN BEGIN
			vsta$$kernel_call(
					vs$$acp_answerback,
					.id [vt$l_virtual_display_id],
					14,
					UPLIT BYTE(
						esc,
						%C'[',
						%C'>',
						%C'5',
						%C';',
						%C'1',
						%C'0',
						%C'0',
						%C';',
						%C'1',
						%C'1',
						%C';',
						%C'1',
						%C'c'));
		     END
		ELSE BEGIN
			vsta$$kernel_call(
					vs$$acp_answerback,
					.id [vt$l_virtual_display_id],
					13,
					UPLIT BYTE(
						155,	! 8bit c1
						%C'>',
						%C'5',	! Product ID
						%C';',
						%C'1',	! VS100
						%C'0',
						%C'0',
						%C';',
						%C'1',	! Version 1.1
						%C'1',
						%C';',
						%C'1',
						%C'c'));
		     END;
		END;
	    [OTHERWISE]:;
	TES;
    END;

    [%C'g']:	! TBC
		!Reset tab(s)
	INCR counter FROM 0 TO .id [vt$b_current_parameter] DO
	!Go through all parameters
	SELECTONE .parameter [.counter] OF  !select action based on parameter
	SET
	    [0]:
		begin
		vsta$$clear_vt100_tab (
				id[$base],
				.id [vt$l_cursor_column]
				);
		$update_settings (s100$k_cleartab)
		end;
	    [3]: INCR position FROM 1 TO .id [vt$l_extreme_right] DO
		!Reset all tabs
		tabs [.position - 1] = 0;
	TES;
    [%C'h']:	!Set mode 	SM
	INCR counter FROM 0 TO .id [vt$b_current_parameter] DO
	!Go through all parameters
	SELECTONE .parameter [.counter] OF
	SET
	    [3]:	! Control representation mode
		BEGIN
		id [vt$v_crm] = true;
		id [vt$w_crm_state] = 0;
		id [vt$w_g2_set] = vt$k_supplemental_g;
		id [vt$w_gr_active_set] = .id [vt$w_g2_set];
		END;
	    [4]:	! IRM
		BEGIN
		flush_backlog(.id);
		id [vt$v_vt102_insert_mode] = true;
		id [vt$v_last_col_flag] = 0;
		END;
	    [20]:   ! LNM
		BEGIN
		vsta$$set_vt100_newline (id[$base]);
		$UPDATE_SETTINGS(s100$k_newline);
		END;
	    [42]:	! DECNRC
		BEGIN
		vsta$$set_vt100_nrc (id[$base]);
		$UPDATE_SETTINGS(-1);
		END;
	TES;

    [%C'l']:	!RESet mode 	RM
	INCR counter FROM 0 TO .id [vt$b_current_parameter] DO
	!Go through all parameters
	SELECTONE .parameter [.counter] OF
	SET
	    [4]:	! IRM
		BEGIN
		flush_backlog(.id);
		id [vt$v_vt102_insert_mode] = false;
		id [vt$v_last_col_flag] = 0;
		END;
	    [20]:	! LNM
		BEGIN
		vsta$$set_vt100_oldline (id[$base]);
		$UPDATE_SETTINGS(s100$k_oldline);
		END;
	    [42]:	! DECNRC
		BEGIN
		vsta$$set_vt100_level (id[$base], prof$k_vt_level2);
		$UPDATE_SETTINGS(-1);
		END;
	TES;

    [%C'm']:	! SGR
		!Set or reset attributes (sometimes called graphics rendition)
	INCR counter FROM 0 TO .id [vt$b_current_parameter] DO
	!Go through all parameters
	rend:	BEGIN
	    SELECTONE .parameter[.counter] !Select action based on parameter
	    OF SET
		[0]:
		    BEGIN
		    id [vt$b_attributes] = 0;		!Set all attributes off
		    END;
		[1]:
		    BEGIN
		    id [vt$v_bold] = 1;		!Set bold attribute on
		    END;
		[4]:
		    BEGIN
		    id [vt$v_underscore] = 1;		!Set underscore on
		    END;
		[5]:
		    BEGIN
		    id [vt$v_blink] = 1;		!Set blink on
		    END;
		[7]:
		    BEGIN
		    id [vt$v_reverse] = 1;		!Set reverse video on
		    END;
		[22]:
		    IF .id [vt$w_conformance_level] NEQ vt$k_level_1 
		    THEN BEGIN
			id [vt$v_bold] = 0;		!Set bold attribute on
			END;
		[24]:
		    IF .id [vt$w_conformance_level] NEQ vt$k_level_1 
		    THEN BEGIN
			id [vt$v_underscore] = 0;	!Set underscore on
			END;
		[25]:
		    IF .id [vt$w_conformance_level] NEQ vt$k_level_1 
		    THEN BEGIN
			id [vt$v_blink] = 0;		!Set blink on
			END;
		[27]:
		    IF .id [vt$w_conformance_level] NEQ vt$k_level_1 
		    THEN BEGIN
			id [vt$v_reverse] = 0;		!Set reverse video on
			END;
		[OTHERWISE]: LEAVE rend;		!Ignore anything else
	    TES;
	END;
    [%C'n']:! DSR
	    !Return status - similar to answerback
	BEGIN
	LOCAL 
		 reverse_digits: VECTOR [4,BYTE]
		,rd_inx
		;
	CASE .parameter [0] FROM 5 TO 6
	OF SET
	    [5]:	! Device status report
		BEGIN
		    IF (.id [vt$w_c1_transmission] EQL vt$k_c1_7bit)
		    OR (.id [vt$w_c1_transmission] EQL vt$k_bit7_nrc)
		    THEN BEGIN
			vsta$$kernel_call(
					vs$$acp_answerback,
					.id [vt$l_virtual_display_id],
					4,
					UPLIT BYTE(
						esc,
						%C'[',
						%C'0',
						%C'n'));
			END
		    ELSE BEGIN
			vsta$$kernel_call(
					vs$$acp_answerback,
					.id [vt$l_virtual_display_id],
					3,
					UPLIT BYTE(
						155,
						%C'0',
						%C'n'));
			 END;
		END;	! End of device status report

	    [6]:	! CPR
			! Cursor position report
		BEGIN
		    id [vt$l_generation_buffer_ptr] = 0;
		    IF .id [vt$v_margin_origin]
		    THEN num = .id [vt$l_cursor_row] - .id [vt$l_top_margin] + 1
		    ELSE num = .id [vt$l_cursor_row];
		    !
		    !  Set up transmission
		    !
		    IF (.id [vt$w_c1_transmission] EQL vt$k_c1_7bit)
		    OR (.id [vt$w_c1_transmission] EQL vt$k_bit7_nrc)
		    THEN BEGIN
			generation_buffer[0] = esc;
			generation_buffer[1] = %C'[';
			id [vt$l_generation_buffer_index] = 1;
			id [vt$l_generation_buffer_ptr] = 0;
			END
		    ELSE BEGIN
			generation_buffer[0] = 155;
			id [vt$l_generation_buffer_index] = 0;
			id [vt$l_generation_buffer_ptr] = 0;
			END;
		    rd_inx = 0;
		    !
		    !  Loop to get digits in reverse order than needed
		    !
		    WHILE .num NEQ 0
		    DO BEGIN
			digit = (.num MOD 10) + %C'0';
			num = .num / 10;
			reverse_digits [ .rd_inx] = .digit;
			rd_inx = .rd_inx + 1;
			END;
		    DECR i FROM .rd_inx TO 1
		    DO BEGIN
			id [vt$l_generation_buffer_index] = 
					.id [vt$l_generation_buffer_index] + 1;
			generation_buffer [.id [vt$l_generation_buffer_index]]
					= .reverse_digits [ .i - 1];
			END;
		    !
		    ! Put in the ;
		    !
		    id [vt$l_generation_buffer_index] =
					.id [vt$l_generation_buffer_index] + 1;
		    generation_buffer [.id [vt$l_generation_buffer_index]] = 
					%C';';
		    !
		    !  Now decode the column
		    !
		    rd_inx = 0;
		    num = .id [vt$l_cursor_column];
		    WHILE .num NEQ 0
		    DO BEGIN
			digit = (.num MOD 10) + %C'0';
			num = .num / 10;
			reverse_digits [ .rd_inx] = .digit;
			rd_inx = .rd_inx + 1;
			END;
		    DECR i FROM .rd_inx TO 1
		    DO BEGIN
			id [vt$l_generation_buffer_index] = 
					.id [vt$l_generation_buffer_index] + 1;
			generation_buffer [.id [vt$l_generation_buffer_index]]
						= .reverse_digits [ .i - 1];
			END;

		    id [vt$l_generation_buffer_index] =
					.id [vt$l_generation_buffer_index] + 1;
		    generation_buffer [.id [vt$l_generation_buffer_index]] = 
				%C'R';
		    vsta$$kernel_call(
					vs$$acp_answerback,
					.id [vt$l_virtual_display_id],
					.id [vt$l_generation_buffer_index] + 1,
					generation_buffer[0]);
		    END;		! End of cursor report position
	    [OUTRANGE]:
		BEGIN
		id [vt$w_state] = vt$k_straight_text;	!Set state to text mode
		id [vt$v_invalid_sequence] = false;
		RETURN					! and quit
		END;
	TES;	! End of parameter case

	END;
					
    [%C'p']:! DECSCL  Select conformance level
	BEGIN
	IF  (.id [vt$w_intermediate_count] EQL 1)
	AND (.intermediates [0] EQL 33) 
	THEN BEGIN
	   IF .id [vt$w_conformance_level] NEQ vt$k_level_1
	   THEN BEGIN
		process_soft_reset(.id);
		$update_settings (-1)
		END
	   END
	ELSE
	    IF (.id [vt$w_intermediate_count] EQL 1)
	    AND (.intermediates [0] EQL 34) 
	    THEN BEGIN
		SELECTONE .parameter [0] OF
		SET
		    [61]: BEGIN
			id [vt$w_conformance_level] = vt$k_level_1;
			id [vt$w_c1_transmission] = vt$k_c1_7bit;
			vs$$set_vkb_char(
					.id [vt$l_pasteboard_id],
					vsta$m_level,
					vsta$k_vkb_level_1,
					.vs$gl_acp_pid);
			process_soft_reset(.id);
			$update_settings (-1)
			END;
		    [62]: BEGIN
			id [vt$w_conformance_level] = vt$k_level_2;
			vs$$set_vkb_char(
					.id [vt$l_pasteboard_id],
					vsta$m_level OR vsta$m_vt52,
					vsta$k_vkb_level_2,
					.vs$gl_acp_pid);
			!
			!  Move the ascii_g set into 
			!  the gr table.
			!
			CH$MOVE( 
				 6*16
				,vt$b_ascii_table + 160
				,id [vt$b_trans_table] + 160
				);
			process_soft_reset(.id);
			SELECTONE .parameter [1] OF
			SET
			    [0,2]: BEGIN
				 id [vt$w_c1_transmission] = vt$k_c1_8bit;
				 vs$$set_vkb_char(
						.id [vt$l_pasteboard_id],
						vsta$m_eightbit OR vsta$m_vt52,
						vsta$m_eightbit,
						.vs$gl_acp_pid);
				END;
			    [1]:   BEGIN
				 id [vt$w_c1_transmission] = vt$k_c1_7bit;
				 vs$$set_vkb_char(
						.id [vt$l_pasteboard_id],
						vsta$m_eightbit,
						0,
						.vs$gl_acp_pid);
				END;
			TES;
			$update_settings (-1)
			END;
		    [OTHERWISE]:;
		TES;
	     END;
	END;
			
    [%C'q']:; !Load LED's - not supported

    [%C'r']:BEGIN	! DECSTBM
			!Set scrolling region (sometimes called margins)
	id [vt$v_last_col_flag] = false;
	IF .parameter [0] EQL 0 
	THEN parameter [0] = 1;
	IF .parameter [1] EQL 0
	THEN parameter [1] = .id [vt$l_screen_absolute_bottom];
	IF .parameter [1] GTR .parameter [0]
	!Do this only if bottom below top
	THEN BEGIN
	    id [vt$l_top_margin] = .parameter [0];
	    id [vt$l_bottom_margin] = .parameter [1];
	    id [vt$l_cursor_column] = 1;    !Side-effect puts cursor at origin
	    !
	    !Check for origin within margins
	    !If so, cursor goes to top margin
	    !Otherwise, it goes to top of screen
	    !
	    IF .id [vt$v_margin_origin]
	    THEN id [vt$l_cursor_row] = .id [vt$l_top_margin]
	    ELSE id [vt$l_cursor_row] = 1;
	    END;
	!No "else"... If bottom equal or above top, ignore request
	END;
    [%C'x']:; !Similar to answerback
    [%C'y']:; !Hardware test - not supported
TES;

!
!Finished with control sequence - revert to text mode
!
id [vt$w_state] = vt$k_straight_text;


END;

ROUTINE process_soft_reset
!++
! FUNCTIONAL DESCRIPTION:
!
!
! This routine provides the soft terminal reset function required by Level 2
! of TIA (except that the addition for nrc mode (==reset to multinational)
! must be done by the calling program--it's not done here).
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table):
	
!
! RETURN VALUE
!
	VT_LINKAGE NOVALUE =
!
! 
!--
BEGIN

!
!  Turn text cursor on
!
id [vt$v_text_cursor_enabled] = true;

id [vt$w_gl_active_set] = vt$k_g0_set;
id [vt$w_gr_active_set] = vt$k_g2_set;

!
!  Set up the translation table according to level.
!
SELECTONE .id [vt$w_conformance_level] OF
  SET
    [vt$k_level_1]:
	BEGIN
	!
	!  Set up the translation table in level one.  So let the GR part of
	!   the table be a copy of the GL table
	!
	IF .id [vt$w_c1_transmission] EQL vt$k_bit7_nrc
	THEN
	    BEGIN		! 7-bit NRC
	    CH$MOVE( 32, vt$b_ascii_table, id [vt$b_trans_table]);
	    CH$MOVE( 32, vt$b_ascii_table, id [vt$b_trans_table] + 128);
	    process_g_sets( 
			 .id
			,vt$k_g0_set
			,.vt$l_kbd_gset_table [.srv$gl_kbd_set]
			,vt$k_upd_all
			);
	    id [vt$w_g1_set] = .vt$l_kbd_gset_table [.srv$gl_kbd_set];
	    id [vt$w_g2_set] = .vt$l_kbd_gset_table [.srv$gl_kbd_set];
	    id [vt$w_g3_set] = .vt$l_kbd_gset_table [.srv$gl_kbd_set];
	    END
	ELSE
	    BEGIN		! 7-bit ASCII
	    CH$MOVE( 128, vt$b_ascii_table, id [vt$b_trans_table]);
	    CH$MOVE( 128, vt$b_ascii_table, id [vt$b_trans_table] + 128);
	    id [vt$w_g0_set] = vt$k_ascii_g;
	    id [vt$w_g1_set] = vt$k_ascii_g;
	    id [vt$w_g2_set] = vt$k_ascii_g;
	    id [vt$w_g3_set] = vt$k_ascii_g;
	    END;
	END;

    [vt$k_level_2]:
	BEGIN
	!
	!  Reset the character tables
	!
	id [vt$w_g0_set] = vt$k_ascii_g;
	id [vt$w_g1_set] = vt$k_ascii_g;
	id [vt$w_g2_set] = vt$k_supplemental_g;
	id [vt$w_g3_set] = vt$k_supplemental_g;
	CH$MOVE( 256, vt$b_ascii_table, id [vt$b_trans_table]);
	END;
    TES;
!
!  Reset character attributes
!
id [vt$b_attributes] = 0;		!Set all attributes off

id [vt$l_top_margin] = 1;
id [vt$l_bottom_margin] = .id [vt$l_screen_absolute_bottom];
id [vt$v_vt102_insert_mode] = false;
id [vt$v_margin_origin] = false;
id [vt$v_auto_wrap] = false;

id [vt$v_keyboard_blocked] = false;
vs$$set_vkb_char(
	    .id [vt$l_pasteboard_id],
	    vsta$m_keypad OR vsta$m_cursor_key,
	    0,
	    .vs$gl_acp_pid);

!
!  Reset the save cursor areas
!
id [vt$l_saved_cursor_column] = 1;
id [vt$l_saved_cursor_row] = 1;
id [vt$b_saved_attributes] = 0;
CH$MOVE(8, id [vt$w_g0_set], id [vt$w_saved_character_sets]);
id [vt$v_saved_last_col_flag] = false;
id [vt$v_saved_origin_mode] = false;

RETURN
END;


ROUTINE erase_all_chars
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine erases the entire screen, clears up entire database
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table
		!Address of table containing state, modes,... of this VT100
	): VT_LINKAGE =

!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
! If error status returned by any called routines, it's passed back.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	The image of the VT100 on the screen is erased to background color
!
!--

BEGIN
LOCAL
	status;

!
! Clear database, clear screen
!
IF NOT VT$$DT_CLEAR_VT100 (.id)
THEN $RETURN_ERROR(vsta$_cnterasevtchrs);

IF NOT VT$$DT_CLEAR_SCREEN (.id)
THEN $RETURN_ERROR(vsta$_cnterasevtchrs);

RETURN ss$_normal;

END;

ROUTINE erase_characters
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine erases characters on the screen from the starting position to
! the end position, inclusive.
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table
		!Address of table containing state, modes,... of this VT100
	,start_row
	,start_column
	,end_row
	,end_column): VT_LINKAGE =

!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
! If error status returned by ***** it's passed back.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! The device data table is modified.
!
!--

BEGIN
LOCAL
	status,
	row;

INCR row FROM .start_row TO .end_row DO
    IF NOT VT$$DT_erase_chars_vt100 (
				 .id
				,.row
				,(IF .row EQL .start_row THEN .start_column
							 ELSE 1 )
				,(IF .row EQL .end_row THEN .end_column
					ELSE .id [vt$l_extreme_right])
				)
    THEN $LOG_ERROR(vsta$_cntwrivttx);

IF NOT VT$$DT_erase_chars_screen (
				 .id
				,.start_row
				,.start_column
				,.end_row
				,.end_column
				)
THEN $LOG_ERROR(vsta$_cntwrivttx);

RETURN ss$_normal;
END;

ROUTINE process_control_parameters
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine handles all characters that arrive between the beginning of
! a control or dec-private sequence (i.e. following the control sequence
! introducer) and the final character. The only legal characters in that
! space are the characters between octal 60 and octal 77. Anything else is
! considered illegal, and causes the VT100 to abort the sequence and revert
! to text mode.
!
! Characters in the range octal 60 to octal 71 (digits 0 - 9) are treated
! as part of a parameter. The current value of the parameter is multiplied by
! ten and the new digit is added to it. If a semi-colon is encountered (octal
! 73), a new parameter is initiated.
!
! Characters in the range octal 72 to 77 (except for 73) are treated as
! legal, but invalid for the VT100. If one of these is encountered, anything
! following it is ignored until a final character is encountered (the
! sequence is ignored).
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table):
		!Address of table containing state, modes,... of this VT100
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =	!No error possible
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! The device data table is modified.
!
!--

BEGIN

! Redefine parameters as a vector for easy reference
BIND
	parameter = id [vt$w_parameters]: VECTOR [vt$k_maximum_parameter,WORD];

!
! Check for past indication that sequence is invalid
! If known to be invalid already, don't bother with parameters
!
IF .id [vt$v_invalid_sequence]
	THEN RETURN;

SELECTONE .id [vt$b_char] OF
SET

!
! Calculate numeric value of parameter unless it's huge or we ran out of
! vector space
!
    [%C'0' TO %C'9']:
    !Only stack up to max allowable parameters
	IF .id [vt$b_current_parameter] LSS vt$k_maximum_parameter
	THEN
	    !Check for unreasonable humungousness
	    !If still OK, calculate new value
	    IF .parameter [.id [vt$b_current_parameter]] LSS 1000
	    THEN parameter [.id [vt$b_current_parameter]] =
				.parameter [.id [vt$b_current_parameter]] * 10
				+ (.id [vt$b_char] - %C'0');

    [%C';']:
    !start doing next parameter, up to maximum allowable
	id [vt$b_current_parameter] = MIN (
		vt$k_maximum_parameter - 1 , .id [vt$b_current_parameter] + 1);

    !Any other character in this range is invalid.
    [%C':',%C'<' TO %C'?']: id [vt$v_invalid_sequence] = true;

    !If other than what we've tested for, it's illegal
    [OTHERWISE]: id [vt$w_state] = vt$k_straight_text;

TES;
END;

ROUTINE process_dec_private_sequence
!++
! FUNCTIONAL DESCRIPTION:
!
! This routine handles characters that come in after the start of a dec
! private control sequence has been identified, and keeps track of dec
! private control sequences that are "legal ANSI" and those that are "valid"
! for VT100 operation.
!
!
! "Legal" means that the sequence conforms to the ANSI definition of a
! control sequence, which is "<CSI> P;P;...;P F", where P;P;...;P is a series
! of parameters each of which consists of a string of decimal digits (range
! octal 60 to octal 71), separated by semicolons (octal 73), and F is a
! "final character" (range octal 100 to octal 176). As long as the incoming
! dec private control sequence is legal, no action is taken until a final
! character is detected. If a character comes in which deviates from the
! legal definition, the sequence is aborted, and the state reverts to simple
! text processing.
!
! <CSI> means an escape character followed by a left bracket and a question 
! mark: <ESC> [ ?
!
! If a "final character" is detected, a complete, legal dec private control
! sequence  has been received, and the routine checks for "validity". "Valid"
! means the dec private control sequence is recognized as a command which the
! VT100  understands.  If  the sequence is valid, the action is determined by
! examining the parameters and final character. If not valid, the sequence is
!ignored.
!
! FORMAL PARAMETERS:
!
	(id: REF device_data_table):
		!Address of table containing state, modes,... of this VT100
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
	VT_LINKAGE NOVALUE =	!No error possible
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
! The data table mey be modified.
! The contents of the virtual display screen may change.
!
!--

BEGIN
LOCAL
	status;
LABEL	setmode,
	resetmode;

! Redefine parameters as a vector for easy reference
BIND
	line_state = id [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE],
	parameter = id [vt$w_parameters]: VECTOR [vt$k_maximum_parameter,WORD];

SELECTONE .id [vt$b_char] OF	! then select action based on final character.
SET

    [%C'h']:	!Set mode    SM
	!Go through all parameters
	INCR counter FROM 0 TO .id [vt$b_current_parameter] DO
	    setmode:
		BEGIN
		!Select action based on parameter
		CASE .parameter [.counter] FROM 1 TO 42 OF
		SET
		    [1]:	! DECCKM
			vs$$set_vkb_char(
					    .id [vt$l_pasteboard_id],
					    vsta$m_cursor_key,
					    vsta$m_cursor_key,
					    .vs$gl_acp_pid);

		    [3]:  ! DECCOLM Set wide (e.g. 132 column) mode 
			BEGIN
!
! This is currently not implemented. So for now will behave exactly the
! same as a reset to 80 columns.
!
			id [vt$v_last_col_flag] = false;
			!
			!Reset wide mode bit 
			!
			id [vt$v_wide] = false;
			!
			!Set bit indicating wide mode
			!
!***			id [vt$v_wide] = true;
			!
			!Set normal width 
			!
			id [vt$l_extreme_right] = .id [vt$l_normal_right];
			!
			!Setwide width 
			!
!***			id [vt$l_extreme_right] = .id [vt$l_wide_right];
			!
			!set all lines to single width
			!
			INCR count FROM 0 TO vt$k_maximum_rows - 1 DO 
			    line_state [.count] = vt$k_single;
			!
		 	!Implicitly reset margins 
			!
			id [vt$l_top_margin] = 1;
			id [vt$l_bottom_margin] = 
					.id [vt$l_screen_absolute_bottom];
			!Implicitly reset cursor to upper left
			id [vt$l_cursor_row] = 1;
			id [vt$l_cursor_column] = 1; 
			VT$$DT_CLEAR_VT100 (.id);
			VT$$DT_CLEAR_SCREEN (.id);
			END;

		    [4]:	! DECSCLM  Set smooth scroll mode
			id [vt$v_scroll] = true;

		    [5]:	! DECSCNM
			begin
			vsta$$set_vt100_light (id[$base]);
			$update_settings (s100$k_light_background)
			end;

		    [6]:	! DECOM
				!Make origin column 1, top of scrolling region
			BEGIN
			id [vt$v_last_col_flag] = false;
			!
			!Set origin within scrolling region
			!
			id [vt$v_margin_origin] = true;
			id [vt$l_cursor_row] = .id [vt$l_top_margin];
			id [vt$l_cursor_column] = 1;
			END;

		    [7]:	! DECAWM
			begin
			vsta$$set_vt100_wrap (id[$base]);
			$update_settings (s100$k_wrap)
			end;

		    [25]:	! DECTCEM 
			id [vt$v_text_cursor_enabled] = true;

		    [42]:	! DECNRC
			begin
			vsta$$set_vt100_nrc(id[$base]);
			$UPDATE_SETTINGS(-1);
			end;

		    [INRANGE]: LEAVE setmode;
		    [OUTRANGE]: LEAVE setmode;

		TES;
		END;

    [%C'l']:	! RM  Reset mode
	!Go through all parameters
	INCR counter FROM 0 TO .id [vt$b_current_parameter] DO
	    resetmode:
		BEGIN
		!Select action based on parameter
		CASE .parameter [.counter] FROM 1 TO 42 OF
		SET
		    [1]:	! DECCKM
			vs$$set_vkb_char(
					    .id [vt$l_pasteboard_id],
					    vsta$m_cursor_key,
					    0,
					    .vs$gl_acp_pid);

		    [2]:	! EXIT VT52
			begin
			vsta$$set_vt100_vt52 (id[$base]);
			$update_settings (s100$k_vt52)
			end;

		    [3]:	! DECCOLM  Set screen width to normal
			BEGIN
			id [vt$v_last_col_flag] = false;
			!
			!Reset wide mode bit
			!
			id [vt$v_wide] = false;
			!
			!Set screen width
			!
			id [vt$l_extreme_right] = .id [vt$l_normal_right];
			!
			!set all lines to single width
			!
			INCR count FROM 0 TO vt$k_maximum_rows - 1 DO
			    line_state [.count] = vt$k_single;
			!
			!Implicitly reset margins
			!
			id [vt$l_top_margin] = 1;
			id [vt$l_bottom_margin] = 
					.id [vt$l_screen_absolute_bottom];
			!
			!Implicitly reset cursor to upper left
			!
			id [vt$l_cursor_row] = 1;
			id [vt$l_cursor_column] = 1;
			VT$$DT_CLEAR_VT100 (.id);
			VT$$DT_CLEAR_SCREEN (.id);
			END;

		    [4]:	! DECSCLM  Set jump scroll
			id [vt$v_scroll] = false;

		    [5]:	! DECSCNM
			begin
			vsta$$set_vt100_dark (id[$base]);
			$update_settings (s100$k_dark_background)
			end;

		    [6]:	! DECOM Make origin upper left of screen
			BEGIN
			id [vt$v_last_col_flag] = false;
			!
			!Origin will be top left of screen
			!
			id [vt$v_margin_origin] = false;
			id [vt$l_cursor_row] = 1;
			id [vt$l_cursor_column] = 1;
			END;

		    [7]:	! DECAWM
			begin
			vsta$$set_vt100_nowrap (id[$base]);
			$update_settings (s100$k_nowrap)
			end;

		    [25]: 	! DECTCEM
			id [vt$v_text_cursor_enabled] = false;

		    [42]:	! DECNRC
			begin
			vsta$$set_vt100_level(id[$base], prof$k_vt_level2);
			$update_settings (-1)
			end;

		    [INRANGE]: LEAVE resetmode;
		    [OUTRANGE]: LEAVE resetmode;

		TES;
	    END;
    TES;	
id [vt$w_state] = vt$k_straight_text;	!Sequence finished - revert to text mode
END;

global routine vsta$$set_vt100_dark
!++
! Functional description:
!
!	This routine is called either because the user has told the human
!	interface to set this vt100's background to black, or because
!	the program has sent the escape sequence that means to make a vt100
!	black.
!
! Formal parameters:
 (
	id : ref device_data_table
 ) =
!
!--

BEGIN
local	saved_pid;
!
! Nothing to do if screen is already black.
!
IF not .id [vt$v_screen_background]
THEN return ss$_normal;
!
! Set dark background mode.
!
id [vt$v_screen_background] = false;
!
!Disable VD output while doing slow stuff
!
IF NOT vs$$vds_disable_vd (.id [vt$l_virtual_display_id])
THEN $RETURN_ERROR(vsta$_cntdisvtvd);

saved_pid = .vs$gl_pid;
vs$gl_pid = .vs$gl_acp_pid;
IF NOT vs$$vds_set_vd_char (
	    .id [vt$l_virtual_display_id],
	    vt$k_uic,
	    vt$k_background,
	    vt$k_foreground,
	    1,
	    -1,
	    -1
	    )	!Don't change chars, protection
THEN begin
    vs$gl_pid = .saved_pid;
    $RETURN_ERROR(vsta$_cntsetvtvdchrs);
    end;
!
!Enable VD for doing fast invert screen
!
IF NOT vs$$vds_enable_vd (.id [vt$l_virtual_display_id])
THEN $RETURN_ERROR(vsta$_cntenavtvd);

IF NOT vs$$vds_invert (
	    .id [vt$l_virtual_display_id],
	    0,
	    0,
	    .id [vt$l_body_width],
	    .id [vt$l_body_height])
THEN $RETURN_ERROR(vsta$_cntinvvtscreen);

RETURN ss$_normal

end;

global routine vsta$$set_vt100_light
!++
! Functional description:
!
!	This routine is called either because the user has told the human
!	interface to set this vt100's background to light, or because
!	the program has sent the escape sequence that means to make a vt100
!	light.
!
! Formal parameters:
 (
	id : ref device_data_table
 ) =
!
!--

begin
local	saved_pid;
!
! Nothing to do if screen is already light
!
IF .id [vt$v_screen_background]
then return ss$_normal;
!
! Set light background mode
!
id [vt$v_screen_background] = true;
!
! Disable VD output while doing slow stuff
!
IF NOT vs$$vds_disable_vd (.id [vt$l_virtual_display_id])
THEN $RETURN_ERROR(vsta$_cntdisvtvd);

saved_pid = .vs$gl_pid;
vs$gl_pid = .vs$gl_acp_pid;
IF NOT vs$$vds_set_vd_char
			(.id [vt$l_virtual_display_id],
			vt$k_uic,
			vt$k_foreground,
			vt$k_background,
			1,-1,-1) !Don't change chars, protection
THEN begin
    vs$gl_pid = .saved_pid;
    $RETURN_ERROR(vsta$_cntsetvtvdchrs);
    end;
!
! Enable VD for doing fast invert screen
!
IF NOT vs$$vds_enable_vd (.id [vt$l_virtual_display_id])
THEN $RETURN_ERROR(vsta$_cntenavtvd);

IF NOT vs$$vds_invert (
		.id [vt$l_virtual_display_id],
		0,
		0,
		.id [vt$l_body_width],
		.id [vt$l_body_height])
THEN $RETURN_ERROR(vsta$_cntinvvtscreen);

RETURN ss$_normal

END;

global routine vsta$$set_vt100_nrc
!++
! Functional description:
!
!	Set vt100 nrc mode.
!
! Formal parameters:
 (
	id : ref device_data_table
 ) =
!

BEGIN

id [vt$v_ansi_vt52] = true;
id [vt$w_c1_transmission] = vt$k_bit7_nrc;
id [vt$w_conformance_level] = vt$k_level_1;

process_soft_reset(.id);

IF NOT vs$$set_vkb_char(
		.id [vt$l_pasteboard_id],
		vsta$m_level OR vsta$m_eightbit OR vsta$m_vt52,
		vsta$k_vkb_level_1,
		.vs$gl_acp_pid)
THEN $LOG_ERROR(vsta$_cntsetvtvkb);

IF NOT vs$$vkb_set_nrc(
		.id [vt$l_pasteboard_id],
		.vt$l_nrc_vkb_table[.vt$l_kbd_gset_table[.srv$gl_kbd_set]])
THEN $LOG_ERROR(vsta$_cntsetvtvkb);

RETURN ss$_normal;

END;

global routine vsta$$set_vt100_ansi
!++
! Functional description:
!
!	Put vt100 into ansi mode.
!
! Formal parameters:
 (
	id : ref device_data_table
 ) =
!
!--

BEGIN
id [vt$v_ansi_vt52] = true;

SELECTONE .id [vt$w_conformance_level] OF
SET
    [vt$k_level_1]:
	BEGIN
	vs$$set_vkb_char(
			.id [vt$l_pasteboard_id],
			vsta$m_level+vsta$m_vt52+vsta$m_eightbit,
			vsta$k_vkb_level_1,
			.vs$gl_acp_pid);
	process_soft_reset(.id);
	END;

    [vt$k_level_2]:
	BEGIN
	vs$$set_vkb_char(
			.id [vt$l_pasteboard_id],
			vsta$m_level+vsta$m_vt52+vsta$m_eightbit,
			vsta$k_vkb_level_2+vsta$m_eightbit,
			.vs$gl_acp_pid);
	process_soft_reset(.id);
	END;

    TES;

RETURN ss$_normal;

END;

global routine vsta$$set_vt100_vt52
!++
! Functional description:
!
!	Put vt100 into vt52 emulation mode
!
! Formal parameters:
 (
	id : ref device_data_table
 ) =
!
!--

BEGIN
flush_backlog(.id);
id [vt$v_ansi_vt52] = false;

id [vt$w_c1_transmission] = vt$k_c1_7bit;

vs$$set_vkb_char(
      .id [vt$l_pasteboard_id],
      vsta$m_level+vsta$m_vt52+vsta$m_eightbit,
      vsta$k_vkb_level_1+vsta$m_vt52,
      .vs$gl_acp_pid);

!
!  Setup the IN_USE_TABLE for the normal character set
!
CH$MOVE( 128, vt$b_ascii_table, id [vt$b_trans_table]);
CH$MOVE( 128, vt$b_ascii_table, id [vt$b_trans_table] + 128);
id [vt$b_vt52_char_set] = vt$k_ascii_g;

RETURN ss$_normal

END;

global routine vsta$$set_vt100_answer
!++
! Functional description:
!
!	Set a vt100's answerback message.
!
! Formal parameter:
 (
	id : ref device_data_table,	! which vt100
	answr_back_siz,			! number of bytes in message
	answr_back_a : ref vector [,byte]! address of bytes
 ) =
!
!--

BEGIN

CH$COPY(
	 .answr_back_siz		! copy new AB mess. 
	,answr_back_a[0]		! from packed buffer
	,%C' '				! fill with blanks
	,vt$s_answerback_message	! into the AB field
	,id [vt$b_answerback_message]	! in the vt100 DB
    );

id [vt$l_answerback_message_length] = .answr_back_siz - 1;

RETURN ss$_normal;
END;

global routine vsta$$set_vt100_wrap
!++
! Functional description:
!
!	Put a vt100 into wrap mode.
!
! Formal parameters:
 (
	id : ref device_data_table
 ) =
!
!--

begin
id [vt$v_auto_wrap] = true;	!Set mode to wrap to next line at edge
RETURN ss$_normal
end;


global routine vsta$$set_vt100_nowrap
!++
! Functional description:
!
!	Take a vt100 out of wrap mode.
!
! Formal parameters:
 (
	id : ref device_data_table
 ) =
!
!--

begin
id [vt$v_auto_wrap] = false;
RETURN ss$_normal
end;


global routine vsta$$set_vt100_newline
!++
! Functional description:
!
!	Make carriage return cause new line
!
! Formal parameters:
 (
	id : ref device_data_table
 ) =
!
!--

begin
id [vt$v_linefeed_newline] = true;
vs$$set_vkb_char(
		.id [vt$l_pasteboard_id],
		vsta$m_new_line,
		vsta$m_new_line,
		.vs$gl_acp_pid);

RETURN ss$_normal
end;


global routine vsta$$set_vt100_oldline
!++
! Functional description:
!
!	Prevent carriage return from producing linefeed.
!
! Formal parameters:
 (
	id : ref device_data_table
 ) =
!
!--

begin
id [vt$v_linefeed_newline] = false;
vs$$set_vkb_char(
		.id [vt$l_pasteboard_id],
		vsta$m_new_line,
		0,
		.vs$gl_acp_pid);

RETURN ss$_normal
end;


global routine vsta$$clear_vt100_tab
!++
! Functional description:
!
!	Clear tab stop an column n
!
! Formal parameters:
 (
	id : ref device_data_table,
	n			! column ( 1 through 132 )
 ) =
!
!--

begin
bind
	tabs = id [vt$v_tabs]: BITVECTOR [vt$k_maximum_columns];

tabs [ .n] = 0;	!Clear tab in specified column

RETURN ss$_normal
end;


global routine vsta$$set_vt100_tab
!++
! Functional description:
!
!	Set tab stop an column n
!
! Formal parameters:
 (
	id : ref device_data_table,
	n			! column ( 1 through 132 )
 ) =
!
!--

begin
bind
	tabs = id [vt$v_tabs]: BITVECTOR [vt$k_maximum_columns];

tabs [ .n] = 1;	!Set tab in specified column
RETURN ss$_normal

end;


GLOBAL ROUTINE vsta$$set_vt100_level
!++
! Functional description:
!
!	Sets vt100 TIA conformance level.
!
! Formal parameters:
 (
	id : REF device_data_table,
	level				! prof$k_vt_level1 or prof$k_vt_level2
 ) =
!
!--

BEGIN
LOCAL	s,
	trans_table;

SELECTONE .level OF
SET
    [prof$k_vt_level2]:
	BEGIN
	id [vt$w_conformance_level] = vt$k_level_2;
	id [vt$w_c1_transmission] = vt$k_c1_8bit;
	vsta$$set_vt100_ansi(.id);
	IF NOT vs$$vkb_set_nrc(
		.id [vt$l_pasteboard_id],
		vsta$k_nrc_multinational)
	  THEN 	$LOG_ERROR(vsta$_cntsetvtvkb);
	END;

    [prof$k_vt_level1]:
	BEGIN
	id [vt$w_conformance_level] = vt$k_level_1;
	id [vt$w_c1_transmission] = vt$k_c1_7bit;
	IF NOT vs$$set_vkb_char(
				.id [vt$l_pasteboard_id],
				vsta$m_level+vsta$m_eightbit,
				vsta$k_vkb_level_1,
				.vs$gl_acp_pid)
	THEN $LOG_ERROR(vsta$_cntsetvtvkb);
	!
	!  Set up the translation table in level one.  So let the GR part of the table
	!  be a copy of the GL table
	!
	IF NOT vs$$vkb_set_nrc(
		.id [vt$l_pasteboard_id],
		vsta$k_nrc_ascii)
	  THEN 	$LOG_ERROR(vsta$_cntsetvtvkb);
	process_soft_reset(.id);
	END;

    [prof$k_7bit_nrc]:
	vsta$$set_vt100_nrc(.id);

  TES;

RETURN ss$_normal

END;

GLOBAL ROUTINE vsta$$set_vt100_kbd_change
!++
! Functional description:
!
!	Updates vt100 nrc if in nrc mode when keyboard changes in profile.
!
! Formal parameters:
 (
	id : REF device_data_table
 ) =
!
!--

BEGIN

IF .id [vt$w_c1_transmission] EQL vt$k_bit7_nrc
  THEN vsta$$set_vt100_nrc(.id);

RETURN ss$_normal

END;

GLOBAL ROUTINE vsta$$get_vt100_backcolor
!++
! FUNCTIONAL DESCRIPTION:
!	Return background color of VT100. 0=black, 1=white.
! FORMAL PARAMETERS:
	(vd_id
	,backcolor
	) =
!--
BEGIN
LOCAL
    id: REF device_data_table,
    status;

.backcolor = 0;			!assume black background
IF NOT (status = find_vt100 (.vd_id, id))
  THEN RETURN SS$_NORMAL;	!Can't find VT100

IF (.id [vt$v_screen_background])
  THEN .backcolor = 1;		!Which background

RETURN SS$_NORMAL
END;

%sbttl 'VT$$DT_CLEAR_VT100 -- Clear vt100 data base'
routine VT$$DT_CLEAR_VT100(
				 VTDB: ref DEVICE_DATA_TABLE
			   ) =
!
!  This routine clears the vt100 data backing store
!
begin

bind
	 line_state = vtdb [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	,row_table = vtdb [vt$b_row_table]: VECTOR [vt$k_maximum_rows,BYTE]
	;

CH$FILL (
	 VT$M_BLANK
	,.VTDB [VT$L_EXTREME_RIGHT] * .VTDB [VT$L_SCREEN_ABSOLUTE_BOTTOM]
	,.VTDB [VT$A_REND_TABLE]
	);

CH$FILL (
	 VT$K_SINGLE
	,VT$K_MAXIMUM_ROWS
	,line_state[0]
	);

INCR i from 0 to .vtdb [vt$l_screen_absolute_bottom] - 1
DO row_table [ .i] = .i;

RETURN SS$_NORMAL;

end;


%sbttl 'VT$$DT_CLEAR_SCREEN -- Clear vt100 virtual display'
routine VT$$DT_CLEAR_SCREEN(
				 VTDB: ref DEVICE_DATA_TABLE
			   ) =
!
!  This routine clears the vt100 data backing store
!
begin

local
	 CLIP_RCSQ	: vector [2,long]
	,RCS		: ref vector [,long]
	,SRC
	,NEXT_RCS
	,MSK		: vector [2,word]
	;

!
!  If we have light background then do source is 1 otherwise the source is 0
!
if .VTDB [VT$V_SCREEN_BACKGROUND] 
then SRC = 1
else SRC = 0;

!
!  Determine the mask rectangle
!
MSK [0] = .VTDB [VT$L_BODY_WIDTH];
MSK [1] = .VTDB [VT$L_BODY_HEIGHT];

VSTA$$VDS_COPY_VD_RC_LISTS ( .VTDB [VT$L_VIRTUAL_DISPLAY_ID], CLIP_RCSQ);

!
!  Now for each clipping rectangle ...
!
RCS = .CLIP_RCSQ [0];

until .RCS eql CLIP_RCSQ [0]
do begin			! Clear each screen instance

    NEXT_RCS = .RCS [0];

    !
    !  Do copy area
    !
    $DRIVECOPY(
		 CHAN	= .VS$GW_VBCHAN
		,SRCTYP = VSTA$K_SRC_CONST
		,SOURCE = .SRC
		,MSKTYP	= VSTA$K_MSK_RECTANGLE
		,MASK	= MSK [0]
		,DST	= .VSTA$A_FRAME_BUFFER [0]
		,DSTOFX = .RCS [3]
		,DSTOFY = .RCS [4]
		,RECNUM	= .RCS [5]
		,RECADR = RCS [6]
		,EFN = 5
		);

    RCS = .NEXT_RCS;

    end;			! End of clearing all vd instances on screen

!
!  Do a noop to deallocate rectangles
!
$DRIVENOOP(
	 CHAN	= .VS$GW_VBCHAN
	,ASTADR	= VT$$DT_COMPLETION_ROUTINE
	,ASTPRM	= .CLIP_RCSQ [0]
	  );

return SS$_NORMAL;

end;


%sbttl 'VT$$DT_CLEAR_SCREEN_RC -- Color VD rectangle'
routine VT$$DT_CLEAR_SCREEN_RC(
				 VTDB: ref DEVICE_DATA_TABLE
				,TOP_ROW
				,LEFT_COLUMN
				,BOTTOM_ROW
				,RIGHT_COLUMN
			   ) =
!
!  This routine clears the vt100 data backing store
!  Doesn't do anything about double width lines, but since this is only
!	called for a complete line it appears to be okay.
!
begin

local
	 CLIP_RCSQ	: vector [2,long]
	,RCS		: ref vector [,long]
	,SRC
	,NEXT_RCS
	,MSK		: vector [2,word]
	,X_OFF
	,Y_OFF
	,X_EXT
	,Y_EXT
	;


!
!  If we have light background then do source is 1 otherwise the source is 0
!
if .VTDB [VT$V_SCREEN_BACKGROUND] 
then SRC = 1
else SRC = 0;

!
!  Get top-left of source rectangle
!
X_OFF = $get_x ( .LEFT_COLUMN);
Y_OFF = $get_y (.top_row);

!
!  Get x,y of bottom right of source rectangle
!
X_EXT = $get_x (.RIGHT_COLUMN + 1);
Y_EXT = $get_y (.BOTTOM_ROW + 1);

!
!  Turn the x,y of bottom-right into extents of rectangle
!
X_EXT = .X_EXT - .X_OFF;	! + 1;
Y_EXT = .Y_EXT - .Y_OFF;	! + 1;

!
!  Determine the mask rectangle
!
MSK [0] = .X_EXT;
MSK [1] = .Y_EXT;

VSTA$$VDS_COPY_VD_RC_LISTS ( .VTDB [VT$L_VIRTUAL_DISPLAY_ID], CLIP_RCSQ);

!
!  Now for each clipping rectangle print the text etc...
!
RCS = .CLIP_RCSQ [0];

until .RCS eql CLIP_RCSQ [0]
do begin			! Clear each screen instance

    NEXT_RCS = .RCS [0];

    !
    !  Do copy area
    !
    $DRIVECOPY(
		 CHAN	= .VS$GW_VBCHAN
		,SRCTYP = VSTA$K_SRC_CONST
		,SOURCE = .SRC
		,MSKTYP	= VSTA$K_MSK_RECTANGLE
		,MASK	= MSK [0]
		,DST	= .VSTA$A_FRAME_BUFFER [0]
		,DSTOFX = .RCS [3] + .X_OFF
		,DSTOFY = .RCS [4] + .Y_OFF
		,RECNUM	= .RCS [5]
		,RECADR = RCS [6]
		);

    RCS = .NEXT_RCS;

   end;				! End of clearing all vd instances on screen

!
!  Do a noop to deallocate rectangles
!
$DRIVENOOP(
	 CHAN	= .VS$GW_VBCHAN
	,ASTADR	= VT$$DT_COMPLETION_ROUTINE
	,ASTPRM	= .CLIP_RCSQ [0]
	  );

return SS$_NORMAL;

end;




%sbttl 'VT$$DT_REDISPLAY_SCREEN -- Replay vt100 data'
routine VT$$DT_REDISPLAY_SCREEN (
				 VTDB: ref device_data_table
				) =
!
!  This routine scans the vt100 data base and replays its contents
!
begin

local
	 ROW
	,COLUMN
	,FONT
	,TEXT_DESC	: vector [2,long]
	,CHARS_TO_SPAN
	,CHARS_TO_PRINT
	,CHAR_POS
	,DEST_OFFSET	: vector [2,word]
	,CLIP_RCSQ	: ref vector [,long]
	,DST_RCSQ	: vector [2,long]
	,ROW_RC		: vector [4,word]
	,NEXT_RCS
	,RCS		: ref vector [,long]
	,VD_OFF_X
	,VD_OFF_Y
	,MAP_VALUE
	,MAP_TYPE
	,left_x
	,base
	,dsc		: vector [6,long]
	,w_color
	,under_line
	;

bind
	 TEXT_ADDR	= TEXT_DESC [1]
	,TEXT_BCNT	= TEXT_DESC [0]
	,ROW_TABLE	= VTDB [VT$B_ROW_TABLE]: vector [,byte]
	,line_state = vtdb [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	,PATH = DSC [0]: VECTOR [,WORD]
	;

!
!  Clear vt100 vd
!
VT$$DT_CLEAR_SCREEN( .VTDB);

!
!  Get the clipping rectangles
!
VSTA$$VDS_GET_VD_RC_LISTS( .VTDB [VT$L_VIRTUAL_DISPLAY_ID], CLIP_RCSQ);

!
!  If there are no clipping rectangles then just return success
!
if .CLIP_RCSQ [0] eql CLIP_RCSQ [0]
then return SS$_NORMAL;

!
!  Loop through all rows of the terminal
!
incr ROW from 1 to .VTDB [VT$L_SCREEN_ABSOLUTE_BOTTOM]
do begin				! Print all lines

    bind
	 TEXT_ROW = .VTDB [VT$A_TEXT_TABLE] +
			   (.ROW_TABLE [ .ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
			   : vector [,byte]
	,REND_ROW = .VTDB [VT$A_REND_TABLE] +
			   (.ROW_TABLE [ .ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
			   : vector [,byte]
	;

    !
    !  Calculate the ROW rectangle
    !
    !  Get the x,y position of the text to be printed
    !

    ROW_RC [0] = $get_x (1);
    ROW_RC [1] = $get_y (.ROW);
    ROW_RC [2] = .VTDB [VT$L_EXTREME_RIGHT] * .VT$L_FONT_WIDTH;
    ROW_RC [3] = .VT$L_FONT_HEIGHT;

    !
    !  intersect the rectangle that represents the current row with
    !  the clipping rectangle lists and use the resulting lists to
    !  perform the print text etc...
    !
    VSTA$$RCS_INTER_LIST_WITH_LISTS( 1, ROW_RC [0], CLIP_RCSQ [0], 
						DST_RCSQ [0]);

    !
    !  Check to see if the DST_RCSQ is empty,  if so then skip this
    !  row.
    !
    if .DST_RCSQ [0] neq DST_RCSQ [0]
    then begin			! Intersection found

	!
	!  Initialize column pointer and character count
	!
	COLUMN = 1;
	CHARS_TO_SPAN = .VTDB [VT$L_EXTREME_RIGHT];
	while .CHARS_TO_SPAN GTR 0
	do begin			! Print all chars in line
	    CHAR_POS = CH$FIND_NOT_CH( 
				 .CHARS_TO_SPAN
				,REND_ROW [ .COLUMN - 1]
				,.REND_ROW [ .COLUMN - 1]
			      );

	    if CH$FAIL( .CHAR_POS)
	    then CHARS_TO_PRINT = .CHARS_TO_SPAN
	    else CHARS_TO_PRINT = .CHAR_POS - REND_ROW [ .COLUMN - 1];
		
	    !
	    !  Find font to use.  Look into the font table according to
	    !  line and character rendition.
	    !
	    VT$$DT_GET_FONT ( .VTDB, .ROW, .COLUMN, FONT);

	    !
	    !  Get the x,y position of the text to be printed
	    !
	    VD_OFF_X = $get_x (.COLUMN);
	    VD_OFF_Y = $get_y (.ROW);

	    IF (.line_state [.row-1] NEQ vt$k_single) AND (.column GTR 1)
	    THEN vd_off_x = 2 * .VD_OFF_X;

	    !
	    !
	    !  Set up print text
	    !
	    TEXT_BCNT = .CHARS_TO_PRINT;
	    TEXT_ADDR = TEXT_ROW [ .COLUMN - 1];
		
	    !
	    !  determine mapping function based on screen color
	    !  and whether rendition is reverse-video
	    !
	    if (.REND_ROW[ .COLUMN - 1] AND VT$M_REVERSE) neq 0
	    then begin
		if .VTDB [VT$V_SCREEN_BACKGROUND] 
		then begin
		    MAP_TYPE = VSTA$K_MAP_IDENTITY;
		    end
		else begin
		    MAP_TYPE = VSTA$K_MAP_SOURCEDEST;
		    MAP_VALUE = VSTA$K_MAP_NOTSRC;
		    end
		end
	    else begin
		if .VTDB [VT$V_SCREEN_BACKGROUND] 
		then begin
		    MAP_TYPE = VSTA$K_MAP_SOURCEDEST;
		    MAP_VALUE = VSTA$K_MAP_NOTSRC;
		    end
		else begin
		    MAP_TYPE = VSTA$K_MAP_IDENTITY;
		    end;
		end;

	    IF ( .line_state [.row-1] NEQ vt$k_dhtop )
	       and ((.REND_ROW [.COLUMN - 1] AND VT$M_underline) neq 0)
	    THEN under_line = 1 ELSE under_line = 0;
	    !
	    !  If the rendition in not blank then print text etc...
	    !
	    if (.REND_ROW[ .COLUMN - 1] and VT$M_BLANK) eql 0
	    then begin
		!
		!  Now for each clipping rectangle print the text etc...
		!
		RCS = .DST_RCSQ [0];
	
		until .RCS eql DST_RCSQ [0]
		do begin		! Print in each rectangle

		    NEXT_RCS = .RCS [0];

		    DEST_OFFSET [0] = .VD_OFF_X + .RCS [ 3];
		    DEST_OFFSET [1] = .VD_OFF_Y + .RCS [ 4];

		    !
		    !  Do print text
		    !
		    $DRIVEPRINT(
 				 CHAN	= .VS$GW_VBCHAN
				,SRCTYP = VSTA$K_SRC_FONT_BITMAP
				,SOURCE = .FONT
				,DST	= .VSTA$A_FRAME_BUFFER [0]
				,DSTOFF	= DEST_OFFSET [0]
				,MAPTYP	= .MAP_TYPE
				,MAPVAL	= .MAP_VALUE
				,TXTNUM	= .TEXT_BCNT
				,TXTADR = .TEXT_ADDR
				,RECNUM	= .RCS [5]
				,RECADR = RCS [6]
				) ;

		    !
		    !  If this is underline text and the line attribute is not
		    !  top half then draw the underscore
		    !
		    IF .under_line
		    then begin

			!
			!  Put draw curve information into descriptor: 
			!	Path,pattern,mask,Pattern state
			!

			!
			!  DSC [0] - DSC [2] = path
			!
			PATH [0] = .VD_OFF_X;
			PATH [1] = $get_y (.ROW+1) - 2;
			PATH [2] = 2;
			PATH [3] = $get_x (.COLUMN + .chars_to_print);
			PATH [4] = .PATH [1];
			PATH [5] = 0;

			IF (.line_state [.row-1] NEQ vt$k_single)
			then PATH [3] = .PATH [3] * 2;

			!
			!  DSC [3] = mask rectangle
			!
			PATH [6] = 1;
			PATH [7] = 1;
			
			!
			!  DSC [3] - DSC [4] = pattern block has same values 
			!  as msk
			!
			PATH [8] = 1;
	
			!
			!  DSC [5] = pattern state
			!
			PATH [9] = 0;
			PATH [10] = 0;

			if (.REND_ROW[ .COLUMN - 1] AND VT$M_REVERSE) neq 0
			then begin
			    if .VTDB [VT$V_SCREEN_BACKGROUND] 
			    then w_color = 1
			    else w_color = 0
			    end
			else begin
			    if .VTDB [VT$V_SCREEN_BACKGROUND] 
			    then w_color = 0
			    else w_color = 1
			    end;

			$DRIVEDRAW(
				CHAN	= .VS$GW_VBCHAN,
				SRCTYP	= vsta$k_src_const,
				SOURCE	= .W_COLOR,
				MSKTYP	= VSTA$K_MSK_RECTANGLE,
				MASK	= DSC [3],
				PTHNUM	= 2,
				PTHADR	= DSC [0],
				PATBLK	= DSC [3],
				PATSTA	= DSC [5],
				DST	= .VSTA$A_FRAME_BUFFER [0],
				DSTOFX	= .rcs [3],
				DSTOFY	= .rcs [4],
				RECNUM	= .RCS [5],
				RECADR	= RCS [6]
				,efn = 7
				   );
			end;	! End of for each underline

		    RCS = .NEXT_RCS;

		    end;		! End of printing in each rectangle
		end;		! End of printing non blank characters

	    !
	    !  Update the number of characters to span
	    !
	    CHARS_TO_SPAN = .CHARS_TO_SPAN - .CHARS_TO_PRINT;
	    COLUMN = .COLUMN + .CHARS_TO_PRINT;
	    end;			! End of printing all chars in line

	!
	!  Flush all previous operations and deallocate the rectangle lists
	!  when done.
	!
	$DRIVENOOP(
		 CHAN	= .VS$GW_VBCHAN
		,ASTADR = VT$$DT_COMPLETION_ROUTINE
		,ASTPRM	= .DST_RCSQ [0]
		  );

        end;					! End of intersection found

    end;					! End of printing each line


return SS$_NORMAL;

end;



%sbttl 'VT$$DT_REDISPLAY_vd -- Replay vt100 data'
global routine VT$$DT_REDISPLAY_vd (
				 VD_id
				) =
!
!  This routine scans the vt100 data base and replays its contents
!
begin

local
	    id : ref device_data_table,
	    s;
!
! Find vt100 database associated with this terminal.
! For now, we quietly return if we can't find it.  Such would be the
! case during logout, during which we get called after terminal has
! gone away.
!
	if not (s = find_vt100 (.vd_id, id))
	then return ss$_normal;


	vt$$dt_redisplay_screen (.id);

	return SS$_NORMAL;

end;



%sbttl 'VT$$DT_COMPLETION_ROUTINE -- Clean up after graphics operation'
routine VT$$DT_COMPLETION_ROUTINE (
				 RCS		: ref vector [,long]
				,STATUS
				) =
!
!  This routine cleans up the rectangle lists used in the last operation
!
begin

local
	 BASE
	,NEXT_RCS
	;

!
!  Base gets the address of base of the queue.  Note that the base no longer
!  exists but that the queue is still pointing to it
!
BASE = .RCS [1];

until .RCS eql .BASE
do begin
	NEXT_RCS = .RCS [0];
	VS$$ACP_FREE_VM( RCS [2], RCS , 0);
	RCS = .NEXT_RCS;	
   end;

return SS$_NORMAL;

end;




%sbttl 'VT$$DT_INIT_FONTS -- Initialize all vt100 fonts'
routine VT$$DT_INIT_FONTS(
				 VTDB: ref device_data_table
				) =
!
!  This routine scans the vt100 data base and replays its contents
!
begin

local

	 FIB_ADR		: ref FIB
	,FIB_ID
	,S
	;

!
!  See if fonts are defined
!
if .VT$B_FONTS_DEFINED
then return SS$_NORMAL;

!
!  Loop through all fonts and get their address
!
incr I from 0 to VT$K_NUMBER_OF_FONTS - 1
do begin

    bind
	 FONT_DESCRIPTOR = VT$LV_FONT_DESCRS [.I^1]: VECTOR [2,LONG]
	;

    !
    !  Get the address of the font descriptor and the font image block id
    !
    if not (S = VS$$TXT_GET_FONT_ADDRESS(
				 0			! No vd_id system font
				,.VT$AV_FONT_NAMES[ .I] ! Typeface name
				,.VT$L_FONT_SIZE	! Size
				,.VT$LV_FONT_RENDS[ .I]	! No rendition
				,FONT_DESCRIPTOR [0]	! Return addr of font
				,FIB_ID			! REturn addr fib
				))
    then return .S;

    !
    !  Note that get font address increments the font reference count
    !  So call font dereference.
    !
    FIBDEREFERENCE ( .FIB_ID);
 
    !
    !  Get the address of the font image block
    !
    if not (S = FINDFIB( .FIB_ID, FIB_ADR, 0))
    then return .S;

    !
    !  If the font resides in display mem then save the address in
    !  in the font descriptor 
    !
    if .FIB_ADR [ FIB_DISPLAY_ADR] neq 0
    then begin
	FONT_DESCRIPTOR [0] = .FIB_ADR [ FIB_DISPLAY_ADR];
	FONT_DESCRIPTOR [1] = VSTA$K_DISPMEM;
    end
    else begin
	FONT_DESCRIPTOR [1] = VSTA$K_VAXMEM;
    end;

   end;				! End of defining all fonts


!
!  Tell the world that the vt100 fonts are defined
!
VT$B_FONTS_DEFINED = 1;

return SS$_NORMAL;

end;


%sbttl 'VT$$DT_GET_FONT -- Initialize all vt100 fonts'
routine VT$$DT_GET_FONT(
				 VTDB		: ref device_data_table
				,ROW
				,COLUMN
				,RET_FONT_DESC_ADR
				) =
!
!  This routine scans the vt100 data base and replays its contents
!
begin

local
	 FONT_INDX
	,s
	;

bind
	 ROW_TABLE = VTDB [VT$B_ROW_TABLE] : vector [,byte]
	,REND_ROW = .VTDB [VT$A_REND_TABLE] + (.ROW_TABLE [.ROW - 1]) * 
		.VTDB [VT$L_EXTREME_RIGHT] 	: vector [,byte]
	,LINE_STATE = VTDB [VT$B_LINE_STATE] 	: vector [,byte];
	;

!
!  Make sure fonts are initialized.
!
IF VT$B_FONTS_DEFINED EQL 0
THEN IF NOT (s = VT$$DT_INIT_FONTS ( .VTDB ) ) THEN RETURN .s;

!
!  Initialize the font index to 0
!
FONT_INDX = 0;

!
!  Get line attribute index
!
selectone .LINE_STATE [ .ROW - 1 ]
of set
	[VT$K_SINGLE]	: FONT_INDX = .FONT_INDX + VT$K_SINGLE_FONT_INDEX;
	[VT$K_DWIDTH]	: FONT_INDX = .FONT_INDX + VT$K_DWIDTH_FONT_INDEX;
	[VT$K_DHTOP]	: FONT_INDX = .FONT_INDX + VT$K_DHTOP_FONT_INDEX;
	[VT$K_DHBOT]	: FONT_INDX = .FONT_INDX + VT$K_DHBOT_FONT_INDEX;
   tes;

!
!  Add line rendition index to character rendition index to get address of font
!
!selectone .REND_ROW [ .COLUMN - 1]
!of set
!	[VT$M_BOLD]	: FONT_INDX = .FONT_INDX + VT$K_BOLD_FONT_INDEX;
!	[VT$M_BLINK]	: FONT_INDX = .FONT_INDX + VT$K_BLINK_FONT_INDEX;
!	[OTHERWISE]	: FONT_INDX = .FONT_INDX;
!   tes;
IF ( .rend_row [.column - 1] AND vt$m_bold ) NEQ 0
THEN FONT_INDX = .FONT_INDX + VT$K_BOLD_FONT_INDEX;

IF ( .rend_row [.column - 1] AND vt$m_blink ) NEQ 0
THEN FONT_INDX = .FONT_INDX + VT$K_BLINK_FONT_INDEX;

.RET_FONT_DESC_ADR = VT$LV_FONT_DESCRS [ .FONT_INDX ^ 1];


return SS$_NORMAL;

end;


%sbttl  'VT$$DT_SCROLL_VT100 -- Scrolls vt100 virtual display up or down'
global routine VT$$DT_SCROLL_VT100(
				 VTDB		: ref DEVICE_DATA_TABLE
				,UP_OR_DOWN
				,top_line
				,count) =
!
!  Functional Description
!
!
!  This routine manipulates the vt100 data base to perform a scroll operation
!  To do this it must rotate the row table around the scrolling region.
!  The row entries taken off the end of the scrolling region must be added
!  to the beginning of the scrolling region and the line and row attributes
!  must be cleared.
!
begin

local
	 SAVED_ROWS : vector [vt$k_maximum_rows,byte]
	,saved_states : vector [vt$k_maximum_rows,byte]
	,i
	;

bind
	 ROW_TABLE = VTDB [VT$B_ROW_TABLE] : vector [,byte]
	,line_state = vtdb [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	;

!
!  Are we going up or down
!
if .UP_OR_DOWN
then begin

    !
    !  Scroll up.
    !  Save row table entries of scrolling region
    !
    CH$MOVE(
		 .vtdb [vt$l_bottom_margin] - .top_line + 1
		,row_table [ .top_line - 1 ]
		,saved_rows
		);

    CH$MOVE(
		 .vtdb [vt$l_bottom_margin] - .top_line + 1
		,line_state [ .top_line - 1 ]
		,saved_states
		);

    !
    !  Shift row table up in scrolling region
    !
    CH$MOVE( 
		 .vtdb[vt$l_bottom_margin] - .top_line - .count + 1
		,saved_rows [ .count ]
		,ROW_TABLE [ .TOP_line - 1 ]
		);

    CH$MOVE( 
		 .vtdb[vt$l_bottom_margin] - .top_line - .count + 1
		,saved_states [ .count ]
		,line_state [ .TOP_line - 1 ]
		);

    !
    !  Store saved row table entries at bottom of scrolling region
    !
    CH$MOVE(
		 .count
		,saved_rows
		,row_table [ .vtdb [vt$l_bottom_margin] - .count ]
		);


    CH$FILL (
		 vt$k_single
		,.count
		,line_state [ .vtdb [vt$l_bottom_margin] - .count ]
		);

    end

else begin
    !
    !  Scroll down.
    !  Save row table entries of scrolling region
    !
    CH$MOVE(
		 .vtdb [vt$l_bottom_margin] - .top_line + 1
		,row_table [ .top_line - 1 ]
		,saved_rows
		);

    CH$MOVE(
		 .vtdb [vt$l_bottom_margin] - .top_line + 1
		,line_state [ .top_line - 1 ]
		,saved_states
		);

    !
    !  Shift row table down in scrolling region
    !
    CH$MOVE( 
		 .vtdb [vt$l_bottom_margin] - .top_line - .count + 1
		,saved_rows
		,ROW_TABLE [ .TOP_line + .count - 1 ]
		);

    CH$MOVE( 
		 .vtdb [vt$l_bottom_margin] - .top_line - .count + 1
		,saved_states
		,line_state [ .TOP_line + .count - 1 ]
		);

    !
    !  Store saved row table entry at top of scrolling region
    !
    CH$MOVE(
		 .count
		,saved_rows[.vtdb[vt$l_bottom_margin] - .top_line - .count+1]
		,row_table [ .top_line - 1 ]
		);


    CH$FILL (
		 vt$k_single
		,.count
		,line_state [ .top_line - 1 ]
		);

    !
    !  Adjust saved table for ease in clearing
    !
    CH$MOVE(
		.count
		,row_table [.top_line - 1]
		,saved_rows
		);

    end;				! End of scrolling down

!
!  Clear character attributes for new lines
!
INCR i FROM 0 TO ( .count - 1 ) DO
    begin
    !
    !  Fill new character renditions with blank
    !
    CH$FILL (
		 VT$M_BLANK				! Blank attribute
		,.VTDB [VT$L_EXTREME_RIGHT]		! All of line
		,.VTDB [VT$A_REND_TABLE] + 
		   ( .SAVED_ROWS [.i] ) * ( .VTDB [VT$L_EXTREME_RIGHT])
		);
    end;

return SS$_NORMAL;

end;



%sbttl  'VT$$DT_SCROLL_SCREEN -- Scrolls vt100 virtual display up or down'
global routine VT$$DT_SCROLL_SCREEN(
				 VTDB		: ref DEVICE_DATA_TABLE
				,UP_OR_DOWN
				,top_line
				,count
				) =
!
!  Functional Description
!
begin

local
	 SRC_RC		: vector [4,word,signed]
	,SRC_RCSQ	: vector [2,long]
	,CLIP_RCSQ	: ref vector [,long]
	,SAVED_RCSQ	: vector [2,long]
	,TXT_RCSQ	: vector [2,long] 
	,TXT_RCS	: ref vector [,long]
	,TXT_REC_LIST	: ref vector [,word,signed]
	,TXT_REC_INDEX
	,DY		: signed
	,RCS		: ref vector [,long]
	,NEXT_RCS
	,X_FROM
	,Y_FROM
	,X_TO
	,Y_TO
	;

builtin
	 insque
	,remque
	;

bind	line_state = vtdb [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE];

!
!  Get the vd clipping rectangles
!		
VSTA$$VDS_GET_VD_RC_LISTS( .VTDB [VT$L_VIRTUAL_DISPLAY_ID], CLIP_RCSQ);

!
!  If the clipping rectangle list is empty then vt100 is not visible on screen
!
if .CLIP_RCSQ [0] eql CLIP_RCSQ [0]
then return SS$_NORMAL;

!
!  Find the distance to be scrolled + or -
!  & Determine the upper left & lower right corners of box to be scrolled
!
if .UP_OR_DOWN
then begin
    DY = -.VT$L_FONT_HEIGHT * .count;

    X_FROM = $get_x (1);
    Y_FROM = $get_y (.toP_line);

    X_TO = $get_x (.VTDB [VT$L_EXTREME_RIGHT] + 1);
    Y_TO = $get_y (.vtdb [vt$l_bottom_margin] + 1);

    end

else begin
    DY = .VT$L_FONT_HEIGHT * .count;

    X_FROM = $get_x (1); 
    Y_FROM = $get_y (.toP_line);

    X_TO = $get_x (.VTDB [VT$L_EXTREME_RIGHT] + 1);
    Y_TO = $get_y (.vtdb [vt$l_bottom_margin] + 1);

    end;

src_RC [0] = .X_from;
src_RC [1] = .Y_from;
src_RC [2] = .x_to - .x_from;
SRC_RC [3] = .Y_TO - .Y_FROM;

!
!  Intersect the source rectangle with the vd clipping rectangles
!
VSTA$$RCS_INTER_LIST_WITH_LISTS( 1, SRC_RC [0], CLIP_RCSQ [0], SRC_RCSQ [0]);

!
!  If the result is null then just return
!
if .SRC_RCSQ [0] eql SRC_RCSQ [0]
then return SS$_NORMAL;

!
!  Init the text recovery rectangle lists queue
!
TXT_RCSQ [0] = TXT_RCSQ [0];
TXT_RCSQ [1] = TXT_RCSQ [0];

!
!  Now for each clipping rectangle list move up the rectangle on the screen
!
RCS = .SRC_RCSQ [0];

until .RCS eql SRC_RCSQ [0]
do begin
    bind 
	 SRC_RCS = RCS [6]: vector [,word,signed]
	;

    !
    !  Get vm for text recovery rectangles
    !
    VS$$ACP_GET_VM( RCS [2], TXT_RCS, 0);
    TXT_RCS [2] = .RCS [2];
    TXT_RCS [3] = .RCS [3];
    TXT_RCS [4] = .RCS [4];
    TXT_RCS [5] = .RCS [5];
    TXT_REC_LIST = TXT_RCS [6];
    TXT_REC_INDEX = 0;

    !
    !  Put the new list in the TXT_RCSQ
    !
    insque( TXT_RCS [0], .TXT_RCSQ [1]);

    !
    !  Process each scrolling rectangle.  MOve the region up by  .DY distance:
    !  NOte .DY may be negative.
    !
    incr I from 0 to (.RCS [5] - 1) * 4 by 4
    do begin
	!
	!  Move the region desired
	!
	$DRIVECOPY(
			 CHAN	= .VS$GW_VBCHAN
			,SRCTYP = VSTA$K_SRC_BM
			,SOURCE	= .VSTA$A_FRAME_BUFFER [0]
			,SRCOFX = .SRC_RCS [.I]
			,SRCOFY = .SRC_RCS [.I + 1] 
			,MSKTYP	= VSTA$K_MSK_RECTANGLE
			,MASK	= SRC_RCS [.I + 2]
			,DST	= .VSTA$A_FRAME_BUFFER [0]
			,DSTOFX	= .SRC_RCS [.I]
			,DSTOFY	= .SRC_RCS [.I + 1] + .DY
			,RECNUM	= 1
			,RECADR	= SRC_RCS [.I]
			) ;

	!
	!  Determine the rectangle to fill with text if there is
	!  one.  Determine the direction of the scroll first.
	!
	if .DY lss 0
	then begin	! Scroll was in the upward direction.
	    !
	    !  Was the source rectangle clipped on the bottom
	    !
	    TXT_REC_LIST [.TXT_REC_INDEX] = .SRC_RCS [.I];
	    TXT_REC_LIST [.TXT_REC_INDEX + 2] = .SRC_RCS [.I + 2];
	    !
	    !  Determine the depth of the text recovery rectangle
	    !
	    TXT_REC_LIST [.TXT_REC_INDEX + 3] = MIN(-.DY,.SRC_RCS [.I + 3]);
	    !
	    !  Now determine the y offset of the rectangle
	    !
	    TXT_REC_LIST [.TXT_REC_INDEX + 1] = 
					.SRC_RCS [.I + 1] +
					.SRC_RCS [.I + 3] -
					.TXT_REC_LIST [.TXT_REC_INDEX + 3];

	    !
	    !  If the text recovery rectangle is at the bottom of the
	    !  source rectangle then don't recover the text in it.
	    !
	    if (.TXT_REC_LIST [.TXT_REC_INDEX + 1] + 
			    .TXT_REC_LIST [.TXT_REC_INDEX + 3]) eql
			   (.SRC_RC [1] + .SRC_RC [3] + .TXT_RCS [4]) 
	    then begin
		TXT_REC_INDEX = .TXT_REC_INDEX - 4;
		TXT_RCS [5] = .TXT_RCS [5] - 1;
		end;

	     end
	else begin	! Scrolling was downward.
	    !
	    !  Was the source rectangle clipped on the bottom
	    !
	    TXT_REC_LIST [.TXT_REC_INDEX] = .SRC_RCS [.I];
	    TXT_REC_LIST [.TXT_REC_INDEX + 2] = .SRC_RCS [.I + 2];
	    !
	    !  Determine the depth of the text recovery rectangle
	    !
	    TXT_REC_LIST [.TXT_REC_INDEX + 3] = MIN(.DY,.SRC_RCS [.I + 3]);
	    !
	    !  Now determine the y offset of the rectangle
	    !
	    TXT_REC_LIST [.TXT_REC_INDEX + 1] = .SRC_RCS [.I + 1];
	    !
	    !  If the text recovery rectangle is at the top of the
	    !  source rectangle then don't recover the text in it.
	    !
	    if .TXT_REC_LIST [.TXT_REC_INDEX+1] eql (.SRC_RC [1] + .TXT_RCS [4])
	    then begin
		TXT_REC_INDEX = .TXT_REC_INDEX - 4;
		TXT_RCS [5] = .TXT_RCS [5] - 1;
		end;
	     end;

	!
	!  Now increment the recovery rectangle pointer
	!
	TXT_REC_INDEX = .TXT_REC_INDEX + 4;

	end;	! End of processing each rectangle in list !
	!
	!  If no rectangles resulted the remove this list from the queue
	!  and deallocate the memory for it
	!
    if .TXT_REC_INDEX eql 0
    then begin
	local RL: ref vector [,long];

	REMQUE( .TXT_RCSQ [1], RL);
	VS$$ACP_FREE_VM( RL [2], RL, 0);
	end;

    !
    !  Next list
    !
    RCS = .RCS [0];

    end;	! End of processing each rectangle list for the vd !

!
!  If the scroll queue is not empty then redisplay the text
!
if .TXT_RCSQ [0] neq TXT_RCSQ [0]
then begin
    !
    !  Save old projection of the virtual display on screen. (i.e. its
    !  clipping rectangles.
    !
    VSTA$$VDS_SAVE_VD_RC_LISTS(.VTDB [VT$L_VIRTUAL_DISPLAY_ID],SAVED_RCSQ);
    !
    !  Put the text recovery rectangles in its place.
    !
    VSTA$$VDS_STORE_VD_RC_LISTS(.VTDB [VT$L_VIRTUAL_DISPLAY_ID], TXT_RCSQ);
    !
    !  Call the redisplay routine to replay the text into the specified
    !  rectangles
    !
    VT$$DT_REDISPLAY_SCREEN( .VTDB);
    !
    !  Restore the TXT_RCSQ to be deallocated
    !
    VSTA$$VDS_SAVE_VD_RC_LISTS ( .VTDB [VT$L_VIRTUAL_DISPLAY_ID], TXT_RCSQ);
    !
    !  Put the text recovery rectangles in its place.
    !
    VSTA$$VDS_STORE_VD_RC_LISTS( .VTDB [VT$L_VIRTUAL_DISPLAY_ID], SAVED_RCSQ);
    !
    !  Now we need to deallocate the TXT_RCSQ lists
    !
    RCS = .TXT_RCSQ [0];
    until .RCS eql TXT_RCSQ [0]
    do begin
	NEXT_RCS = .RCS [0];
	VS$$ACP_FREE_VM( RCS [2], RCS , 0);
	RCS = .NEXT_RCS;
	end;
    end;

!
!  Now deallocate the source rcs queue lists
!
RCS = .SRC_RCSQ [0];
until .RCS eql SRC_RCSQ [0]
do begin
    NEXT_RCS = .RCS [0];
    VS$$ACP_FREE_VM( RCS [2], RCS , 0);
    RCS = .NEXT_RCS;
    end;

!
!  Clear top or bottom line depending on direction of scroll
!
IF .up_or_down
THEN VT$$DT_CLEAR_SCREEN_RC(
			 .VTDB
			,.vtdb [vt$l_bottom_margin] - .count + 1
			,1
			,.vtdb [vt$l_bottom_margin]
			,.VTDB [VT$L_EXTREME_RIGHT]
		      )
ELSE VT$$DT_CLEAR_SCREEN_RC(
			 .VTDB
			,.top_line
			,1
			,.top_line + .count - 1
			,.VTDB [VT$L_EXTREME_RIGHT]
		      );
return ss$_normal;

end;


%sbttl 'VT$$DT_DISPLAY_SCREEN_line -- Replay vt100 data'
routine VT$$DT_DISPLAY_SCREEN_line (
				 VTDB: ref device_data_table
				,start_row
				,start_column
				,nchars
				) =
!
!  This routine scans the vt100 data base and replays its contents for one line
!
begin

local
	 COLUMN
	,FONT
	,CHARS_TO_SPAN
	,CHARS_TO_PRINT
	,CHAR_POS
	,DEST_OFFSET	: vector [2,word]
	,CLIP_RCSQ	: ref vector [,long]
	,DST_RCSQ	: vector [2,long]
	,ROW_RC		: vector [4,word]
	,NEXT_RCS
	,RCS		: ref vector [,long]
	,VD_OFF_X
	,VD_OFF_Y
	,MAP_VALUE
	,MAP_TYPE
	,TEXT_BCNT
	,TEXT_ADDR
	,dsc		: vector [6,long]
	,w_color
	,msk		: vector [2,word]
	,under_line
	;

bind
	 ROW_TABLE	= VTDB [VT$B_ROW_TABLE]: vector [,byte]
	,line_state = vtdb [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	,PATH = DSC [0]: VECTOR [,WORD]
	;

!
! Get the clipping rectangles
!
VSTA$$VDS_GET_VD_RC_LISTS( .VTDB [VT$L_VIRTUAL_DISPLAY_ID], CLIP_RCSQ);

!
!  If there are no clipping rectangles then just return success
!
if .CLIP_RCSQ [0] eql CLIP_RCSQ [0]
then return SS$_NORMAL;

!
!
begin

    bind
	 TEXT_ROW = .VTDB [VT$A_TEXT_TABLE] +
		   (.ROW_TABLE [ .start_ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
		   : vector [,byte]
	,REND_ROW = .VTDB [VT$A_REND_TABLE] +
		   (.ROW_TABLE [ .start_ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
		   : vector [,byte]
	;
    IF (.line_state [.start_row-1] EQL vt$k_dhtop)
    THEN under_line = 0 ELSE under_line = 1;
!
!  Calculate the ROW rectangle
!
!  Get the x,y position of the text to be printed
!
    ROW_RC [0] = $get_x (.start_column);
    ROW_RC [1] = $get_y (.start_ROW);
    ROW_RC [2] = .nchars *  .VT$L_FONT_WIDTH;
    ROW_RC [3] = .VT$L_FONT_HEIGHT;

    IF (.line_state [.start_row-1] NEQ vt$k_single)
    then begin
	if (.start_column gtr 1) then row_rc [0] = 2 * .row_rc [0];
	row_rc[2] = 2 * .row_rc [2];
	end;
!
!  intersect the rectangle that represents the current row with
!  the clipping rectangle lists and use the resulting lists to
!  perform the print text etc...
!
    VSTA$$RCS_INTER_LIST_WITH_LISTS( 1, ROW_RC [0], CLIP_RCSQ [0], 
						DST_RCSQ [0]);

!
!  Check to see if the DST_RCSQ is empty,  if so then skip this
!  row.
!
    if .DST_RCSQ [0] neq DST_RCSQ [0]
    then begin			! Intersection found

	!
	!  Initialize column pointer and character count
	!
	COLUMN = .start_column;
	CHARS_TO_SPAN = .nchars;
	while .CHARS_TO_SPAN GTR 0
	do begin			! Print all chars in line

	    CHAR_POS = CH$FIND_NOT_CH( 
			 .CHARS_TO_SPAN
			,REND_ROW [ .COLUMN - 1]
			,.REND_ROW [ .COLUMN - 1]
				      );

	    if CH$FAIL( .CHAR_POS)
	    then CHARS_TO_PRINT = .CHARS_TO_SPAN
	    else CHARS_TO_PRINT = .CHAR_POS - REND_ROW [ .COLUMN - 1];

	    !
	    !  Find font to use.  Look into the font table according to
	    !  line and character rendition.
	    !
	    VT$$DT_GET_FONT ( .VTDB, .start_ROW, .COLUMN, FONT);

	    !
	    !  Get the x,y position of the text to be printed
	    !
	    VD_OFF_X = $get_x (.COLUMN);
	    VD_OFF_Y = $get_y (.start_ROW);

	    IF (.line_state [.start_row-1] NEQ vt$k_single) AND (.column GTR 1)
	    THEN vd_off_x = 2 * .vd_off_X;

	    !
	    !
	    !  Set up print text
	    !
	    TEXT_BCNT = .CHARS_TO_PRINT;
	    TEXT_ADDR = TEXT_ROW [ .COLUMN - 1];
		
	    !
	    !  determine mapping function based on screen color
	    !  and whether rendition is reverse-video
	    !
	    if (.REND_ROW[ .COLUMN - 1] AND VT$M_REVERSE) neq 0
	    then begin
		if .VTDB [VT$V_SCREEN_BACKGROUND] 
		then begin
		    MAP_TYPE = VSTA$K_MAP_IDENTITY;
		    end
		else begin
		    MAP_TYPE = VSTA$K_MAP_SOURCEDEST;
		    MAP_VALUE = VSTA$K_MAP_NOTSRC;
		    end
		end
	    else begin
		if .VTDB [VT$V_SCREEN_BACKGROUND] 
		then begin
		    MAP_TYPE = VSTA$K_MAP_SOURCEDEST;
		    MAP_VALUE = VSTA$K_MAP_NOTSRC;
		    end
		else begin
		    MAP_TYPE = VSTA$K_MAP_IDENTITY;
		    end;
		end;


	    IF .under_line AND ( .line_state [.start_row-1] NEQ vt$k_dhtop )
	       AND ((.REND_ROW [.COLUMN - 1] AND VT$M_underline) neq 0)
	    THEN under_line = 1 ELSE under_line = 0;
	    !
	    !  If the rendition is not blank then print text etc...
	    !
	    if (.REND_ROW[ .COLUMN - 1] and VT$M_BLANK) eql 0
	    then begin
		!
		! for each clipping rectangle print the text etc...
		!
		RCS = .DST_RCSQ [0];

		until .RCS eql DST_RCSQ [0]
		do begin		! Print in each rectangle
		    NEXT_RCS = .RCS [0];
		    DEST_OFFSET [0] = .VD_OFF_X + .RCS [ 3];
		    DEST_OFFSET [1] = .VD_OFF_Y + .RCS [ 4];

		    !
		    !  Do print text
		    !
		    $DRIVEPRINT(
				 CHAN	= .VS$GW_VBCHAN
				,SRCTYP = VSTA$K_SRC_FONT_BITMAP
				,SOURCE = .FONT
				,DST	= .VSTA$A_FRAME_BUFFER [0]
				,DSTOFF	= DEST_OFFSET [0]
				,MAPTYP	= .MAP_TYPE
				,MAPVAL	= .MAP_VALUE
				,TXTNUM	= .TEXT_BCNT
				,TXTADR = .TEXT_ADDR
				,RECNUM	= .RCS [5]
				,RECADR = RCS [6]
				) ;

		    !
		    !  If this is underline text and the line attribute is not
		    !  top half then draw the underscore
		    !
		    IF .under_line
		    then begin

			!
			!  Put draw curve information into descriptor: 
			!	Path,pattern,mask,Pattern state
			!

			!
			!  DSC [0] - DSC [2] = path
			!

			PATH [0] = .VD_OFF_X;
			PATH [1] = $get_y (.start_ROW+1) - 2;
			PATH [2] = 2;
			PATH [3] = $get_x (.COLUMN + .chars_to_print);
			PATH [4] = .PATH [1];
			PATH [5] = 0;
	
			IF (.line_state [.start_row-1] NEQ vt$k_single)
			then PATH [3] = .PATH [3] * 2;

			!
			!  DSC [3] = mask rectangle
			!
			PATH [6] = 1;
			PATH [7] = 1;
			
			!
			!  DSC [3] - DSC [4] = pattern block has same values 
			!  as msk
			!
			PATH [8] = 1;
	
			!
			!  DSC [5] = pattern state
			!
			PATH [9] = 0;
			PATH [10] = 0;

			if (.REND_ROW[ .COLUMN - 1] AND VT$M_REVERSE) neq 0
			then begin
			    if .VTDB [VT$V_SCREEN_BACKGROUND] 
			    then w_color = 1
			    else w_color = 0
			    end
			else begin
			    if .VTDB [VT$V_SCREEN_BACKGROUND] 
			    then w_color = 0
			    else w_color = 1
			    end;

			$DRIVEDRAW(
				CHAN	= .VS$GW_VBCHAN,
				SRCTYP	= vsta$k_src_const,
				SOURCE	= .W_COLOR,
				MSKTYP	= VSTA$K_MSK_RECTANGLE,
				MASK	= DSC [3],
				PTHNUM	= 2,
				PTHADR	= DSC [0],
				PATBLK	= DSC [3],
				PATSTA	= DSC [5],
				DST	= .VSTA$A_FRAME_BUFFER [0],
				DSTOFX	= .rcs [3],
				DSTOFY	= .rcs [4],
				RECNUM	= .RCS [5],
				RECADR	= RCS [6]
				,efn = 7
				   );
			end;	! end of for each underline


		    RCS = .NEXT_RCS;

		    end;		! End of printing in each rectangle

		end		! End of printing non blank characters
		
	    else begin

		!
		!  Determine the mask rectangle
		!
		MSK [0] = .VT$L_FONT_WIDTH * .nchars;
		IF (.line_state [.start_row-1] neq vt$k_single)
			and (.start_column gtr 1)  THEN msk [0] = 2 * .msk[0];
		MSK [1] = .VT$L_FONT_HEIGHT;

		!
		!  Now for each clipping rectangle erase the text
		!
		RCS = .DST_RCSQ [0];

		until .RCS eql DST_RCSQ [0]
		do begin			! Clear each screen instance

		    NEXT_RCS = .RCS [0];

		    !
		    !  Do copy area
		    !
		    $DRIVECOPY(
			 	 CHAN	= .VS$GW_VBCHAN
				,SRCTYP = VSTA$K_SRC_CONST
				,SOURCE = (if .VTDB [VT$V_SCREEN_BACKGROUND] 
						then 1 else 0)
				,MSKTYP	= VSTA$K_MSK_RECTANGLE
				,MASK	= MSK [0]
				,DST	= .VSTA$A_FRAME_BUFFER [0]
				,DSTOFX = .RCS [3] + .vd_off_x
				,DSTOFY = .RCS [4] + .vd_off_y
				,RECNUM	= .RCS [5]
				,RECADR = RCS [6]
				);

		    RCS = .NEXT_RCS;

		    end;	! of clearing all rectangles

		end;		! of blank characters

	    !
	    !  Update the number of characters to span
	    !
	    CHARS_TO_SPAN = .CHARS_TO_SPAN - .CHARS_TO_PRINT;
	    COLUMN = .COLUMN + .CHARS_TO_PRINT;

	    end;			! End of printing all chars in line

	!
	!  Flush all previous operations and deallocate the rectangle lists
	!  when done.
	!
	$DRIVENOOP(
		 CHAN	= .VS$GW_VBCHAN
		,ASTADR = VT$$DT_COMPLETION_ROUTINE
		,ASTPRM	= .DST_RCSQ [0]
		  );

	end;				! End of intersection found

    end;				! End of printing each line


return SS$_NORMAL;

end;



%sbttl 'VT$$DT_display_VT100_line-- add a line of text to vt100 database'
routine VT$$DT_display_VT100_line(
				 VTDB: ref DEVICE_DATA_TABLE
				,row
				,column
			   ) =

begin

local	char_rend;

bind
	 ROW_TABLE = VTDB [VT$B_ROW_TABLE]: vector [,byte]
	,TEXT_ROW = .VTDB [VT$A_TEXT_TABLE] +
		   (.ROW_TABLE [ .ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
		   : vector [,byte]
	,REND_ROW = .VTDB [VT$A_REND_TABLE] +
		   (.ROW_TABLE [ .ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
		   : vector [,byte]
	,line_state = vtdb [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	;

!
! store text
!
CH$move (
	 .vtdb [vt$l_backlog_count]
	,.vtdb [vt$a_backlog]
	,text_row[.column-1]
	);

!
! store rendition
!
char_rend = 
	 ( (IF .vtdb [vt$v_bold] THEN vt$m_bold ELSE 0)
	 + (IF .vtdb [vt$v_underscore] THEN vt$m_underline ELSE 0)
	 + (IF .vtdb [vt$v_blink] THEN vt$m_blink ELSE 0)
	 + (IF .vtdb [vt$v_reverse] THEN vt$m_reverse ELSE 0 ));

CH$FILL (
	 .char_rend
	,.vtdb [vt$l_backlog_count]
	,rend_row [.column-1]
	);


RETURN SS$_NORMAL;

end;


%sbttl 'VT$$DT_erase_chars_VT100 -- Clear vt100 data base for a specified range'
routine VT$$DT_erase_chars_VT100(
				 VTDB: ref DEVICE_DATA_TABLE
				,row
				,start_column
				,end_column
			   ) =
!
!  This routine clears the vt100 data backing store for a specified range
!
begin

bind
	 ROW_TABLE = VTDB [VT$B_ROW_TABLE]: vector [,byte]
	,REND_ROW = .VTDB [VT$A_REND_TABLE] +
		   (.ROW_TABLE [ .ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
		   : vector [,byte]
	;

CH$FILL (
	 VT$M_BLANK
	,.end_column - .start_column + 1
	,rend_row [.start_column - 1]
	);

		
RETURN SS$_NORMAL;

end;

%sbttl 'VT$$DT_erase_chars_SCREEN -- Clear vt100 virtual display for specified range'
routine VT$$DT_erase_chars_SCREEN (
				 VTDB: ref DEVICE_DATA_TABLE
				,start_row
				,start_column
				,end_row
				,end_column
			   ) =
!
!  This routine clears the virtual display for specified range
!
begin

bind 	line_state = vtdb [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE];

local
	 CLIP_RCSQ	: vector [2,long]
	,RCS		: ref vector [,long]
	,SRC
	,NEXT_RCS
	,MSK		: vector [2,word]
	,row_offset
	;

!
!  If we have light background then do source is 1 otherwise the source is 0
!
if .VTDB [VT$V_SCREEN_BACKGROUND] 
then SRC = 1
else SRC = 0;

VSTA$$VDS_COPY_VD_RC_LISTS ( .VTDB [VT$L_VIRTUAL_DISPLAY_ID], CLIP_RCSQ);

!
! First row
!
row_offset = $get_y ( .start_row );

!
!  Determine the mask rectangle
!
MSK [0] = .VT$L_FONT_WIDTH *
		( IF (.line_state [.start_row-1] EQL vt$k_single)
			OR (.start_column EQL 1)
		  THEN 1
		  ELSE 2 ) *
		( ( IF  ( .end_row EQL .start_row )
		    AND ( .end_column LSS .vtdb [vt$l_extreme_right] )
		    THEN ( .end_column )
		    ELSE ( .VTDB [VT$L_EXTREME_RIGHT] ) )
	    - .start_column  + 1 ) + 1;

MSK [1] = .VT$L_FONT_HEIGHT;

!
!  Now for each clipping rectangle print the text etc...
!
RCS = .CLIP_RCSQ [0];

until .RCS eql CLIP_RCSQ [0]
do begin			! Clear each screen instance

    NEXT_RCS = .RCS [0];

    !
    !  Do copy area
    !
    $DRIVECOPY(
	 	 CHAN	= .VS$GW_VBCHAN
		,SRCTYP = VSTA$K_SRC_CONST
		,SOURCE = .SRC
		,MSKTYP	= VSTA$K_MSK_RECTANGLE
		,MASK	= MSK [0]
		,DST	= .VSTA$A_FRAME_BUFFER [0]
		,DSTOFX = .RCS [3] + 1
			+ .vt$l_font_width * (.start_column - 1)
			* (IF (.line_state [.start_row-1] EQL vt$k_single)
				OR (.start_column EQL 1)
			   THEN 1 ELSE 2 )
		,DSTOFY = .RCS [4] + .row_offset
		,RECNUM	= .RCS [5]
		,RECADR = RCS [6]
		);

    RCS = .NEXT_RCS;

    end;

row_offset = $get_y ( .start_row + 1 );

!
! Do the body of blank lines, if any
!
IF .start_row NEQ .end_row
THEN BEGIN
    !
    !  Determine the mask rectangle
    !
    MSK [0] = .VTDB [VT$L_BODY_WIDTH];
    MSK [1] = .VT$L_FONT_HEIGHT * 
			( ( IF   ( .end_column EQL .VTDB[VT$L_EXTREME_RIGHT] )
			    THEN ( .end_row + 1 )
			    ELSE ( .end_row ) )
			 -
			  ( IF   ( .start_column EQL 1 )
			    THEN ( .start_row )
			    ELSE ( .start_row + 1 ) ) ) ;

    !
    !  Now for each clipping rectangle print the text etc...
    !
    RCS = .CLIP_RCSQ [0];

    until .RCS eql CLIP_RCSQ [0]
    do begin			! Clear each screen instance

	NEXT_RCS = .RCS [0];
	!
	! Do copy area
	!
	$DRIVECOPY(
			 CHAN	= .VS$GW_VBCHAN
			,SRCTYP = VSTA$K_SRC_CONST
			,SOURCE = .SRC
			,MSKTYP	= VSTA$K_MSK_RECTANGLE
			,MASK	= MSK [0]
			,DST	= .VSTA$A_FRAME_BUFFER [0]
			,DSTOFX = .RCS [3]
			,DSTOFY = .RCS [4] + .row_offset
			,RECNUM	= .RCS [5]
			,RECADR = RCS [6]
			);

	RCS = .NEXT_RCS;

	end;
    !
    ! Do the last line to blank, if it's not done yet
    !
    IF (.end_column LSS .vtdb [vt$l_extreme_right]) AND (.end_column GTR 0)
    THEN BEGIN
	!
	!  Determine the mask rectangle
	!
	MSK [0] = .VT$L_FONT_WIDTH * ( .end_column + 1 ) *
			( IF .line_state [.end_row-1] EQL vt$k_single
			  THEN 1
			  ELSE 2 ) + 1;
	MSK [1] = .VT$L_FONT_HEIGHT;
	row_offset = $get_y ( .end_row );

	!
	!  Now for each clipping rectangle print the text etc...
	!
	RCS = .CLIP_RCSQ [0];

	until .RCS eql CLIP_RCSQ [0]
	do begin			! Clear each screen instance

	    NEXT_RCS = .RCS [0];

	    !
	    !  Do copy area
	    !
	    $DRIVECOPY(
			 CHAN	= .VS$GW_VBCHAN
			,SRCTYP = VSTA$K_SRC_CONST
			,SOURCE = .SRC
			,MSKTYP	= VSTA$K_MSK_RECTANGLE
			,MASK	= MSK [0]
			,DST	= .VSTA$A_FRAME_BUFFER [0]
			,DSTOFX = .RCS [3]
			,DSTOFY = .RCS [4] + .row_offset
			,RECNUM	= .RCS [5]
			,RECADR = RCS [6]
			);

	    RCS = .NEXT_RCS;

	    end;

	END;
    end;

!
!  Do a noop to deallocate rectangles
!
$DRIVENOOP(
	 CHAN	= .VS$GW_VBCHAN
	,ASTADR	= VT$$DT_COMPLETION_ROUTINE
	,ASTPRM	= .CLIP_RCSQ [0]
	  );

return SS$_NORMAL;

end;

%sbttl 'VT$$DT_delete_chars_VT102 -- does vt102 delete n chars'
routine VT$$DT_delete_chars_VT102(
				 VTDB: ref DEVICE_DATA_TABLE
				,start_row
				,start_column
				,nchars
			   ) =
!
!  This routine clears the vt102 delete n chars in database
!
begin

bind
	 ROW_TABLE = VTDB [VT$B_ROW_TABLE]: vector [,byte]
	,TEXT_ROW = .VTDB [VT$A_TEXT_TABLE] +
		   (.ROW_TABLE [ .start_ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
		   : vector [,byte]
	,REND_ROW = .VTDB [VT$A_REND_TABLE] +
		   (.ROW_TABLE [ .start_ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
		   : vector [,byte]
	,line_state = vtdb [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	;

local	 temp_text : vector[256,byte]	! made up number!  something big!
	,chars_to_move
	;


chars_to_move = .vtdb [vt$l_extreme_right] - .start_column - .nchars + 1;

!
! move the text
!
CH$MOVE(
	 .chars_to_move
	,text_row[.start_column] + .nchars - 1
	,temp_text [0]
	);

CH$MOVE (
	 .chars_to_move
	,temp_text [0]
	,text_row[.start_column] - 1
	);

!
! move the renditions
!
CH$MOVE(
	 .chars_to_move
	,rend_row[.start_column] + .nchars - 1
	,temp_text [0]
	);

CH$MOVE (
	 .chars_to_move
	,temp_text [0]
	,rend_row [.start_column] - 1
	);

!
! pad with blanks
!
CH$FILL (
	 VT$M_blank
	,.nchars
	,rend_row[.start_column] + .chars_to_move - 1
	);


RETURN SS$_NORMAL;

end;

%sbttl 'VT$$DT_delete_chars_screen - does vt102 delete chars function for screen'
routine VT$$DT_delete_chars_screen (
				 VTDB: ref device_data_table
				,start_row
				,start_column
				,nchars
				) =
!
!  This routine scans the vt100 data base and replays its contents for one line
!
begin

local
	 COLUMN
	,FONT
	,CHARS_TO_SPAN
	,CHARS_TO_PRINT
	,CHAR_POS
	,DEST_OFFSET	: vector [2,word]
	,CLIP_RCSQ	: ref vector [,long]
	,DST_RCSQ	: vector [2,long]
	,ROW_RC		: vector [4,word]
	,NEXT_RCS
	,RCS		: ref vector [,long]
	,VD_OFF_X
	,VD_OFF_Y
	,MAP_VALUE
	,MAP_TYPE
	,TEXT_BCNT
	,TEXT_ADDR
	,dsc		: vector [6,long]
	,w_color
	,under_line
	;

bind
	 ROW_TABLE	= VTDB [VT$B_ROW_TABLE]: vector [,byte]
	,line_state = vtdb [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	,PATH = DSC [0]: VECTOR [,WORD]
	;

!
! Get the clipping rectangles
!
VSTA$$VDS_GET_VD_RC_LISTS( .VTDB [VT$L_VIRTUAL_DISPLAY_ID], CLIP_RCSQ);

!
!  If there are no clipping rectangles then just return success
!
if .CLIP_RCSQ [0] eql CLIP_RCSQ [0]
then return SS$_NORMAL;

!
!
begin

    bind
	 TEXT_ROW = .VTDB [VT$A_TEXT_TABLE] +
		   (.ROW_TABLE [ .start_ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
		   : vector [,byte]
	,REND_ROW = .VTDB [VT$A_REND_TABLE] +
		   (.ROW_TABLE [ .start_ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
		   : vector [,byte]
	;

!
!  Calculate the ROW rectangle
!
!  Get the x,y position of the text to be printed
!

    ROW_RC [0] = $get_x (.start_column);
    ROW_RC [1] = $get_y (.start_ROW);
    ROW_RC [2] = .nchars * .VT$L_FONT_WIDTH;
    ROW_RC [3] = .VT$L_FONT_HEIGHT;

    IF (.line_state [.start_row-1] neq vt$k_single)
    then begin
	if (.start_column gtr 1 ) then row_rc [0] = .row_rc[0] * 2;
	row_rc [2] = .row_rc [2] * 2;
	end;

!
!  intersect the rectangle that represents the current row with
!  the clipping rectangle lists and use the resulting lists to
!  perform the print text etc...
!
    VSTA$$RCS_INTER_LIST_WITH_LISTS( 1, ROW_RC [0], CLIP_RCSQ [0], 
						DST_RCSQ [0]);

!
!  Check to see if the DST_RCSQ is empty,  if so then skip this
!  row.
!
    if .DST_RCSQ [0] neq DST_RCSQ [0]
    then begin			! Intersection found

	!
	!  Initialize column pointer and character count
	!
	COLUMN = .start_column;
	CHARS_TO_SPAN = .nchars;
	while .CHARS_TO_SPAN GTR 0
	do begin			! Print all chars in line

	    CHAR_POS = CH$FIND_NOT_CH( 
			 .CHARS_TO_SPAN
			,REND_ROW [ .COLUMN - 1]
			,.REND_ROW [ .COLUMN - 1]
				      );

	    if CH$FAIL( .CHAR_POS)
	    then CHARS_TO_PRINT = .CHARS_TO_SPAN
	    else CHARS_TO_PRINT = .CHAR_POS - REND_ROW [ .COLUMN - 1];

	    !
	    !  Find font to use.  Look into the font table according to
	    !  line and character rendition.
	    !
	    VT$$DT_GET_FONT ( .VTDB, .start_ROW, .COLUMN, FONT);

	    !
	    !  Get the x,y position of the text to be printed
	    !
	    VD_OFF_X = $get_x (.COLUMN);
	    VD_OFF_Y = $get_y (.start_ROW);

	    IF (.line_state [.start_row-1] NEQ vt$k_single) AND (.column GTR 1)
	    THEN vd_off_x = 2 * .vd_off_X;

	    !
	    !
	    !  Set up print text
	    !
	    TEXT_BCNT = .CHARS_TO_PRINT;
	    TEXT_ADDR = TEXT_ROW [ .COLUMN - 1];
		
	    !
	    !  determine mapping function based on screen color
	    !  and whether rendition is reverse-video
	    !
	    if (.REND_ROW[ .COLUMN - 1] AND VT$M_REVERSE) neq 0
	    then begin
		if .VTDB [VT$V_SCREEN_BACKGROUND] 
		then begin
		    MAP_TYPE = VSTA$K_MAP_IDENTITY;
		    end
		else begin
		    MAP_TYPE = VSTA$K_MAP_SOURCEDEST;
		    MAP_VALUE = VSTA$K_MAP_NOTSRC;
		    end
		end
	    else begin
		if .VTDB [VT$V_SCREEN_BACKGROUND] 
		then begin
		    MAP_TYPE = VSTA$K_MAP_SOURCEDEST;
		    MAP_VALUE = VSTA$K_MAP_NOTSRC;
		    end
		else begin
		    MAP_TYPE = VSTA$K_MAP_IDENTITY;
		    end;
		end;


	    IF ( .line_state [.start_row-1] NEQ vt$k_dhtop )
	       and ((.REND_ROW[ .COLUMN - 1] AND VT$M_underline) neq 0)
	    THEN under_line = 1 ELSE under_line = 0;
	    !
	    !  If the rendition in not blank then print text etc...
	    !
	    if (.REND_ROW[ .COLUMN - 1] and VT$M_BLANK) eql 0
	    then begin
		!
		! for each clipping rectangle print the text etc...
		!
		RCS = .DST_RCSQ [0];

		until .RCS eql DST_RCSQ [0]
		do begin		! Print in each rectangle
		    NEXT_RCS = .RCS [0];
		    DEST_OFFSET [0] = .VD_OFF_X + .RCS [ 3];
		    DEST_OFFSET [1] = .VD_OFF_Y + .RCS [ 4];

		    !
		    !  Do print text
		    !
		    $DRIVEPRINT(
				 CHAN	= .VS$GW_VBCHAN
				,SRCTYP = VSTA$K_SRC_FONT_BITMAP
				,SOURCE = .FONT
				,DST	= .VSTA$A_FRAME_BUFFER [0]
				,DSTOFF	= DEST_OFFSET [0]
				,MAPTYP	= .MAP_TYPE
				,MAPVAL	= .MAP_VALUE
				,TXTNUM	= .TEXT_BCNT
				,TXTADR = .TEXT_ADDR
				,RECNUM	= .RCS [5]
				,RECADR = RCS [6]
				) ;

		    !
		    !  If this is underline text and the line attribute is not
		    !  top half then draw the underscore
		    !
		    IF .under_line
		    then begin

			!
			!  Put draw curve information into descriptor: 
			!	Path,pattern,mask,Pattern state
			!

			!
			!  DSC [0] - DSC [2] = path
			!

			PATH [0] = .VD_OFF_X;
			PATH [1] = $get_y (.start_ROW+1) - 2;
			PATH [2] = 2;
			PATH [3] = $get_x (.COLUMN + .chars_to_print);
			PATH [4] = .PATH [1];
			PATH [5] = 0;
	
			IF .line_state [.start_row-1] NEQ vt$k_single
			then PATH [3] = .PATH [3] * 2;

			!
			!  DSC [3] = mask rectangle
			!
			PATH [6] = 1;
			PATH [7] = 1;
			
			!
			!  DSC [3] - DSC [4] = pattern block has same values 
			!  as msk
			!
			PATH [8] = 1;
	
			!
			!  DSC [5] = pattern state
			!
			PATH [9] = 0;
			PATH [10] = 0;

			if (.REND_ROW[ .COLUMN - 1] AND VT$M_REVERSE) neq 0
			then begin
			    if .VTDB [VT$V_SCREEN_BACKGROUND] 
			    then w_color = 1
			    else w_color = 0
			    end
			else begin
			    if .VTDB [VT$V_SCREEN_BACKGROUND] 
			    then w_color = 0
			    else w_color = 1
			    end;

			$DRIVEDRAW(
				CHAN	= .VS$GW_VBCHAN,
				SRCTYP	= vsta$k_src_const,
				SOURCE	= .W_COLOR,
				MSKTYP	= VSTA$K_MSK_RECTANGLE,
				MASK	= DSC [3],
				PTHNUM	= 2,
				PTHADR	= DSC [0],
				PATBLK	= DSC [3],
				PATSTA	= DSC [5],
				DST	= .VSTA$A_FRAME_BUFFER [0],
				DSTOFX	= .rcs [3],
				DSTOFY	= .rcs [4],
				RECNUM	= .RCS [5],
				RECADR	= RCS [6]
				,efn = 7
				   );
			end;	! end of for each underline

		    RCS = .NEXT_RCS;

		    end;		! End of printing in each rectangle

		end		! End of printing non blank characters


	    else vt$$dt_erase_chars_screen (
						 .vtdb
						,.start_row
						,.column
						,.start_row
						,.column + .chars_to_print - 1
						);
		
	    !
	    !  Update the number of characters to span
	    !
	    CHARS_TO_SPAN = .CHARS_TO_SPAN - .CHARS_TO_PRINT;
	    COLUMN = .COLUMN + .CHARS_TO_PRINT;

	    end;			! End of printing all chars in line

	!
	!  Flush all previous operations and deallocate the rectangle lists
	!  when done.
	!
	$DRIVENOOP(
		 CHAN	= .VS$GW_VBCHAN
		,ASTADR = VT$$DT_COMPLETION_ROUTINE
		,ASTPRM	= .DST_RCSQ [0]
		  );

	end;				! End of intersection found

    end;				! End of printing each line


return SS$_NORMAL;

end;



%sbttl 'VT$$DT_DECALN_VT100 -- Performs decaln test'
routine VT$$DT_DECALN_VT100(
				 VTDB: ref DEVICE_DATA_TABLE
			   ) =
!
!  This routine clears the vt100 data backing store
!
begin

bind
	 line_state = vtdb [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	,ROW_TABLE = VTDB [VT$B_ROW_TABLE]: vector [,byte]
	;
local	i;

!
!  Fill the rendition table with the vanilla attribute
!
CH$FILL (
	 0
	,.VTDB [VT$L_EXTREME_RIGHT] * .VTDB [VT$L_SCREEN_ABSOLUTE_BOTTOM]
	,.VTDB [VT$A_REND_TABLE]
	);

!
!  Clear the attributes
!
CH$FILL (
	 VT$K_SINGLE
	,VT$K_MAXIMUM_ROWS
	,line_state[0]
	);

!
!  Fill text table with E's
!
CH$FILL (
	 %c'E'
	,.VTDB [VT$L_EXTREME_RIGHT] * .VTDB [VT$L_SCREEN_ABSOLUTE_BOTTOM]
	,.VTDB [VT$a_text_table]
	);

!
!  Sort row_table.
!
INCR i from 0 to .vtdb [vt$l_screen_absolute_bottom] - 1
DO row_table [ .i] = .i;

RETURN SS$_NORMAL;

end;

%sbttl 'VT$$DT_SET_VT100_line_att -- changes line attribute in database'
routine VT$$DT_SET_VT100_line_att(
				 VTDB: ref DEVICE_DATA_TABLE
				,row
				,new_state
			   ) =
!
!
begin

VTDB [VT$B_LINE_STATE] + .row - 1 = .new_state;

RETURN SS$_NORMAL;

end;

%sbttl 'VT$$DT_insert_chars_vt102 -- insert or replacement mode'
routine VT$$DT_insert_chars_vt102(
				 VTDB: ref DEVICE_DATA_TABLE
				,start_row
				,start_column
			   ) =

begin

local	 num_chars
	,temp_text : vector[256,byte]	! made up number!  something big!
	;

bind
	 ROW_TABLE = VTDB [VT$B_ROW_TABLE]: vector [,byte]
	,TEXT_ROW = .VTDB [VT$A_TEXT_TABLE] +
		   (.ROW_TABLE [ .start_ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
		   : vector [,byte]
	,REND_ROW = .VTDB [VT$A_REND_TABLE] +
		   (.ROW_TABLE [ .start_ROW - 1])*.VTDB [VT$L_EXTREME_RIGHT]
		   : vector [,byte]
	,line_state = vtdb [vt$b_line_state]: VECTOR [vt$k_maximum_rows,BYTE]
	;


IF .line_state [.vtdb [vt$l_cursor_row]-1] NEQ vt$k_single
THEN 
  num_chars = .vtdb [vt$l_extreme_right] / 2 - .start_column - .vtdb [vt$l_backlog_count] + 1
ELSE 
  num_chars = .vtdb [vt$l_extreme_right] - .start_column - .vtdb [vt$l_backlog_count] + 1;

!
! store text
!
CH$move (
	 .num_chars
	,text_row [.start_column-1]
	,temp_text
	);

CH$move (
	 .vtdb [vt$l_backlog_count]
	,.vtdb [vt$a_backlog]
	,text_row [.start_column-1]
	);

CH$move (
	 .num_chars
	,temp_text
	,text_row [ .start_column + .vtdb [vt$l_backlog_count] - 1 ]
	);

!
! store rendition
!
CH$MOVE (
	 .num_chars
	,rend_row [.start_column-1]
	,temp_text
	);

CH$MOVE (
	 .num_chars
	,rend_row [.start_column-1]
	,rend_row [.start_column + .vtdb [vt$l_backlog_count] - 1 ]
	);

CH$FILL (
	 ( (IF .vtdb [vt$v_bold] THEN vt$m_bold ELSE 0)
	 + (IF .vtdb [vt$v_underscore] THEN vt$m_underline ELSE 0)
	 + (IF .vtdb [vt$v_blink] THEN vt$m_blink ELSE 0)
	 + (IF .vtdb [vt$v_reverse] THEN vt$m_reverse ELSE 0 ))
	,.vtdb [vt$l_backlog_count]
	,rend_row [.start_column - 1]
	);

RETURN SS$_NORMAL;

end;


end
eludom

